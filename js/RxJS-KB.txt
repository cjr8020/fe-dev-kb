
  @@@@@@@@@@@@@@@@@@@@@@@

      ReactiveX - RxJS

  @@@@@@@@@@@@@@@@@@@@@@@


ReactiveX

  is a library for composing asynchronous programs by using observable sequences.
  provides a long list of operators which allows us to filter, select, transform
  combine and compose observables.  


http://reactivex.io/rxjs/

Reactive programming with observable streams.

Observable is the key abstraction in this library.

An "observable" is a stream of events that we can process with array-like operators.

Stream

  a sequence of ongoing events ordered in time

  streams emit a value (data), error and complete signal (maybe)

  E.g. http.get is a stream that 
    - should return a value (data) or an error, and 
    - complete signal

Observables
  are used to watch these streams
  will emit a function when a value, error or completed signal is returned
  can be subscribed to by an Observer
  will constantly watch streams and will update accordingly.

  We can interact with these data streams via Observables as we would with an array.


  let source = Rx.Observable.from(...);

  let subscription = source.subscribe(
    value => console.log('next value: %s', value),
    error => console.log('error: %s', error),
    () => console.log('Completed.')
  );




================================================================================

  Advantages:

    - lazy by default

      Observables processing is "lazy" by default - nothing will happen
      until someone subscribes to it.


================================================================================

  Observable
  **********

from(ObservableInput<T>, Scheduler): Observable<T>
---------------------------------------------------------------------------

  creates an Observable from an Array, an array-like object, Promise, ...
  (optional) Scheduler - on which to schedule the emissions of values.

  e.g.:

    let observable = Observable.from(source);
    class MyObserver implements Observer<number> { .. }
    observable.subscribe(new MyObserver());


fromEvent
---------------------------------------------------------------------------

  creates an Obervable by attaching an event listener to an 'event target'
  which may be an 
  - object with 'addEventListener' and 'removeEventListener'
  - Node.js EventEmitter
  - a jQuery style EventEmitter
  - a NodeList or HTMLCollection from the DOM 

  the event handler is attached when the output  Observable is subscribed, 
  and removed when the Subscription is unsubscribed.

    var clicks = Rx.Observable.fromEvent(document, 'click');
    clicks.subscribe(x => console.log(x));


create
---------------------------------------------------------------------------
 
  create(subscribe: function(subscriber))

  subscribe - a function that accepts a Subscriber and invokes its 
              next(), error() and complete() methods

  create() converts a 'subscribe' function to an actual Observable.
  this is equivalent to calling an Observable constructor.
  write the 'subscribe' function so that it behaves as an Observable:
    - it should invoke the Suscriber's next(), error() and complete() methods.

  e.g.:

    let obserable = Observable.create(observer => {
      // do something
      observer.next(..);
      //
      observer.complete();
    });
    // subscribe an observer
    observable.subscribe(
      value => console.log(`value: ${value}`); // next() callback
      e => console.log(`error: ${e}`);         // error() callback
      () => console.log("i'm done");           // complete() callback




import {Observable} from 'rxjs';  

I can create an observable from something like:

an Array
a Promise or 
an Observable-like object.

Before I can use an Observable, I need to suscribe to it as an Observer.

An Observer needs three methods:

  next(value) 
    that's the method the Observable will invoke when there is a value to produce


  error(e) {
    console.log(`error: ${e}`);
  }

  /*
   * if an Observable knows it has exausted all of its resources
   * it can invoke complete method to indicate it's DONE
   */
  complete() {
    console.log("complete");
  }

Note every Observable datasource can complete, or as long as the app is running.


Observer without a class - just passing the Observer interface methods:

    let numbers = [1,2,3];
    let source = Observable.from(numbers);

    source.subscribe(
      value => console.log(`value: ${value}`),
      e => console.log(`error: ${e}`),
      () => console.log("complete")

    );


Observable.create()
-------------------

Observable is created using create() method within which it interacts with the
Observer object that is going to be passed it at subscribe time.

    let numbers = [1,2,3];
    let source = Observable.create(observer => {

      for (let n of numbers) {
        observer.next(n);
      }

      observer.complete();
    });

    source.subscribe(
      value => console.log(`value: ${value}`),
      e => console.log(`error: ${e}`),
      () => console.log("complete")

    );

Observable.finally()
--------------------

https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md

  Invokes a specified action after the source observable sequence terminates
  gracefully or exceptionally.   


    /* Terminated by error still fires function */
    var source = Rx.Observable.throw(new Error())
      .finally(function () { console.log('Finally'); });

    var subscription = source.subscribe(
      function (x) {
        console.log('Next: %s', x);
      },
      function (err) {
        console.log('Error: %s', err);
      },
      function () {
        console.log('Completed');
      });

    // => Error: Error
    // => Finally


finally() vs completed()
------------------------

  Finally always happens whenever an observable terminates (includuing errors).
  Completed only happens when it terminates without errors.

    OnCompleted
      called after onNext() is called for the last time.


================================================================================

  Using Observables with Promises
  *******************************

Promise
  resolves to a single value asynchronously
  e.g. response from an Ajax call

Observable
  resolves (or emits) multiple values asynchronously over time
  e.g. click events




================================================================================

  Fetch
  *****

WhatWG - web hypertext application technology working group

Fetch standard defines requests, responses, and the process that binds them: 
fetching.

supported natively in chrome:

> fetch
  function fetch() { [native code] }
> fetch("movies.json")
  Promise{..}



================================================================================

  Observer
  ********

next(value: T): void
  - the callback to receive notifications of type 'next' from the Observable,
    with a value

complete():void
  - the callback to receive a valueless notification of type 'complete'

error(err:any):void  
  - the callback to receive notifications of type 'error' from the Observable,
    with an attached Error.



    Subscribe operator
---------------------------------------------------------------------------

the 'subscribe' operator is the glue that connects an observer to an Observable.
in order for an observer to see the items being emitted by an Observable, or 
to receive error or completed notifications from the Observable, it must first
subscribe to that Observable with this operator. E.g.:

  result.subscribe(x => console.log(x));

Here, "result" is an observable to which an observer is subscribing.  



An Observable is called a 'cold' Observable if it doesn't emit items until an
observer has subscribed to it.

'hot' Observable - if it may begin emitting items at any time, and a subscriber 
may begin observing the sequence of emitted items at some point after its 
commencement, missing out on any items emitted previously.

subscribe operator returns a subscription:

  var subscription = source.subscribe(...);

what will 'unsubscribe' method do?

  - it depends on the Observable.


Any time you have a long-running operation that might produce Observables, or
you yourself create Observables that might create certain resources and you 
need to provide the user with the ability to cancel the execution,
that's when you implement the unsubscribe logic in a function that is returnable
from Observable.create()

with the purpose of cleanup resources and stop execution of some Observables.



================================================================================

  Subscription
  ************

represents a disposable resource, such as the execution of an Observable.
a subscription has one important method:

  unsubscribe()

    takes no argument and just disposes the resource held by the subscription.



================================================================================

  Operators
  *********

Operators by Category
----------------------

Creating new Obervables

  create    - create from scratch by calling observer methods
  defer     - do not create an O until subscriber subscribe
              and create a new fresh one for each observer
  emtpy/never/throw
            - create Os that have very precise and limited behavior
  interval  - create an O that emits a sequence spaced by an interval
  just      - covert an object or set of objects into an O that emits that
              those objects
  range     - creates an O that emits a range of sequential integers
  repeat    - create an O that emits a particular item or sequence of items
              repeatedly
  start     - create an O that emits the return value of function
  timer     - create an O that emits a single item after a given delay

Transforming Observables

  buffer
  flatMap
  groupBy
  map
  scan      - apply a function to each item emitted, sequentially 
  window    - periodically subdivide items from an Observable into Observable
              windows and emit these windows rather than emitting the items 
              one at a time

  switchMap - map to observable, complete previous inner observable, emit values
                - this operator can cancel in-flight network requests!

Filtering Observables

Combining Observables

Error Handling Observables

  catch     - recover from an 'onError' notification by continuing the sequence 
              without error

  retry     - if a source O sends an 'onError' notification, resubscribe to it
              in the hopes that it will complete without an error.

Observable Utility Operators

Conditional and Boolean Operators

Mathematical and Aggregate Operators

Backpressure Operators

Connectable Observable Operators

To Convert Observables


A Decision Tree of Observable Operators
---------------------------------------
http://reactivex.io/documentation/operators.html#tree





Observable Operators
=====================================================

map()
-----

  applies a given 'project' function to each value emitted by the source
  Observable

  --  1   2   3  -->

observable.map(x => x * 10)

  --  10  20  30 -->

filter()
--------

  filters values emitted by the source Observable by only emitting those that
  specify the predicate

    observable.filter(x => x % 2 === 1);



FlatMap
--------------------------------------------------------------------------

transform the items emitted by an Observable into Observables, then flatten
the emissions from those into a single Observable.

  flatMap transforms an Observable by applying a function that you provide to
  each item emitted by the source Observable, where the function returns an
  Observable that itself emits items.

  flatMap then merges the emissions of these resulting Observables, emitting these
  merged results as its own sequence.


SwitchMap
--------------------------------------------------------------------------

  1. why the term 'switch', what exaclty is being switched to and from?

    the result observable can be switched from emitting the values 
    of the first inner observable to emitting the values of the newly
    created inner observable

  2. why the term 'map', what is being mapped?

    what is being mapped is the emitted source value, that is getting
    mapped to an observable using the mapping function passed to switchMap.



  RxJS provides several flattening operators like switch, concat, merge that
  allow to merge multiple streams of observables into one stream.

    simple case with map operator

      Rx.Observable.of(1)
        .map(x => x * 2)

    a switchMap use case:

      Rx.Observable.of('some_url')
        .switchMap(url => this.http.get(url))

    rule:

      simple value => use 'map'
      Observable   => use 'switchMap'


  The switchMap operator will create a derived observable (called inner observab le) from a source observable and emit those values.

  When the source emits a new value, it will create a new inner observable and 
  switch to those values instead.

why use switchMap?
https://stackoverflow.com/questions/42655134/angular-2-why-use-switchmap-when-retrieving-route-params

Q: why do they need swtichMap?

ngOnInit() {
  this.route.params
    .switchMap((params: Params) => this.service.getHero(+params['id']))
    .subscribe((hero: Hero) => this.hero = hero);
}

A:

  the difference from flatMap or concatMap is that as soon as the next trigger emits, the current async operation is canceled and retriggered.

  which means, as soon as the route-params change, your hero-service is
  automatically called again with the changed params and the previous call is
  canceled so you won't receive outdated data.

  this is especially helpful for search queries that might take longer 
  than 200-300ms and are triggered while a user is typing 
  see:
  https://stackoverflow.com/documentation/rxjs/8247/common-recipes/26559/discarding-slow-outdated-rest-calls


Retry(number: number)
--------------------------------------------------------------------------

  if a source Observable emits an error,m resubscribe to it in the hopes 
  that it will complete without an error

  if the source Observable calls error(), this methos will resubscribe to the 
  source Observable for a maximum of count resubscriptions rather than 
  propagating the error() call.


retryWhen
--------------------------------------------------------------------------

  returns an Observable that emits the same values as the source observable
  with the exception of an error.

  error() will cause the emission of the Throwable that caused the error 
  returned from notificationHandler.

    retryWhen(
        receives: notificationHandler,
        the: scheduler): Observable

    where
      receives 
        -is an Observable of notifications which a user can 'complete' or
         'error' aborting the retry

      the
        - scheduler on which to subscribe to the source observable

  
      return - the source Observable modified with retry logic

    
scan
--------------------------------------------------------------------------
  applies an accumulator function over the source Observable,
  and returns each intermediate result, with an optional seed value.

  scan(accumulator: function(acc: R, value: T, index: number):R, seed:T|R):Observable<R>

    accumulator

      function(acc, value, index)

    seed - (optional) initial accumulator value


  E.g.: 

    obs.scan( (acc, one) => acc + one,   0);



takeWhile
--------------------------------------------------------------------------

  emits vlaues emitted by the source Observable so long as each value satisfies
  the given 'predicate', and then
  completes as soon as this predicate is not satisfied.

  takeWhile(predicate:function(value: T, index: number):boolean):Observable<T>

  e.g.: emit click events while the clientX prop is greater than 200 

    var clicks = Rx.Observable.fromEvent(document, 'click');
    var result = clicks.takeWhile(ev => ev.clientX > 200);
    result.subscribe( x => console.log(x) );

  

defer
--------------------------------------------------------------------------
  allows you to create the Observable only when the Observer subscribes,
  and create a fresh Observable for each Observer.

  factory method

  static defer(observableFactory: function(): Observable|Promise): Observable

  e.g. 

    function loadWithFetch(url: string) {
      return Observable.defer( () => {
        return Observable.fromPromise(fetch(url).then( r => r.json())
      });
    }



Concat Operators
****************

  If you want to be sure that the order of emissions is the same as the order
  in which you specified the source Observables.

  concat* operators subscribe to an Observable only after the previous 
  Observable completes.


concat
--------------------------------------------------------------------------

  use concat if you just need to order the emissions


      var source1 = Observable.of(1,2,3,4,5);
      var source2 = Observable.of(6,7,8,9,10);

      var source = Observable.concat(source1, source2);

      var subscription = source.subscribe(
          (next) => {
              console.log('Next: %s', next);
          },
      (error) => {
              console.log('Error: %s', error);
          },
          () => {
              console.log('Complete');
          }
      );



concatMap
--------------------------------------------------------------------------

  use concatMap if the request for one depends on the response of the previous
  one.


  Observable.of('Hello', 'Goodbye')
      .concatMap( val => Observable.of(`${val} World!`))
      .subscribe( val =>  console.log('Example One: ', val));


================================================================================

Importing RxJS components
*************************

    import { Observable, Observer } from 'rxjs';

in VSCode, if you place your cursor on 'rxjs' and hit F12, you will get a listing
of everything that is being sent to the browser.

There is a way to be more specific about what you need to import:

    import { Observable } from 'rxjs/Observable';
    import { Observer } from 'rxjs/Observer';
    import 'rxjs/add/operator/map';
    import 'rxjs/add/operator/filter';    


================================================================================

  Error Handling
  **************

In RxJS, if something creates an error which causes the error handler to be invoked,
but there is no error handler defined in the observer, or any operator that might
stop that error, then the error becomes an unhandled exception.


    let source = Observable.create(observer => {
      observer.next(1);
      observer.next(2);
      
      // observer.error("Stop!");      // create an error
      // throw an error
      throw new Error("Stop!");        // or throw an Error

      observer.next(3);
      observer.complete();

    });

    source.subscribe(
      value => console.log(`value: ${value}`),
      error => console.log(`error: ${error}`),
      () => console.log("complete")
      
    );  

If you provide an error handler in the observer, the Observable execution will 
complete without an uncaught exception, but the complete()  handler will never be 
called and of course anything that follows the point where the error occurred.


onErrorResumeNext()

  operator
  instructs an O to begin emitting a second Observable sequence if it encounters
  an error or if the source Observable terminates normally.

catch() operator
-------------------

  will catch the error, and return its own Observable

    let source = Observable.merge(

      Observable.of(1),
      Observable.from([2,3,4]),

      Observable.throw(new Error("Stop!")),

      Observable.of(5)

    ).catch( e => {
      console.log(`caught: ${e}`);
      return Observable.of(10);
    })


    Type 'void' is not assignable to type 'ObservableInput<{}>'

      When using catch(), you have to return an observable:

        Observable.of({})
          .map( (res: Response) => res.json() )
          .catch( (error: any) => {
            // do something
            return Observable.of({});  // or
            return Observable.throw(error.statusTest);
          })



==============================================================================


  Functional Reactive Programming FRP
  ***********************************

Tutorial 1
https://github.com/channikhabra/frp-with-rxjs-jschannel-conf/blob/master/README.org

Task: 
 - render tweets to a web page
 - tweet looks like this
      var tweets = [
        {
          id: 'tweet1',
          username: 'koyote',
          body: 'I will eventually catch you :3'
        }
        ...
      (100 or so)];
Dev spec:
  - only show tweets from the logged-in user
  - only show the tweets with specific hash-tags
  - and replace the text emogies with images.

So, the dev starts coding one problem at a time:

var tweets = getTweets();
tweets
    .filter(t => t.username === me.username)   // filter tweets from this user
    .filter(t => hasTag(selectedHTag, t.text)  // only tweets with selected #tag
    .map(t => {
      t.text = emogize(t.text);
      return t;
    })                     // replace text emogies with <img> tags
                           // map is like filter but it takes a function... 
    .forEach(t => render); // for each item in the processed collection, render...


Code:

    tweets
      .filter(t => t.username === me.username)
      .filter(t => t.text.split(' ').includes(selectedHTag))
      .map(t => {
        t.text = emogize(t.text);
        return t;
      })
      .forEach(t => render);

Source
    +---------------------------+
    |                           |
    |        operations         |
    |                           |
    +---------------------------+
                              Sink

The data source is made to go through an operation, and the result is passed to
a sink for side effects.
The operations will not mutate the source.
Given the same input, it will always produce same output - it's a pure function.
Pure functions can be composed to make complex operations without any hassle.

This functional approach brings a lot of value:

  1. the code is readable
  2. pure functions are easy to test
  3. modular, compose-able code means ease of extension

But this is JavaScript - turns out the source is asynchronous, and it produces
one tweet at a time.

First thing that came to mind - callbacks

  - composability.. how would you compose with callbacks?
  - dangling state can be nasty. imagine 6 levels deep with callbacks.  5th
  uses something set by 2nd callback.  now debug
  - readability is the first thing that gets murdered.

Promises?

Thanks to promises, async values can be passed around like regular data.
but they are hard to compose.
they resolve once at most and then be done with, and canceling a promise is not
something you do in a pool of async requests

with RxJS
----------

var tweets_ = Rx.Observable.fromPromise(getTweets);

tweets_
    .filter(t => t.username === me.username)
    .filter(t => hasTag(selectedTag) )
    .map(t => {
      t.text = emogize(t.text);
      return t;
    })
    .subscribe(x => render(x));



================================================================================

  angular2 Http service methods and Observables
  *********************************************
  
In Angular, each Http service method returns an Observable of HTTP Response objects.

For instance, HeroService converts an Observable into a Promise and returns the
promise to the caller.

  an observable is a stream of events that we can process with array-like operators.  

Angular core has basic support for observables.  We augment that support with
operators and extensions from the RxJS Observables library.

Converting an Observable to a Promise is often a good choice.
We often ask 'http.get' to fetch a single chunk of data.
When we receive the data, we are done.

A single result in the form of a promise is easy for the calling component to
consume and it helps that promises are widely understood by the JS programmers.

  HTTP requests aren't always "one and done"
  ------------------------------------------

We may start one request, then cancel it, and make a different request 
before the server has responded to the first request...

Such a 'request-cancel-new-request' sequence is difficult to implement with 
Promises.

It's easy with Observables.



================================================================================

  RxJS Angular2 pitfalls
  **********************
http://blog.angular-university.io/angular-2-rxjs-common-pitfalls/

pitfall 1 - nothing happens
---------------------------



================================================================================

  Promises
  ********

Instantly resolve or reject promises
-------------------------------------

Using methods

  Promise.resolve(data)
  Promise.reject(error)

let firstPromise = Promise.resolve(10);
let secondPromise = Promise.reject(Error('Ooops!'));

firstPromise
  .then(console.log)
  .catch(console.log)


secondPromise
  .then(console.log)
  .catch(console.log);

Executing all promises
------------------------

Using the syntax Promise.all(iterable), you can execute an array of Promises.
This method resolves when all promises have resolved and fails if any of those
promises fail.

  let firstPromise = Promise.resolve(10);
  let secondPromise = Promise.resolve(5);
  let thirdPromise = Promise.resovle(20);

  Promise
    .all([firstPromise, secondPromise, thirdPromise])
    .then(values => {
      console.log(values);
    });

Promise Race Function
---------------------

You can use the Promise.race(iterable) function when you want the value
of the first promise that resolves or rejects

  let p1 = new Promise((resolve,reject) => {
    setTimeout(resolve, 2000, 'promise 1 resolved');
  });

  let p2 = new Promise((resolve,reject) => {
    setTimeout(reject, 3000, 'promise 2 rejected');
  });

  Promise
    .race([promise1, promise2])
    .then(console.log)
    .catch(console.log);

the .then will be invoked because p1 would resolve before p2.    


Convert Promises to Observables
-------------------------------

RxJS provides Rx.Obserable.fromPromise method which calls the then method 
of the promise to handle both success and error cases.

// create a promise which resolves to 42
let promise1 = new RSVP.Promise(function (resolve, reject) {
  resolve(42);
});

// create a observable
let source1 = Rx.Observable.fromPromise(promise1);

let subscription1 = source1.subscribe(
  x => {
    console.log('onNext: %s', x);
  },
  e => {
    console.log('onError: %s', e)
  },
  () => console.log('onCompleted')
);

// output:
// onNext: 42
// onCompleted

let promise2 = new RSVP.Promise(function (resolve, reject) {
  reject(new Error('reason'));
});

let source2 = Rx.Observable.fromPromise(promise2);

let subscription2 = source2.subscribe(
  x => {
    console.log('onNext: %s', x);
  },
  e => {
    console.log('onError: %s', e)
  },
  () => console.log('onCompleted')
)

// output:
// onError: reject


================================================================================

  forkJoin
  ********
Runs all observable sequences in parallel and collects their last elements.

https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/forkjoin.md


  Handling Observables that depend on each other
  ----------------------------------------------

https://stackoverflow.com/questions/42188732/handling-observables-when-one-is-dependent-on-data-from-another  


const request1$ = Rx.Observable.of('response1').delay(2000);
const request2$ = Rx.Observable.of('response2').delay(100);

Rx.Observable.forkJoin(request1$, request2$)
  .subscribe(res => console.log(`forkJoin: ${res}`));


// Or if your 2nd request depends on 1st response - use switchMap

request1$.switchMap(res1 => {
  console.log(`switchMap: ${res1}`);
  return request2$;
}).subscribe(res2 => console.log(`switchMap: ${res2}`));




    /**
     * 1. get outage notice
     * 2. check if user is authenticated
     *    2.1. enforce FORCED DATA COLLECTION policy
     */
    Observable.forkJoin(

      // 1. get outage notice
      this.getDrupalOutageInfoObservable()
        .map( (outageContent: Outage) => {
          this.outageContent = outageContent;
          console.log('Outage content.notificationType: %s', outageContent.notificationType);
          if (outageContent.notificationType === 'total-outage') {
            this.isTotalOutage = true;
          }
        }),

      // 2. check if authenticated
      this.authenticationService.checkIfAuthenticated()
        .map( () => {
          console.log('User is authenticated');
          this.isAuthenticated = true;

          // 2.1 enforce FORCED_DATA_COLLECTION_AUTHZ_POLICY
          this.authenticationService.validateAuthzPolicy(this.FORCED_DATA_COLLECTION_AUTHZ_POLICY)
            .subscribe(
              () => {
                console.log('Forced Data Collection policy met');
                this.isForcedDataCollectionPolicyMet = true;
              },
              ( (error: IResponse) => {
                console.log('User failed FORCED_DATA_COLLECTION_AUTHZ_POLICY validation. Error.status: %s', error.status);
                this.router.navigate(['/data-collection']);
              })
            );

        })
        .catch( (error: IResponse) => {
          console.log('User not authenticated. Error.status: %s', error.status);
          return Observable.of({});
        }),
    )
      .subscribe(
        () => {

          console.log('forkJoin completed successfully');
          console.log('this.isAuthenticated: %s', this.isAuthenticated);
          console.log('this.isForcedDataCollectionPolicyMet: %s', this.isForcedDataCollectionPolicyMet);
          if (this.isAuthenticated && this.isForcedDataCollectionPolicyMet) {
            console.log('isAuthenticated && ForcedDataCollection OK => redirect to dest');
            this.isRedirect = true;
            this.redirectToDestination();
          }

          this.isInitDataAvailable = true;
        });


  } // complete ngOnInit()



================================================================================

  experimenting with Observables
  ******************************

from one or multiple values
---------------------------

  Observable.of('foo', 'bar');

from array of values
--------------------

  ////////////  Observable from array of values ////////////

  let numbersArray: number[] = [1,2,3];

  let source: Observable<number> = Observable.from(numbersArray);
  source.subscribe(
      n => console.log('Next number: %s', n),
      error => console.log('error: %s', error),
      () => console.log('Completed')
  );

  example

        export class Crisis {
            constructor(
                public id: number,
                public name: string
            ) {}
        }
        const CRISES = [
            new Crisis(1, 'Dragon Burning Cities'),
            new Crisis(2, 'Sky Rains Great White Sharks'),
            new Crisis(3, 'Giant Asteroid Heading for Earth'),
            new Crisis(4, 'Procrastinators Meeting Delayed Again')
        ];


        function getCrisis(id: number|string) {
            return Observable.from(CRISES)
                .find( crisis => crisis.id === id);
        }

        let c: Crisis;
        getCrisis(4).subscribe( s => c = s);
        console.log('c: %s', c.name);



from an event
-------------

  Observable.fromEvent(document.querySelector('button'), 'click');


from a Promise
--------------

  Observable.fromPromise(fetch('/users'));



was able to simulate observable with
------------------------------------

import 'rxjs/add/observable/of';

@Injectable()
export class SomeService{
  
  public blahWithObservables() {
    return Observable.of({
      data: 'blah',
      status: 400
    });
  }
}

consumed
--------




================================================================================