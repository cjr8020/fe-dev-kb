
  @@@@@@@@@@@@@@@@@@@@@@@

      ReactiveX - RxJS

  @@@@@@@@@@@@@@@@@@@@@@@


================================================================================

  Resources:

1. https://github.com/DeborahK/Angular-RxJS/tree/master/APM-Final
2. https://rxjs.dev/api/operators/map


================================================================================

  RxJS Operators
  --------------

`rxjs/operators`

  RxJS Creation Functions
  ------------------------

import { }  from 'rxjs';

if you see an error trying to use `pipe` method with the creation function,
check to see that you're importing the creation function, not the operator.



Hover over the observable to insure it's returning the expected type.

http.get emits ONE item - response - often an array.

  when you get an array as a response of HTTP.GET

    map the emitted array
    map each array element
    transform each array element


    Action Streams
    ---------------

Action streams only emit when they are active.
Unhandled error in an action stream causes the stream to stop.

Catch the error and replace the errored Observable to keep the stream active.

  don't replace an errored action Observable with EMPTY as it will COMPLETE the action stream!

  replace with a default or empty value instead.

  Combination Operators
  ----------------------

don't emit until each source stream emits at least once

  - combineLatest
  - forkJoin
  - withLatestFrom

Action stream created with a Subject does not immediately emit

  when combining with an action stream, consider using a BehaviorSubject,
  since it emits a DEFAULT value upon subscription and ensures that the 
  Action stream emits at LEAST ONCE.


Complete Notification
---------------------

  some functions/operators require the input Observable(s) to complete
  before they emit:

    - forkJoin
    - toArray

  Take care when using these functions/operators with action streams
  which often DON'T complete:

    use innerObservables that do complete.


Hot / Cold
-----------

  http.get  returns a COLD observervable - we must use subscribe or use async pipe
  that subscribes for us...

  Hot observable emits without subscribers

    Subject
    BehaviorSubject



================================================================================


NOTE: 
  one-line arrow function has an implied return.
  multi-line arrow function, we need an explicit return statement.


  error and complete()
    when an error occurs, complete() is not executed.


RxJS is a library for 

  composing async and event-based programs by using observable sequences.

  composing observable streams and optionally processing each item in the stream
  using an extensive set of operators.

it is a way to manage data as it flows though time.


Stream

  a sequence of ongoing events ordered in time

  streams emit a value (data), error and complete signal (maybe)

  E.g. http.get is a stream that 
    - should return a value (data) or an error, and 
    - complete signal

    - lazy by default

      Observables processing is "lazy" by default - nothing will happen
      until someone subscribes to it.


Observer
---------

  const observer = {
    next: apple => console.log(`Apple was emitted ${apple}`),
    error: err => console.log(`Error occurred: ${err}`),
    complete: () => console.log(`No more apples, go home`)
  };


Observable stream
------------------

  const appleStream = new Observable(appleObserver => {
    appleObserver.next('Apple 1');
    appleObserver.next('Apple 2');
    appleObserver.complete();
  });

Start the stream
-----------------

  const subscription = appleStream.subscribe(observer);

as part of the subscription process, 
we tell the Observable how we will observe it.
The subscribe() method returns a `subscription` object which represents
the execution of the observable.

Now that we've subscribed, the code in the constructor is executed:

    appleObserver.next('Apple 1');
    appleObserver.next('Apple 2');
    appleObserver.complete();

Typically, you don't pass the Observer object into the subscribe() method.
Rather, you pass next(), error() and complete()  directly into the subscribe():


  const sub = appleStream.subscribe(
    apple => console.log(`Apple was emitted ${apple}`),
    err => console.log(`Error occurred: ${err}`),
    () => console.log(`No more apples, go home`)
  );


Stop the Observable stream to avoid memory leaks
---------------------------

  observer.complete() will automatically unsubscribe

  some creation functions and operators e.g. of() from() and take() also 
  automatically unsubscribe and  all Observable's complete() method.


  sub.unsubscribe();


Create observables using creation function (preferred)
-------------------------------------------

Some creation functions:

  of()
  from()
  fromEvent()
  interval()


of() static function will emit every argument passed into it;


  const appleStream = of('Apple');            // will emit one apple
  const appleStream = of('Apple1', 'Apple2'); // will emit two apples



from() static function takes an object and emits every element of that array:

  const appleStream = from(['Apple1', 'Apple2']); will emit all elements of the array


    from([20, 15, 10, 5]).subscribe(
      item => console.log(`resulting item .. ${item}`),
      err => console.log(`error occurred ${err}`),
      () => console.log('complete')
    );


these are equivalent:

  const apples = ['Apple1', 'Apple2'];

  from(apples);
  of( ... apples);  // using the spread operator




================================================================================

  Error Handling
  --------------

catchError 

docs:
https://blog.angular-university.io/rxjs-error-handling/


Two common strategies:

  Catch and Replace

    catch the errored observed and replace it with another Observable, 
    for instance, 

      created from hard-coded or local data, or 

      an observable that emits an empty value or empty array, or

      EMPTY RxJS constant - representing empty Observable that immediately completes.


  Catch and Rethrow

    catches the error, does something useful, 
    and rethrows an error Observable



catchError operator

  - use it to catch an error and

    - rethrow an error, or
    - replace the errorred Observable to continue after the error occurs.

  catchError(this.handleError);

    example

      return this.http.get<Product[]>(this.productsUrl)
        .pipe(
          catchError(err => {
            console.error(err)

            return of([
              {id: 1, productName: 'cart'},
              {id: 2, productName: 'hammer'}
            ])
          })
        );


      this.product$ = this.productService.getProducts()
        .pipe(
          catchError(err => {
            this.errorMessage = err;
            return ???;
          })
        );


throwError

  is a creation function

  it creates an Observable that emits no items:


    Observable<never>

  Immediately emits an error notification




EMPTY  RxJS constant

  creates an Observable that emits no items

    and immediately emits a complete notification

    return EMPTY;

    used for returning an empty Observable




================================================================================

  Observable creation functions
  ******************************

from(ObservableInput<T>, Scheduler): Observable<T>
---------------------------------------------------------------------------

  creates an Observable from an Array, an array-like object, Promise, ...
  (optional) Scheduler - on which to schedule the emissions of values.

  e.g.:

  const appleStream = from(['Apple1', 'Apple2']); will emit all elements of the array


    from([20, 15, 10, 5]).subscribe(
      item => console.log(`resulting item .. ${item}`),
      err => console.log(`error occurred ${err}`),
      () => console.log('complete')
    );


fromEvent
---------------------------------------------------------------------------

  creates an Obervable by attaching an event listener to an 'event target'
  which may be an 
  - object with 'addEventListener' and 'removeEventListener'
  - Node.js EventEmitter
  - a jQuery style EventEmitter
  - a NodeList or HTMLCollection from the DOM 

  the event handler is attached when the output  Observable is subscribed, 
  and removed when the Subscription is unsubscribed.

    var clicks = Rx.Observable.fromEvent(document, 'click');
    clicks.subscribe(x => console.log(x));


================================================================================

  Combining streams
  *****************


combineLatest  
    = won't emit until all of the streams emit, 
      and then it will emit whenever any of them emit.

  productsWithCategory$ = combineLatest([
    this.products$,                         --> [product[], category[]]
    this.productCategories$
  ]);


withLatestFrom
    = won't emit until all input streams emit, 
      and emits only when the source stream emits
      so the combined stream waits for all sources of data 

   productsWithCategory$ = this.products$.pipe(
    withLatestFrom(this.productCategories$)          --> [product[], category[]]
   );


forkJoin 
    - only emits when ALL input streams COMPLETE, 
      so the combined stream waits until both sets of data is returned


  productsWithCategory$ = forkJoin([
    this.products$,                         --> [product[], category[]]
    this.productCategories$
  ]);






combineLatest
---------------------------------------------------------

  combination / creation item


  creates an Observable whose values are defined 
    - using the latest values from each input Observable

      note: LATEST and not last...

    combineLatest([a$, b$, c$])

    - does not generate an output Observable until all streams have emitted at
      least one value.

  use it re-evalutate state when an action occurs



withLatestFrom
---------------------------------------------------------

  it is a pipeable operator
  it is a combination creation operator

  takes a set of streams
  subscribes
  creates an output stream

  does not emit until ALL streams have emitted a value and then ONLY
  after the source stream emits

  creates an Observable whose values are defined 

    - using the latest values from each input observable
    - but ONLY when the source stream emits

  here we combine the source stream, a$, with two other streams to create a new
  stream with values from each of the combined streams, 
  BUT it only emits to the output stream when the source stream, a$, emits.


usage: use it to 

  - react to changes in only ONE stream, or
  - to regulate the put of the other streams




Example
-----------------

  product$ = this.http.get<Product[]>(this.url);

  productCategories$ = this.http.get<ProductCategory[]>(this.productCategoriesUrl)
    .pipe(
      tap(data => console.log('categories', JSON.stringify(data))),
      catchError(this.handleError)
    );



  productsWtihCategories$ = combineLatest([
    this.products$,
    this.productsCategoryService.productCategories$
  ]).pipe(
    map( ([products, categories]) =>
      products.map(product => ({
        ...product,
        price: product.price * 1.5,
        category: categories.find(c => product.categoryId === c.id).name,
        searchKey: [product.productName]
      }) as Product)
    )
  );





================================================================================

  map 

    operator

    Applies a given project function to each value emitted by the source Observable, and emits the resulting values as an Observable.




================================================================================

  Data Stream vs Action Stream
  ****************************

when you call HTTP GET, the observable stream emits one item - response - the
stream then completes 

when a stream reacts to an action, the stream emits an item any time the action 
occurs 

combineLatest([data$, action$])
  emits after both stream have emitted, and then again
  every time the action stream emits

  = the resulting array contains data$ and the latest action$ information.


      productsWtihCategories$ = combineLatest([
        this.products$,
        this.productsCategoryService.productCategories$
      ]).pipe(
        map( ([products, categories]) =>
          products.map(product => ({
            ...product,
            price: product.price * 1.5,
            category: categories.find(c => product.categoryId === c.id).name,
            searchKey: [product.productName]
          }) as Product)
        )
      );

  by combining a data steam with an action stream, our code auto reacts to user
  actions and adjusts the display accordingly.



How do we create an Action stream?
-----------------------------------

we could use fromEvent() to react to events

a common technique is to use  Subject/BehaviorSubject


a Subject is both an observable and an observer


  Example
  --------

      A form control emits events containint selected category:


          <select class="form-control"
                  (change)="onSelected($event.target.value)">
            <option value="0">- Display All -</option>
            <option *ngFor="let category of categories$ | async as categories"
                    [value]="category.id">{{ category.name }}</option>
          </select>

      We want use Subject so that it can broadcast category changes to N subscribers.


        private categorySelectedSubject = new Subject<number>();
        categorySelectedAction$ = this.categorySelectedSubject.asObservable();


      in our onSelected() 


        onSelected(categoryId): void {
          this.categorySelectedSubject.next(+categoryId);
        }

      we can call method the Subject as observer, which emits the item, categoryId,
      into the stream.

      This is how the item is emitted into the Action Stream.




================================================================================


  Observable
  **********

Methods:

  lift()
  subscribe()


  Observer
  ********

Methods:

  interface Observer<T> {
    closed?: boolean
    next: (value: T) => void
    error: (err: any) => void
    complete: () => void
  }


  Subject
  *******

Methods:

  lift()
  next()
  error()
  complete()
  unsubscribe()

    _trySubscribe()
    _subscribe()

  asObservable()



================================================================================

  Reacting to Actions
  *******************

1. Create an action stream with Subject or BehaviorSubject.
2. Combine the initial action stream with the Data stream.
3. Emit a value into the Action stream every time an action occurs.

  that re-executes your observable pipeline reacting to user action.


  Subject and BehaviorSubject
  ***************************

Subject is a special type what is both an Observable and an Observer


  Unicast vs Multicast
  --------------------

Observable is Unicast - each subscriber gets its own copy of the stream.

Subject is Multicast - its stream is shared across multiple Subscribers.


  Subject
  *******

Example:
-------------  

private categorySelectedSubject = new Subject<number>();

categorySelectedAction$ = this.categorySelectedSubject.asObservable();

// next() is called to emit the next categoryId to the action stream:

onSelected(categoryId): void {
  this.categorySelectedSubject.next(+categoryId);
}


products$ = combineLatest([

])
.pipe(
  map( ([products, categoryId]) => 
    products.filter(product => 
      categoryId ? product.categoryId ==== categoryId : true) 
  )
);


  BehaviorSubject is a special Subject 
  ---------------

    allows for the initial value to be set in the construtor.



  Starting with Initial Value
  ---------------------------


use startWith(0)


  this.categorySelectedAction$.pipe(startWith(0))


use BehaviorSubject


  private categorySelectedSubject = new BehaviorSubject<number>(0);
  categorySelectedAction$ = this.categorySelectedSubject.asObservable();




================================================================================

  Caching Data
  ************

Classic caching pattern is to define a var to store cached data

  private products: Product[];

  getProducts(): Observable<Product[]> {

    if (this.products) {
      return of(this.products);
    }

    return this.http.get<Product[]>(this.productsUrl)
      .pipe(
        tap(data => this.products = data),
        catchError(this.handleError)
      );
  }

A more declarative approach:

  private productsUrl = 'api/products';

  products$ = this.http.get<Product[]>(this.productsUrl)
    .pipe(
      shareReplay(1),
      catchError(this.handleError)
    );


RxJS operator

  shareReplay 
  -----------

- multicast operator
- returns a Subject that shares a single subscription to the underlying source
- takes in an optional buffer size, which is the number of items cached and replayed
- replays the defined number of emissions on subscription
- on subscribe, it replays a specified number of emitions
- the items stay cached forever, even after there are no more subscribers


  shareReplay(1);  // share the last emission

in this case 

  used to cache data in the application




================================================================================

  Higher Order Observables
  --------------------------

    some Observables emit primitives

    some emit arrays .. or other observables


    of(3,7)
      .pipe(
        map( id => this.http.get<Supplier>(`${this.url}/${id}`) )
      ).subscribe();


      this Observable emits another Observable returned by the HTTP.GET.

      an Observable that emits an Observable is called a Higher Order observable


      Outer observable

      Inner observable 

    but we're not subscribing to the inner observable.


  Nested subscription - not recommended
  --------------------------------------
    

    NOT recommended - should not have nested subscriptions in your code:

      of(3,7)
      .pipe(
        map( id => this.http.get<Supplier>(`${this.url}/${id}`) )
      ).subscribe( o =>
          o.subscribe()
      );

    this is what higher order mapping operators are for ...



  Higher Order Mapping operators
  -------------------------------

    Higher Order mapping operators transform inner observables


    xxxMap() family of operators 
    ----------------------------

      concatMap
      mergeMap
      switchMap


      Map each value 
      - from a source (outer) Observable
      - to a new (inner) Obserbable

      Auto sub/unsub from inner Observables


  with nested subscriptions

      suppliersWithMap$ = of(1, 5, 8)
        .pipe(
          map(id => this.http.get<Supplier>(`${this.suppliersUrl}/${id}`) )
        );


      constructor(private http: HttpClient) {
        this.suppliersWithMap$
          .subscribe(o => o.subscribe(
            item => console.log('map result', item)
          ));
      }

  The above won't work in async pipe, and how to you unsubscribe!


concatMap
--------------------------------------------------------------------------

  higher-order mapping + concatenation

    - transforms each emitted item to a new (inner) Observable
      as defined by a function

      concatMap(i => of(i))

    - processing is SERIAL

      it waits for each inner Observable to complete before processing the 
      next one

    - the results are concatenated to the output stream in SEQUENCE


Example
--------

  of('a1', 'a2')
    .pipe(
      concatMap(id => 
        this.http.get<Apple>(`${this.url}/${id}`)
      )
    ).subscribe(console.log);


  output stream: contains resolved Observables a1 and a2, all completed.

    {a1}, {a2}


  use concatMap to

    - wait for prior Observable to complete before starting the next one

    - if the request for one depends on the response of the previous
      one.




  example:
  --------

  suppliersWithConcatMap$ = of(1, 5, 8)
    .pipe(
      tap(id => console.log('concatMap source Observable', id)),
      concatMap(id => this.http.get<Supplier>( `${this.suppliersUrl}/${id}`))
    );



  example
  -------

    this.authService.isAuthd()
      .concatMap( resp => {
        console.log('used is authd');
        consold.log('resp.status: %s', resp.status);

      })
      .catch( error => {
        console.log('user not authd');
        return Observable.empty();
      })


  note:
  -----

  If any of the observables return Observable.empty() like 
  the catch below, ForkJoin will short-circuit 


  Observable.forkJoin(

      Observable.from([...])
        .concatMap( val => {
          .
          .
          return Observable.of( .. )
            .map( .. )
            .catch( error => {              // <== this catch
              return Observable.empty();    // return empty()!!!! 
            })
        }),

        Observable.of(...)

  )
  .subscribe( () => {

    // WILL NOT BE EXECUTED !!! 

  });

  unless you use 

    .defaultIfEmpty('NO_EFFECT')






mergeMap
--------------------------------------------------------------------------

  higher-order mapping + merging

  transforms each emitted item to a new (inner) Observable as defined by a function

    mergeMap(i => of(i))

  executes each inner Observable in PARALLEL
  merges the result

  results are merged onto output stream in NO PARTICULAR order


use to:

  - process in Parallel
  - when order doesn't matter


Example
-------

  of('a1', 'a2')
    .pipe(
      mergeMap(id =>
        this.http.get<Apple>(`${this.url}/${id}`)
      )
    ).subscribe(console.log);









SwitchMap
--------------------------------------------------------------------------

  higher order mapping + switching

  it is different from concatMap and mergeMap in that it:

    - stops the prior inner Observable and

    - switches to the new inner Observable

Example
-------

  of('a1', 'a2')
    .pipe(
      switchMap(id =>
        this.http.get<Apple>(`${this.url}/${id}`)
      )
    ).subscribe(console.log);


Important: 
  - when a1 is emitted, switchMap subscribes to that Observable 
  - when a2 is emitted, switchMap unsubscribes from a1 before it even returns a result




  1. why the term 'switch', what exaclty is being switched to and from?

    the result observable can be switched from emitting the values 
    of the first inner observable to emitting the values of the newly
    created inner observable

  2. why the term 'map', what is being mapped?

    what is being mapped is the emitted source value, that is getting
    mapped to an observable using the mapping function passed to switchMap.



  RxJS provides several flattening operators like switch, concat, merge that
  allow to merge multiple streams of observables into one stream.

    simple case with map operator

      Rx.Observable.of(1)
        .map(x => x * 2)

    a switchMap use case:

      Rx.Observable.of('some_url')
        .switchMap(url => this.http.get(url))

    rule:

      simple value => use 'map'
      Observable   => use 'switchMap'


  The switchMap operator will create a derived observable (called inner observable) from a source observable and emit those values.

  When the source emits a new value, it will create a new inner observable and 
  switch to those values instead.





why use switchMap?
-------------------


https://stackoverflow.com/questions/42655134/angular-2-why-use-switchmap-when-retrieving-route-params

Q: why do they need swtichMap?

ngOnInit() {
  this.route.params
    .switchMap((params: Params) => this.service.getHero(+params['id']))
    .subscribe((hero: Hero) => this.hero = hero);
}

A:

  the difference from flatMap or concatMap is that as soon as the next trigger emits, the current async operation is canceled and retriggered.

  which means, as soon as the route-params change, your hero-service is
  automatically called again with the changed params and the previous call is
  canceled so you won't receive outdated data.

  this is especially helpful for search queries that might take longer 
  than 200-300ms and are triggered while a user is typing 
  see:
  https://stackoverflow.com/documentation/rxjs/8247/common-recipes/26559/discarding-slow-outdated-rest-calls



switchMap vs (flatMap or mergeMap)
--------------------------------------------------------------------------

switchMap when a new value gets emitted, switchMap immediately cancels that subscription
and subscribes to the new value

mergeMap always waits until the first items is finished before subscribing to the next one.


e.g. switchMap cancels previous HTTP requests that are still in progress, while mergeMap lets all of them finish.


A good use case for switchMap would be an autocomplete input, where we should discard all but the latest results from the userâ€™s input.


================================================================================


  Combining related data streams
  ******************************

Two approaches:

  get all data

  just in time


Get all data
-------------

  combineLatest(product$, suppliers$)

you can use this approach when the data is of a reasonable size and you can cache it


Just in Time
-------------

  you get cart with item in it, and then
  you issue a GET request for the supplier of each item in the cart

  using higher order Observables

use this when data set is large and/or data changes frequently


this.selectedProduct$
  .pipe(
    switchMap(product => 

      from(product.supplierIds)
      .pipe(
        mergeMap(supplierId => 
          this.http.get<Supplier>(...)),
          toArray()
        )
      )
    )
  );

NOTE: we use switchMap (not mergeMap) to retrieve data for the LATEST selected product.
In case user clicks quickly over several products.


NOTE: toArray() only emits when its input stream completes - it cannot produce
and array of emissions until it has all of those emissions.

but the source stream - the selectedProduct$ - does not complete - it continues
to emit each time the user selects a new product!

HOW DO YOU COMPLETE a STREAM within a STREAM that does NOT complete?

  Inner Observable Technique
  --------------------------

  NOTE the inner observable:

    from(product.supplierIds)
      .pipe(
        mergeMap(supplierId => this.http.get<Supplier>(...)),
        toArray()
      )

  this inner observable createe a separate context - the "from" creation function
  creates an Observable stream that emits its array elements and completes,
  so since the `toArray()` is in this context - the toArray() completes.

  use this inner observable tecnique to define a stream that completes,
  or for encapsulating operations that can generate an error
  when you don't want the error to stop the outer observable.








================================================================================

  Combining multiple Async Pipes
  ******************************

if you have multiple streams:


  product$ = this.productService.selectedProduct$
    .pipe(
      catchError(err => {
        this.errorMessageSubject.next(err);
        return EMPTY;
      })
    );

  // pageTitle = 'Product Detail';

  pageTitle$ = this.product$
    .pipe(
      map((p: Product) =>
        p ? `Product Detail for: ${p.productName}` : null)
    );

  productSuppliers$ = this.productService.selectedProductSuppliers$
    .pipe(
      catchError(err => {
        this.errorMessageSubject.next(err);
        return EMPTY;
      })
    );

each resulting in an `async` pipes:


<div class="card"
     *ngIf="product$ | async as product">


  <div class="card-header" *ngIf="pageTitle$ | async as pageTitle">
    {{pageTitle}}
  </div>

    <div class="table-responsive">
      <table class="table mb-0"
             *ngIf="productSuppliers$ | async as productSuppliers">

HOW can we combine all async pipes???


  <div *ngIf="vm$ | async as vm ">

name it "vm$" for View-Model, as it holds all data and actions for our view.


  use combineLatest()
  --------------------

 emits an array of elements - latest from each stream. 


  vm$ = combineLatest([
    this.product$,
    this.productSuppliers$,
    this.pageTitle$
  ])
    .pipe(
      filter(([product]) => Boolean(product)),
      map(([product, productSuppliers, pageTitle]) =>
        ({ product, productSuppliers, pageTitle})
      )
    );

in the filter, we are only destructuring the first array element - product

destucturing syntaxt = square brackets in parens when used on the left side of an arrow function

  ([product]) 

for the map operator, the entire array is destructured;

  ([product, productSuppliers, pageTitle])

then we define an object literal with the property for each array element.

  ({ product, productSuppliers, pageTitle})



================================================================================

Observable.finally()
--------------------

https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/finally.md

  Invokes a specified action after the source observable sequence terminates
  gracefully or exceptionally.   


    /* Terminated by error still fires function */
    var source = Rx.Observable.throw(new Error())
      .finally(function () { console.log('Finally'); });

    var subscription = source.subscribe(
      function (x) {
        console.log('Next: %s', x);
      },
      function (err) {
        console.log('Error: %s', err);
      },
      function () {
        console.log('Completed');
      });

    // => Error: Error
    // => Finally


finally() vs completed()
------------------------

  Finally always happens whenever an observable terminates (includuing errors).
  Completed only happens when it terminates without errors.

    OnCompleted
      called after onNext() is called for the last time.



================================================================================

  Creation Functions
  ******************


merge
-----

  combines multiple streams by merging their emissions

    merge(a$, b$, c$)

  static combination creation function, not a pipeable operator

    -takes in a set of streams
    -subscribes
    -creates an output stream
    -completes when all input streams complete

  as values are emitted in the source streams, they are also emitted in the
  resulting stream producing a combined stream of all values.



reduce
------

Array.reduce function
  that allows you to reduce the value of an array

    e.g 
        var sum = [0, 1, 2, 3].reduce(
          function(acc, val) {
            acc + val
          }, 0);
        )


RxJS reduce

  reduce((total, currVal) => {}, 0)  // start with 0 bc there is no total.


    of(1, 2, 3, 4, 5)
    .pipe(
      tap(item => console.log(`reduce example: ${item}`)),
      reduce((total, currVal) => {
        return total + currVal;
      }, 0),
      tap(item => console.log(`item after reduce ${item}`)) // shows 15
    )
    .subscribe(console.log);  // shows 15


scan
----

  scan is almost like reduce 

    use it when you want in-between totals.

  only difference - it emits the total after EVERY processing step.


    /**
     * RxJS scan example
     */
    of(1, 2, 3, 4, 5)
    .pipe(
      tap(item => console.log(`scan example: ${item}`)),
      scan((total, currVal) => {
        return total + currVal;
      }, 0),
      tap(item => console.log(`item after scan ${item}`))
    )
    .subscribe(console.log);



distinctUntilChanged
--------------------

distinctUntilChanged(compare: function): Observable


  returns an Observable that emits all items emitted by the source Observable
  that are distinct by comparison with the previous item.

    of(1, 1, 2, 2, 3, 3, 3, 4)
    .pipe(
      distinctUntilChanged(),
      tap(item => console.log(`distinctUntilChanged: ${item}`))
    )
    .subscribe();

with a comparison function

  (prev, curr) => prev.name === curr.name

    from([
      { name: 'Brian' },
      { name: 'Brian' },
      { name: 'Joe' },
      { name: 'Joe' },
      { name: 'Sue' },
      { name: 'Brian' }
    ])
    .pipe(
      distinctUntilChanged( (prev, curr) => prev.name === curr.name)
    )
    .subscribe(console.log);



merge + scan to react to an add() action
----------------------------------------

  data stream
  action stream - emits new product

example:
  adding a new product

    - first, merge two streams into a single stream
    - then, aggregate them using scan()

  merge(
    this.product$,                  // data stream all products
    this.newProductAddedAction$     // action stream - emits new product
  )
  .pipe(
    scan( (acc: Product[], value: Product) => 
      [...acc, value]
    )
  );

    for scan() operation, the original product array is the initial value 
    for the accumulator function.
    when a new item emits, it is accumulated into the initial value as
    defined by the accumulator function:

      [...acc, value]

    here, a new array is created using the (...) spread operator to copy 
    the intial array, and 
    then, new 'value' is added to that array.




================================================================================

  Operators
  *********


When processing Observables, items are piped through a set of operators.

e.g.:

  of(2, 4, 6)
      .pipe(
          map(item => item * 2),
          tap(item => console.log(item)),
          take(2)
      ).subscribe(console.log);





Operators by Category
----------------------

Creating new Obervables

  create    - create from scratch by calling observer methods
  defer     - do not create an O until subscriber subscribe
              and create a new fresh one for each observer
  empty/never/throw
            - create Os that have very precise and limited behavior
  interval  - create an Observable that emits a sequence of integers 
              spaced by an interval (ms)
  just      - covert an object or set of objects into an O that emits that
              those objects
  range     - creates an O that emits a range of sequential integers
  repeat    - create an O that emits a particular item or sequence of items
              repeatedly
  start     - create an O that emits the return value of function
  timer     - create an O that emits a single item after a given delay

Transforming Observables

  buffer
  flatMap
  groupBy
  map
  scan      - apply a function to each item emitted, sequentially 
  window    - periodically subdivide items from an Observable into Observable
              windows and emit these windows rather than emitting the items 
              one at a time

  switchMap - map to observable, complete previous inner observable, 
              emit values
            - allows us to have the latest response
            - this operator can cancel in-flight network requests!

Filtering Observables

Combining Observables

Error Handling Observables

  catch     - recover from an 'onError' notification by continuing the sequence 
              without error

  retry     - if a source O sends an 'onError' notification, resubscribe to it
              in the hopes that it will complete without an error.

Observable Utility Operators

Conditional and Boolean Operators

Mathematical and Aggregate Operators

Backpressure Operators

Connectable Observable Operators

To Convert Observables


A Decision Tree of Observable Operators
---------------------------------------
http://reactivex.io/documentation/operators.html#tree







Observable Operators
=====================================================



map operator
------------


  throwing error within map operator
  -----------------------------------           


Just throw the error inside the map() operator. All callbacks in RxJS are wrapped with try-catch blocks so it'll be caught and then sent as an error notification.

This means you don't return anything and just throw the error:

map(res => { 
  if (res.bearerToken) {
    return this.saveJwt(res.bearerToken); 
  } else {
    throw new Error('Valid token not returned');
  }
})




filter operator
---------------


.filter((val) => !isSomething(val) && !isBetterThings(val))





tap()

  use for debugging - taps into a stream without modifying it
  performs actions outside of the flow of data.

take()

  emits the specified number of items
  limits an unlimited stream
  by unsubscribing from the observable stream after the expected number of items is taken.




forEach()
---------

  main intent: clarify situations where you are processing an observable 
  sequence of bounded/finite duration in a more 'synchronous' manner.

    this.http.post(
      `${this.url}/rate`, 
      {id: talk.id, yourRating: rating})
    .forEach(() => {});


  in RxJS 4.0, forEach and subscribe behaved identically.
  in RxJS 5.0 (ES7), the two are NOT the same.

  item$
  .forEach(value => console.log('next', value))
  .then(() => console.log('complete'), e => console.error('error', e));

  forEach is a special kind of operator - internally it will subscribe to the
  Observable and return a Promise.

  https://github.com/ReactiveX/rxjs/blob/master/src/Observable.ts#L227


    subscribe vs forEach
    --------------------

  public subscribe(
    observerOrNext: Observer | Function, 
    error: Function, 
    complete: Function)
  : Subscription

  Observable.subscribe is where you do most of your true Observable handling.
  It returns a subscription token which you can use to cancel your subscription.  This is important - when you do not know the duration of 
  the events/sequence you have subscrbided to, or if you may need to stop
  listening before a known duration.


  public forEach(next: Function, PromiseCtor?: PromiseConstructor): Promise

  Observable.forEach returns a promise
  that will either resolve or reject when the Observable completes or errors.
  It is intended to clarify situations where you are processing an observable 
  sequence of bounded/finite duration in a more 'synchronous' manner, 
  such as collating all the incoming values and presenting once, by handling 
  the Promise.

  You can act on each value, as well as errors and completion events, either way.  

  So the most significant different between RxJS 5 subscribe and forEach is the inability to cancel a promise.






Examples mapping data with map()
-----------------------------------

- Consuming an array of Product
- first, mapping the entire array to `products`
- next, using products.map() to access each individual `product`
- and map each originanl `product` to a new object literal

  products$ = this.http.get<Product[]>(this.productsUrl)
    .pipe(
      map(products => products.map(product => ({
        id: product.id,
        productName: product.productName,
        productCode: product.productCode,
        description: product.description,
        price: product.price * 1.5,
        searchKey: [product.productName]
        }) as Product)
      ),
      tap(data => console.log('Products: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

The above can be simplified with a spread (...) operator:

      map(products => products.map(product => ({
        ...product,
        price: product.price * 1.5,
        searchKey: [product.productName]
        }) as Product)
      ),

  here, the spread copies any properties from the orginal object to the new object
  replacing this:

        id: product.id,
        productName: product.productName,
        productCode: product.productCode,
        description: product.description,
  with this:

        ...product

  then you only need statements for the properties to be modified







Retry(number: number)
--------------------------------------------------------------------------

  if a source Observable emits an error,m resubscribe to it in the hopes 
  that it will complete without an error

  if the source Observable calls error(), this methos will resubscribe to the 
  source Observable for a maximum of count resubscriptions rather than 
  propagating the error() call.


retryWhen
--------------------------------------------------------------------------

  returns an Observable that emits the same values as the source observable
  with the exception of an error.

  error() will cause the emission of the Throwable that caused the error 
  returned from notificationHandler.

    retryWhen(
        receives: notificationHandler,
        the: scheduler): Observable

    where
      receives 
        -is an Observable of notifications which a user can 'complete' or
         'error' aborting the retry

      the
        - scheduler on which to subscribe to the source observable

  
      return - the source Observable modified with retry logic

    
scan
--------------------------------------------------------------------------
  applies an accumulator function over the source Observable,
  and returns each intermediate result, with an optional seed value.

  scan(accumulator: function(acc: R, value: T, index: number):R, seed:T|R):Observable<R>

    accumulator

      function(acc, value, index)

    seed - (optional) initial accumulator value


  E.g.: 

    obs.scan( (acc, one) => acc + one,   0);



takeWhile
--------------------------------------------------------------------------

  emits vlaues emitted by the source Observable so long as each value satisfies
  the given 'predicate', and then
  completes as soon as this predicate is not satisfied.

  takeWhile(predicate:function(value: T, index: number):boolean):Observable<T>

  e.g.: emit click events while the clientX prop is greater than 200 

    var clicks = Rx.Observable.fromEvent(document, 'click');
    var result = clicks.takeWhile(ev => ev.clientX > 200);
    result.subscribe( x => console.log(x) );

  

defer
--------------------------------------------------------------------------
  allows you to create the Observable only when the Observer subscribes,
  and create a fresh Observable for each Observer.

  factory method

  static defer(observableFactory: function(): Observable|Promise): Observable

  e.g. 

    function loadWithFetch(url: string) {
      return Observable.defer( () => {
        return Observable.fromPromise(fetch(url).then( r => r.json())
      });
    }


defaultIfEmpty
---------------------------------------------------------------------------
    emits the values emitted by the source Observable or a specified
    default value if the soure Observable is empty:

      const empty = Rx.Observable.of(); // empty!

      // emit default value when source is empty
      const defaultExample = empty.defaultIfEmpty('Empty!');

      const subscribe = defaultExample
                          .subscribe( val => console.log(val));


      NOTE: protect your forkJoin with defaultIfEmpty:


        Observable.forkJoin(

          Observable.of(1),
          Observable.of(2),

          Observable.of(),  // uh-oh!

          Observable.empty() // uh-oh!

        )
        .defaultIfEmpty('EMPTY_HAS_NO_EFFECT') // no problem with empty!
        .subscribe();



EMPTY constant
--------------------------------------------------------------------------

import { EMPTY } from 'rxjs'
return EMPTY; 



Just one thing to keep in mind, EMPTY completes the observable, so it won't trigger next in your stream, but only completes. So if you have, for instance, tap, they might not get trigger as you wish (see an example below).

Whereas of({}) creates an Observable and emits next with a value of {} and then it completes the Observable.


console.log(`EMPTY constant example`);
EMPTY.pipe(
  tap( () => console.warn('i will not reach here, as i am complete'))
).subscribe();

console.log(`of({}) creates Observable, emits next with value of {} and completes.`);
of({}).pipe(
  tap(() => console.warn('i WILL reach here and complete'))
).subscribe();



empty function
---------------------------------------------------------------------------

returns empty Observable


import {from, Observable, of, EMPTY} from 'rxjs';
import {delay, filter, map, take, tap} from 'rxjs/operators';
import {empty} from 'rxjs/internal/Observer';


There's now an EMPTY constant and an empty function.

  import { Observable, empty, of } from 'rxjs';

  var delay = empty().pipe(delay(1000));     
  var delay2 = EMPTY.pipe(delay(1000));


  Observable.empty() doesn't exist anymore.




take
---------------------------------------------------------------------------

  emit the specified number of values before completing

  Observable.interval(1000)
      .take(5)  // take the first 5 emitted values
      .subscribe( val => {
          console.log(`emitted val: ${val}`);
      });  



interval
---------------------------------------------------------------------------

  Observable.interval(1000)
      .take(5)  // take the first 5 emitted values
      .subscribe( val => {
          console.log(`emitted val: ${val}`);
      });






Concat Operators
****************

  If you want to be sure that the order of emissions is the same as the order
  in which you specified the source Observables.

  concat* operators subscribe to an Observable only after the previous 
  Observable completes.


concat
--------------------------------------------------------------------------

  use concat if you just need to order the emissions


      var source1 = Observable.of(1,2,3,4,5);
      var source2 = Observable.of(6,7,8,9,10);

      var source = Observable.concat(source1, source2);

      var subscription = source.subscribe(
          (next) => {
              console.log('Next: %s', next);
          },
      (error) => {
              console.log('Error: %s', error);
          },
          () => {
              console.log('Complete');
          }
      );


concat example

      import 'rxjs/add/observable/concat';


      // 2. check isAuthenticated and validate policy
      Observable.concat(

        // 2.1  check if authenticated
        this.authenticationService.isAuthd()
          .map( () => {
            console.log('User is authenticated');
          })
          .catch( (error: IResponse) => {
            console.log('User not authenticated');
            return Observable.of({});
          }),

        // 2.2. enforce forced data collection
        this.authenticationService.validate(this.POLICY)
          .map( () => {
            console.log('policy met');
          })
          .catch( (error: IResponse) => {
            console.log('failed validation. Error.status: %s', error.status);
            return Observable.of({});
          })

      )  // end concat









================================================================================

  Error Handling
  **************

In RxJS, if something creates an error which causes the error handler to be invoked,
but there is no error handler defined in the observer, or any operator that might
stop that error, then the error becomes an unhandled exception.


    let source = Observable.create(observer => {
      observer.next(1);
      observer.next(2);
      
      // observer.error("Stop!");      // create an error
      // throw an error
      throw new Error("Stop!");        // or throw an Error

      observer.next(3);
      observer.complete();

    });

    source.subscribe(
      value => console.log(`value: ${value}`),
      error => console.log(`error: ${error}`),
      () => console.log("complete")
      
    );  

If you provide an error handler in the observer, the Observable execution will 
complete without an uncaught exception, but the complete()  handler will never be 
called and of course anything that follows the point where the error occurred.


onErrorResumeNext()

  operator
  instructs an O to begin emitting a second Observable sequence if it encounters
  an error or if the source Observable terminates normally.

catch() operator
-------------------

  will catch the error, and return its own Observable

    let source = Observable.merge(

      Observable.of(1),
      Observable.from([2,3,4]),

      Observable.throw(new Error("Stop!")),

      Observable.of(5)

    ).catch( e => {
      console.log(`caught: ${e}`);
      return Observable.of(10);
    })


    Type 'void' is not assignable to type 'ObservableInput<{}>'

      When using catch(), you have to return an observable:

        Observable.of({})
          .map( (res: Response) => res.json() )
          .catch( (error: any) => {
            // do something
            return Observable.of({});  // or
            return Observable.throw(error.statusTest);
          })





================================================================================


debounceTime(..) operator
-------------------------

This operator is popular in scenarios such as type-ahead where the rate of user input must be controlled!

// RxJS v6+
import { fromEvent } from 'rxjs';
import { debounceTime, map } from 'rxjs/operators';

// elem ref
const searchBox = document.getElementById('search');

// streams
const keyup$ = fromEvent(searchBox, 'keyup');

// wait .5s between keyups to emit current value
keyup$
  .pipe(
    map((i: any) => i.currentTarget.value),
    debounceTime(500)
  )
  .subscribe(console.log);




================================================================================

  angular2 Http service methods and Observables
  *********************************************
  
In Angular, each Http service method returns an Observable of HTTP Response objects.

For instance, HeroService converts an Observable into a Promise and returns the
promise to the caller.

  an observable is a stream of events that we can process with array-like operators.  

Angular core has basic support for observables.  We augment that support with
operators and extensions from the RxJS Observables library.

Converting an Observable to a Promise is often a good choice.
We often ask 'http.get' to fetch a single chunk of data.
When we receive the data, we are done.

A single result in the form of a promise is easy for the calling component to
consume and it helps that promises are widely understood by the JS programmers.

  HTTP requests aren't always "one and done"
  ------------------------------------------

We may start one request, then cancel it, and make a different request 
before the server has responded to the first request...

Such a 'request-cancel-new-request' sequence is difficult to implement with 
Promises.

It's easy with Observables.



================================================================================

  RxJS Angular2 pitfalls
  **********************
http://blog.angular-university.io/angular-2-rxjs-common-pitfalls/

pitfall 1 - nothing happens
---------------------------



================================================================================

  Promises
  ********

Instantly resolve or reject promises
-------------------------------------

Using methods

  Promise.resolve(data)
  Promise.reject(error)

let firstPromise = Promise.resolve(10);
let secondPromise = Promise.reject(Error('Ooops!'));

firstPromise
  .then(console.log)
  .catch(console.log)


secondPromise
  .then(console.log)
  .catch(console.log);

Executing all promises
------------------------

Using the syntax Promise.all(iterable), you can execute an array of Promises.
This method resolves when all promises have resolved and fails if any of those
promises fail.

  let firstPromise = Promise.resolve(10);
  let secondPromise = Promise.resolve(5);
  let thirdPromise = Promise.resovle(20);

  Promise
    .all([firstPromise, secondPromise, thirdPromise])
    .then(values => {
      console.log(values);
    });

Promise Race Function
---------------------

You can use the Promise.race(iterable) function when you want the value
of the first promise that resolves or rejects

  let p1 = new Promise((resolve,reject) => {
    setTimeout(resolve, 2000, 'promise 1 resolved');
  });

  let p2 = new Promise((resolve,reject) => {
    setTimeout(reject, 3000, 'promise 2 rejected');
  });

  Promise
    .race([promise1, promise2])
    .then(console.log)
    .catch(console.log);

the .then will be invoked because p1 would resolve before p2.    


Convert Promises to Observables
-------------------------------

RxJS provides Rx.Obserable.fromPromise method which calls the then method 
of the promise to handle both success and error cases.

// create a promise which resolves to 42
let promise1 = new RSVP.Promise(function (resolve, reject) {
  resolve(42);
});

// create a observable
let source1 = Rx.Observable.fromPromise(promise1);

let subscription1 = source1.subscribe(
  x => {
    console.log('onNext: %s', x);
  },
  e => {
    console.log('onError: %s', e)
  },
  () => console.log('onCompleted')
);

// output:
// onNext: 42
// onCompleted

let promise2 = new RSVP.Promise(function (resolve, reject) {
  reject(new Error('reason'));
});

let source2 = Rx.Observable.fromPromise(promise2);

let subscription2 = source2.subscribe(
  x => {
    console.log('onNext: %s', x);
  },
  e => {
    console.log('onError: %s', e)
  },
  () => console.log('onCompleted')
)

// output:
// onError: reject


================================================================================

  forkJoin
  ********
Runs all observable sequences in parallel and collects their last elements.

Note: LAST and not latest...

is a static creation function, not a pipeable operator.

is a combination creation function.

Only emits when ALL input streams are Complete

so do NOT use it with streams that do not Complete




  NOTE: 
    has intended behavior of collecting results ONLY if ALL provided
    sources emit their values.

    so if any of the sub-obsevables return Observable.empty(), 
    the ForkJoin will return Observable.empty()


  forkJoin will short-circuit if one of the streams completes without
  emitting a value - since conceptually you probably don't want to join 
  values that don't exist.

    this would be the case if you return 
      Observable.of() // empty  
    or
      Observable.empty() // empty
    somewhere inside your forkJoin...

  if you don't want that, you could use defaultIfEmpty('NO_EFFECT'):

  or use

      Observable.of({}) 
      Observable.of(null)




https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/forkjoin.md


  Handling Observables that depend on each other
  ----------------------------------------------

https://stackoverflow.com/questions/42188732/handling-observables-when-one-is-dependent-on-data-from-another  


const request1$ = Rx.Observable.of('response1').delay(2000);
const request2$ = Rx.Observable.of('response2').delay(100);

Rx.Observable.forkJoin(request1$, request2$)
  .subscribe(res => console.log(`forkJoin: ${res}`));


// Or if your 2nd request depends on 1st response - use switchMap

request1$.switchMap(res1 => {
  console.log(`switchMap: ${res1}`);
  return request2$;
}).subscribe(res2 => console.log(`switchMap: ${res2}`));




    Observable.forkJoin(

      // 1. get outage notice
      this.getDrupalOutageInfo()
        .map( (data) => {
          this.outageContent = data[0];
          console.log('Outage content.notificationType: %s', this.outageContent.notificationType);
          if (this.outageContent.notificationType === 'total-outage') {
            this.isTotalOutage = true;
          }
        })
        .catch( (error: any) => {
          console.log('Unable to retrieve outage info');
          return Observable.of({});
        }),

      // 2. check isAuthenticated and validate policy

      this.authenticationService.checkIfAuthenticated()
        .concatMap( (response: IResponse) => {
          console.log('TEST User is authenticated');
          console.log('TEST response.status: %s', response.status);
          this.isAuthenticated = true;

          console.log('in concatMap - response: %s', response);

          return this.authenticationService.validateAuthzPolicy()
            .map( () => {
              console.log('policy validated');
            })
            .catch( (error: IResponse) => {
               console.log('validation failed. Error.status: %s', error.status);
               return Observable.of({});
            })

        })
        .catch( (error: IResponse) => {
          console.log('User not authenticated');
          return Observable.of({})
        }),

    )
      .defaultIfEmpty('NO_EFFECT')
      .subscribe(
        () => {

          console.log(' *** summary ***');
          console.log('this.isAuthenticated: %s', this.isAuthenticated);
          console.log('this.isForcedDataCollectionPolicyMet: %s', this.isForcedDataCollectionPolicyMet);
          console.log('this.isTotalOutage: %s', this.isTotalOutage);

          /**
           *  use cases:
           *  1. total outage - display total outage modal, no login form or redirect to my-home
           *  2. user not athenticated - display login form
           *  3. user is authenticated && policy met -> redirect to my-home
           *  4. user is authenticated && policy not met -> forced data collection
           */
          if (this.isTotalOutage) {
            console.log('==> Total outage <==');
          } else if (this.isAuthenticated && this.isForcedDataCollectionPolicyMet) {
            console.log('isAuthenticated && ForcedDataCollection OK => redirect to dest');
            this.isRedirect = true;
            this.redirectToDestination();
          } else if (this.isAuthenticated && !this.isForcedDataCollectionPolicyMet) {
            this.router.navigate(['/data-collection']);
          }

        });



================================================================================

  experimenting with Observables
  ******************************

from one or multiple values
---------------------------

  Observable.of('foo', 'bar');

from array of values
--------------------

  ////////////  Observable from array of values ////////////

  let numbersArray: number[] = [1,2,3];

  let source: Observable<number> = Observable.from(numbersArray);
  source.subscribe(
      n => console.log('Next number: %s', n),
      error => console.log('error: %s', error),
      () => console.log('Completed')
  );

  example

        export class Crisis {
            constructor(
                public id: number,
                public name: string
            ) {}
        }
        const CRISES = [
            new Crisis(1, 'Dragon Burning Cities'),
            new Crisis(2, 'Sky Rains Great White Sharks'),
            new Crisis(3, 'Giant Asteroid Heading for Earth'),
            new Crisis(4, 'Procrastinators Meeting Delayed Again')
        ];


        function getCrisis(id: number|string) {
            return Observable.from(CRISES)
                .find( crisis => crisis.id === id);
        }

        let c: Crisis;
        getCrisis(4).subscribe( s => c = s);
        console.log('c: %s', c.name);



from an event
-------------

  Observable.fromEvent(document.querySelector('button'), 'click');


from a Promise
--------------

  Observable.fromPromise(fetch('/users'));



was able to simulate observable with
------------------------------------

import 'rxjs/add/observable/of';

@Injectable()
export class SomeService{
  
  public blahWithObservables() {
    return Observable.of({
      data: 'blah',
      status: 400
    });
  }
}


================================================================================

  Observable Pattern
  ******************
(from reactive patterns course)

which problem is Reactive programming trying to solve?

Observer pattern
----------------

Subject
 + registerObserver(o)
 + unregisterObserver(o)
 + notifyObservers()  // fundamental difference 

 Browsers do not expose a public method to notify ALL observers.

Observer
 + notify()


Browser Events
--------------

event callbacks receive a stream of events generated by mouse movement:

  <div id="hover" class="hover-me"></div>

  <button class="button botton-highlight" (click)="unsubscribe()">unsubscribe</button>

  this.divSection.addEventListener('mousemove', onMouseMove);

    public onMouseMove(event: MouseEvent) {
      console.log(event);
    }

    public unsubscribe() {
      console.log('Called unsubscribe()');
      this.hoverSection.removeEventListener('mousemove', this.onMouseMove);
    }


custom application event bus
----------------------------





================================================================================

  TypeError: Observable_1.Observable.throw is not a function
  **********************************************************

Since RxJS 5.5.x, looks like now instead of importing throw, 
use ErrorObservable:

// import { _throw } from 'rxjs/observable/throw';
import { ErrorObservable } from 'rxjs/observable/ErrorObservable';

ErrorObservable.create('error');

or

    if (blah) {
      return Observable
        .fromPromise(blah);
    } else {
      return ErrorObservable.create(new Error('Unlucky'));
    }





================================================================================


  AutoUnsubscribe
  ----------------
  https://levelup.gitconnected.com/auto-unsubscribing-in-angular-components-like-a-pro-742220b01d0c



  UntilDestroy
  ------------
  https://levelup.gitconnected.com/auto-unsubscribing-in-angular-components-like-a-pro-742220b01d0c



================================================================================

  Create Observable Array from static array in typescript
  -------------------------------------------------------

If you want the entire array to be emitted as a single emissions use Observable.of instead:

  const arraySource = Observable.of([1, 2, 3, 4, 5]);

Observable.from iterates the array and emits each item separately while Observable.of takes it as without any further logic.


Alternatively, you could also nest two arrays but that's probably too confusing:

  const arraySource = Observable.from([[1, 2, 3, 4, 5]]);  



================================================================================

  Custom RxJS DEBUG operator to replace tap()
  -------------------------------------------

https://blog.angular-university.io/debug-rxjs/


================================================================================