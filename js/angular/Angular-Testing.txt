
	Angular Testing
	***************

https://angular.io/guide/testing


================================================================================

  Jasmine
  *******

https://jasmine.github.io/api/edge/  


Jamsine built-in matchers
-------------------------


toBe()
toBeNull()
toBeUndefined()
toBeNaN()
toEqual()
toBeFalsy()/toBeTruthy()



Jasmine spies
------------------------

Jasmine provides two ways for spying on method calls:

  spyOn()
  createSpy()

Use spyOn() when the method already exists on the object.

  spyOn() would execute the original method, and then you can use Jasmine
  matchers to assert that something has happened.


sometimes, it may be beneficial to completely repace the original method with
a fake one for testing.  Perhaps, the original method takes too long to execute,
or it depends on other objects that aren't available in the test context.
Jasmine lets us handles this issue by creating a fake method using 

  jasmine.createSpy()

unlike spyOn(), creating a fake method circumvents the original method so that 
it is not called during tests.


================================================================================

  mock REST API backend
  *********************

$ npm install json-server --save

"scripts": {
  . . .
  "json-server": "json-server" --watch db.json"
}

$ npm run json-server

output will show enpoints supported

================================================================================

  testing services with HttpClient
  ********************************





import {inject, TestBed} from '@angular/core/testing';
import {DataService} from './data.service';
import {HttpClientTestingModule, HttpTestingController} from '@angular/common/http/testing';
import {Post} from './post.model';

describe('DataService', () => {

  beforeEach( () => {
    TestBed.configureTestingModule(({
      providers: [DataService],
      imports: [HttpClientTestingModule]
    }));
  });

  /**
   * Ensures that httpMock expectations are met.
   */
  afterEach(inject([HttpTestingController], (httpMock: HttpTestingController) => {
    httpMock.verify();
  }));


  it(
    'should be created',
    inject([DataService], (dataService: DataService) => {
      expect(dataService).toBeTruthy();
    })
  );


  it('should be able to retrieve posts from API via GET',
    inject([HttpTestingController, DataService],
      (httpMock: HttpTestingController, service: DataService) => {

        // prepare dummy data
        const dummyPosts: Post[] = [
          {
            id: 1,
            userId: '1',
            body: 'Http Client',
            title: 'Testing Angular Service'
          },
          {
            id: 2,
            userId: '2',
            body: 'Hello World',
            title: 'Testing Angular Services'
          }];

        // call the service
        service.getPostData().subscribe(posts => {
          expect(posts.length).toBe(2);
          expect(posts).toEqual(dummyPosts);
        });

        // set expectations for the HttpClient mock
        const request = httpMock.expectOne(`${service.ROOT_URL}/posts`);
        expect(request.request.method).toBe('GET');

        // finally, set the fake data to be returned by the mock.
        request.flush(dummyPosts);
      })
  );

});



with fakeAsync 
-------------------------

import {fakeAsync, inject, TestBed, tick} from '@angular/core/testing';
import {HttpClientTestingModule, HttpTestingController} from '@angular/common/http/testing';
import {Post} from './post.model';
import {DataService} from './data.service';

describe('DataService', () => {

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [ HttpClientTestingModule ],
      providers: [ DataService ]
    });
  });

  it(
    'should be created',
    inject([DataService], (dataService: DataService) => {
      expect(dataService).toBeTruthy();
    })
  );

  it(
    'should be able to retrieve posts from API via GET',
    fakeAsync(
      inject(
        [DataService, HttpTestingController],
        (dataService: DataService, httpMock: HttpTestingController) => {

          // set up
          let response = null;
          const url = `${dataService.ROOT_URL}/posts`;
          const dummyPosts: Post[] = [
            {
              id: 1,
              userId: '1',
              body: 'Http Client',
              title: 'Testing Angular Service'
            },
            {
              id: 2,
              userId: '2',
              body: 'Hello World',
              title: 'Testing Angular Services'
            }];

          dataService.getPostData().subscribe(
            (posts: Post[]) => {
              response = posts;
            },
            (error: any) => {}
          );

          const requestMapper = httpMock.expectOne(url);
          requestMapper.flush(dummyPosts);

          tick();

          expect(requestMapper.request.method).toBe('GET');

          expect(response.length).toBe(2);
          expect(response).toEqual(dummyPosts);
        }
      )
    )
  );


});




unit testing 204 response
--------------------------


  request.flush('', { status: 204, statusText: 'No Data' });


================================================================================

  Angular Unit Testing
  ********************

$ ng test --browser ChromeHeadless --watch false [--sourcemaps false]

  using '--sourcemaps false' option may help uncover the real cause behind
  an obscure error message like:

      Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'ng:///DynamicTestModule/SomeComponent.ngfactory.js'.
  with --sourcemaps false:

      TypeError: Cannot read property 'route' of undefined


@see 
    https://github.com/angular/angular.io
    https://github.com/angular/angular.io/tree/master/public/docs/_examples/testing/ts/src



spec file

  tests written in Jasmine are called specs
  the file extension must be .spec.ts - convention expected in karma.conf.js
  which looks for spec file in src/app folder


TestBed

  TestBed is the first and most important of Angular testing utilities - used
  to set up the dependencies for our tests.

  it creates an Angular testing module - an @NgModule class - that you 
  configure with the 'configureTestingModule' method to produce the 
  module environment for the class you want to test.

  in effect, you detach the tested component from its own application 
  module and re-attach it to a dynamically-constructed Angular test module
  tailored specifically for this battery of tests.

  ComponentFixture 

    a handle on the test environment surrounding the created component.
    provides access to the component itself and to the DebugElement which is 
    a handle to the component's DOM element.

    let fixture: ComponentFixture<BannerInlineComponent>;
    let component: BannerInlineComponent;
    let de: DebugElement;
    let el: HTMLElement;
    ...

    beforeEach( () => {
      ...

      fixture = TestBed.createComponent(BannerInlineComponent);
      component = fixture.componentInstance;
      de = fixture.debugElement.query(By.css('h1'));
      el = de.nativeElement;

    })


    fixture returned from TestBed.createComponent is your component under test
    with several additional properties and methods:

      detectChanges()
        force a walk of the data graph and update the view with relevant content

        In the actual application, change detection kicks in automatically when
        Angular creates a component or the user enters a keystroke or an AJAX
        activity completes.
        TestBed.createComponent() does not trigger change detection.
        This behavior (or lack of it) is intentional - it gives the tester
        an opportunity to inspect or change the state of the component 
        before Angular initiates data binding or calls lifecycle hooks.


      componentInstance
        actual component under test - you can call methods on the component

      DebugElement

        angular class that contains all kinds of references and methods 
        that help you introspect the element

      nativeElement
        the DOM element of the template your component owns.



TestBed.compileComponents()

  WebPack developers need not call 'compileComponents' because it inlines
  templates and css as part of the automated build process that precedes
  running the test.

  Q: when am I supposed to call compileComponents()?

    angular docs doesn't explain
     - in what circumstances it is "necessary" to call this function
     - what are the consequences of not doing so

  A: if you're using webpack, the build will compile the templateUrls 
  into inline templates and styleUrls to styles.
  so there is no need to 'compileComponents' because it is jsut like 
  you're using template and styles .. 

  if you're using SystemJS, this doens't happen.  Angular will need to 
  make XHR requests to retrieve the external templates and styles, and 
  then compile.  Here you will need to 'compileComponents'.


  DO NOT configure the TestBed AFTER calling 'compileComponents' - it closes 
  the current TestBed instance to further configuration.  
  Make it the last step before calling TestBed.createComponent() to instantiate
  the component-under-test.


inject

  allows us to get dependencies at the TestBed level

  it('should return ... ', inject([MyService], service => {
    service.foo();
  }));




beforeEach(async(..))

  async is necessary to all the asynchronous TestBed.compileComponents method.
  Internally, async arranges for the body of the 'beforeEach' to run in a 
  special async test zone.

  https://stackoverflow.com/questions/40126729/angular-2-testing-async-function-call-when-to-use

  'async' will allow the next test not to start until the 'async' 
  finishes all it's tasks.

  What 'async' does is wrap the callback in a Zone, where all async tasks
  (e.g. setTimeout) are tracked.  Once all the async tasks are complete,
  then the 'async' completes.

  If you've ever worked with Jasmine outside of Angular, you may have seen
  'done' being passed to the callback:

  it('..', function(done) {
    someAsyncAction().then( () => {
      expect(something).toBe(something);
      done();
    });
  });

  With Angular (in a Jasmine environment), Angular will actually call
  'done' behind the scenes, when we use 'async'.  It will keep track of 
  all the async tasks in the Zone, and when they are all finished, 'done' will be 
  called behind the scenes.

  With TestBed configuration, you would use this generally when you want
  to 'compileComponents'.

  When testing a component that uses templateUrl (if you're not using webpack)
  then Angular needs to make an XHR request to get the template, so the 
  communication is asynchronous.


beforeEach( ... )

  the second 'beforeEach' containing the remaining setup follows the async
  beforeEach.

  Typically, here you create the instance of the component-under-test and
  query the elements to inspect:

    component = fixture.createComponentInstance;
    de = fixture.debugElement.query(By.css('h1'));
    el = de.nativeElement;

  The test runner will wait for the first async 'beforeEach' to finish
  before calling the 2nd one.

    compileComponents returns a promise so you can perform add'l tasks 
    immediately after it finishes.. e.g.:

      compileComponents()
        .then(...)

    but most find this hard to read.

    The two beforeEach calls are widely preferred.



    Change Detection
    ----------------

  detectChanges()

        In the actual application, change detection kicks in automatically when
        Angular creates a component or the user enters a keystroke or an AJAX
        activity completes.
        TestBed.createComponent() does not trigger change detection.
        This behavior (or lack of it) is intentional - it gives the tester
        an opportunity to inspect or change the state of the component 
        before Angular initiates data binding or calls lifecycle hooks.    

You can call changeChanges in 

  beforeEach

    fixture = TestBed.createComponent(Comp);
    fixture.detectChanges();

  in each test 

    it('should do something', () => {
      fixture.detectChanges();
      ...
    });

  automatically

    some testers prefer that the Angular test environment run change detection
    automatically with the ComponentFixtureAutoDetect provider:

      import { ComponentFixtureAutoDetect } from '@angular/core/testing';

    then add it to the providers array of the testing module configuration:

      TestBed.configureTestingModule({
        declarations: [ Banner Component ],
        providers: [
          { provide: ComponentFixtureAutoDetect, useValue: true }
        ]
      })

    IMPORTANT: ComponentFixtureAutoDetect service responds to ASYNC activities
    such as promise resolution, timers, DOM events.
    But a direct, synchronous update of the component is invisible.
    The test call fixture.detectChanges() manually to trigger another cycle
    of change detection.


  *********************************************************************
  * Rather than wonder when the text fixture will or will not perform *
  * change detection, just always call detectChanges() explicitly.    *
  * There is NO harm in calling detectChanges() more often then is    *
  * strictly necessary                                                *    
  *********************************************************************

  NOTE:   
          if I have 'fixture.detectChanges' in the 2nd beforeEach, and then
          in tests, change detection did not work.

          I noticed that in the angular test guide, they do NOT have 
          fixture.detectChanges in beforeEach, but then use it in every 
          test when needed:

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/welcome.component.spec.ts

          2. the default tests created by angular-cli put 
          fixture.detectChanges into the 2nd beforeEach(..)
          however, the generated test specs do not have any in the tests ..




================================================================================

	testing ngOnInit
	****************

     describe("ngOnInit()", () => {
         beforeEach(() => component.ngOnInit());
 
         it("should call getCounter() to get initial value", () => {
             expect(store.getCounter.calls.count()).toEqual(2);
         });
 
     });	

================================================================================

  How to change mock service values 
  *********************************

https://stackoverflow.com/questions/41567825/write-angular2-tests-and-changing-the-mock-return-values-make-it-dry


Also see below:

  Spying on a Mock service
  --------------------------

1. Inject a mock service in the outer 'describe' by overridingProvider.
2. Then, in every "inner" describe define a mock response and implement a spy

describe('SomeComponent', () => {

  beforeEach(async(() => {
    mockAuthenticationService = new MockAuthenticationService();
    TestBed.overrideProvider(AuthenticationService, {useValue: mockAuthenticationService});

    TestBed.configureTestingModule({
      declarations: [

      ],
      imports: [

      ],
      providers: [
        {provide: Router, useClass: RouterStub},
        {provide: AuthenticationService}
      ]
    })
      .compileComponents();
  }));

  describe('Scenario 1', () => {
    ...
  })


  describe('Scenario 4', () => {

    const mockResponse = {...};

    beforeEach(() => {
      createComponent();
    });    

    it('should do something special', async(() => {
    createComponent();
    spyOn(mockAuthenticationService, 'getAuthenticated')
      .and
      .returnValue(Observable.of(mockResponse));
    component.ngOnInit();
    fixture.detectChanges();

    // wait for it ..
    fixture.whenStable().then(() => {
      fixture.detectChanges();
      expect(mockAuthenticationService.getMaskedUserIdentifiers).toHaveBeenCalledTimes(1);
      expect(component.viewModel.something.length).toBe(4);
    });
  }));

  })

  function createComponent() {
  fixture = TestBed.createComponent(MfaUntrustedDeviceComponent);
  component = fixture.componentInstance;
  ce = fixture.debugElement.nativeElement;
  fixture.detectChanges();
}




================================================================================

  Stubbing Component's Dependency just to satisfy the dependency
  ********************************

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/app.component.spec.ts  

If you're testing a component, and it has a dependency on another 
component (which in turn has dependencies on other services, for instance).. 
and you're not asserting anything on this dependency component.. 

you might as well just stub it out:

  // stub WelcomeComponent
  @Component({selector: 'app-welcome', template: ''})
  class WelcomeStubComponent {}


  describe('AppComponent', () => {
    beforeEach(async(() => {
      TestBed.configureTestingModule({
        declarations: [
          AppComponent,
          BannerInlineComponent, 
          WelcomeStubComponent    // declare the stubbed out component
        ],
      }).compileComponents();
    }));

    .
    .
    .

  });



================================================================================

  Testing Component with a Dependency
  ***********************************

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/welcome.component.spec.ts


$ mkdir src/app/model
$ ng g s model/user --flat true --spec false
installing service
  create src/app/model/user.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

$ ng g c welcome

The 'WelcomeComponent' displays a welcome mesage to the logged in user.
It knows the user based on the property of the injected 'UserService'.

in welcome.component.spec.ts

  do not provide the real service - use a test double instead:

    let userServiceStub: {
      isLoggedIn: boolean;
      user: {name: string};
    };

    beforeEach(async( () => {
      userServiceStub = {
        isLoggedIn: true,
        user: { name: 'Test User'}
      };
  
      TestBed.configureTestingModule({
        declarations: [ WelcomeComponent ],
        providers: [
          { provide: UserService, useValue: userServiceStub}
        ]
      }).compileComponents();

    }));


The tests need access to the (stubbed) UserService injected into the 
WelcomeComponent.

  Angular has a hierarchical injection system.  There can be injectors at 
  multiple levels, from the root injector created by the TestBed down through
  the component tree.

The safest way to get the injected service (always works!) is to get it from
the injector of the component-under-test.

  Component Injector
  ------------------

The component injector is a property of the fixture's DebugElement:

  // UserService injected into the component
  userService = fixture.debugElement.injector.get(UserService);

    TestBed.get(..)

      you may be able to get the service from the root injector via 
      TestBed.get - it is easier to remember and less verbose.
      But it only works when Angular injects the component with the service
      instance in the test's root injector.
      In this test suite, the ONLY provider of UserService is the root testing
      module, so it would be safe to call TestBed.get like so:

        userService = TestBed.get(UserService);

  NEVER reference the 'userServiceStub' object that's provided to the testing
  module in the body of your test - THIS WOULDN'T WORK - the userService 
  instance injected into the component is a DIFFERENT objeect - a clone of the
  provided userServiceStub.


================================================================================

  managing shared test resources
  ------------------------------

Over time, you will probably have test stubs for common dependencies like

  Router
  ActivatedRoute
  some services

You can manage the in a testing module outside of 'app' 

  src/
    app/
    testing/
      - router-stubs.ts
      model/
        - fake-hero.service.ts


================================================================================

  Stub out service
  ****************

import ...

var mockStory = {
  id: 1,
  title: 'Blah',
  ...
}

class MockStoryService {
  public getStory(id): Observable<StoryModel> {
    return Observable.of(mockStory);
  }
}

describe('Story', () => {
  var storyFixture,
      story,
      storyE1;

  beforeEach(
  );
}


Here is an example of FakeHeroService:

src/testing/model/fake-hero.service.ts
---------------------------------------

  // re-export for tester convenience

  export {Hero} from 'app/model/hero';

  // import
  import {Hero} from 'app/model/hero';
  import {HeroService} from '../../app/model/hero.service';


  export const HEROES: Hero[] = [
    new Hero(41, 'Bob'),
    new Hero(42, 'Carol'),
    new Hero(43, 'Ted'),
    new Hero(44, 'Alice'),
    new Hero(45, 'Speedy'),
    new Hero(46, 'Stealthy'),
    new Hero(47, 'Tes'),
    new Hero(48, 'Grumpy')
  ];

  export class FakeHeroService implements HeroService {

    heroes = HEROES.map(h => h.clone());
    lastPromise: Promise<any>;  // remember so we can spy on promise calls

    getHero(id: number | string): Promise<Hero> {
      if (typeof id === 'string') {
        id = parseInt(id as string, 10);
      }
      const hero = this.heroes.find(h => h.id === id);
      return this.lastPromise = Promise.resolve(hero);
    }

    getHeroes() {
      return this.lastPromise = Promise.resolve<Hero[]>(this.heroes);
    }

    updateHero(hero: Hero): Promise<Hero> {
      return this.lastPromise = this.getHero(hero.id).then(h => {
        return h ?
          Object.assign(h, hero) :
          Promise.reject(`Hero ${hero.id} not found`) as any as Promise<Hero>;
      });
    }
  }


mock a method
-------------

  public doSomething(blah: string, bluh: string): Observable<Response> {

    /** simulates success or error */

    return Observable.fromPromise(new Promise((resolve, reject) => {
      resolve({
        status: 204
      })
      // reject({
      //   status: 400
      // })
    }));

  }





================================================================================

  Test componet with an async service
  ***********************************

Many services return values async'ly. Most data services make an HTTP request
to a remote server and the response is necessarily asynchronous.

In general, tests should not make calls to remote servers.  They should emulate
such calls.  The setup in src/apps/shared/twain.component.spec.ts shows one way.

  The twain.component.ts handles the display of Twain quotes returned by the
  TwainService.  Both are in src/app/shared.

  $ ng g c shared/twain --flat -it -is
  installing component
    create src/app/shared/twain.component.spec.ts
    create src/app/shared/twain.component.ts
    update src/app/app.module.ts

  $ ng g s shared/twain --module=app.module
  installing service
    create src/app/shared/twain.service.spec.ts
    create src/app/shared/twain.service.ts
    update src/app/app.module.ts

note: this automatically provides the service in app.module.ts

Tests still pass at this point.. 

================================================================================

  Spying on the real service
  --------------------------

This setup is similar to the welcome.component.spec.setup
but instead of stubbing the servide, it injects the REAL service 
and replaces the critical 'getQuote' method with a Jasmine spy.


  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ TwainComponent ],
      providers: [ TwainService ]  // provide TwainService
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(TwainComponent);
    component = fixture.componentInstance;

    twainService = fixture.debugElement.injector.get(TwainService);
    spy = spyOn(twainService, 'getQuote')
      .and.returnValue(Promise.resolve(testQuote));  // spy on it

    de = fixture.debugElement.query(By.css('.twain'));
    el = de.nativeElement;

  });

The spy is designed in such a way that any call to 'getQuote' receives an 
immediately resolved promise with a test quote.
They spy bypasses the actual 'getQuote' method and therefore does not contact
the server.

  Faking a service instance and spying on a real object are BOTH great
  options.  Pick one that seems easiest for the current test suite.

    Spying on the real service isn't always easy, especially when the real 
    servide has injected dependencies.

    You can even STUB and SPY at the same time!

Tests need to become asynchronous in order to pick up the quote returned 
from the service which gets initialized in ngOnInit()

service.getQuote is called in the component's ngOnInit() method, 
and ngOnInit() is called during the first change detection cycle.
but the tests need to wait at least one more full turn of the JS engine
before the value becomes available.

================================================================================

  Spying on a Mock service
  --------------------------

You can inject a mock service into your component

    let component: SomeComponent;
    let fixture: ComponentFixture<SomeComponent>;
    let ce: HTMLElement;
    let titleService: Title;
    let mockAuthenticationService: MockAuthenticationService;


    describe('SomeComponent', () => {

      beforeEach(async(() => {

        // override provider 

        mockAuthenticationService = new MockAuthenticationService();
        TestBed.overrideProvider(AuthenticationService, {useValue: mockAuthenticationService});

        // configure testing module using actual component config

        TestBed.configureTestingModule({
          declarations: [
            SomeComponent,
          ],
          imports: [
            RouterModule,
            FormsModule,
            NgIdleModule.forRoot(),
            ModalModule.forRoot(),
            AccordionModule.forRoot()
          ],
          providers: [
            {provide: Router, useClass: RouterStub},
            {provide: AuthenticationService}
          ]
        })
          .compileComponents();
      }));

If you need to force your component template to reload --> see below


.. then in tests, you can either spy on it in beforeEach .. 


      beforeEach(() => {

        // create component
        createComponent();

        // create mock
        spyOn(mockAuthenticationService, 'getMaskedUserIdentifiers')
          .and
          .returnValue(Observable.of(mockMaskedIdentifiers_emailPreferred_noOtherVerifiedDefaults));

        // make component do something
        component.getUserOtpDeliveryChannelOptions();

        // expect spy to have been called
        expect(mockAuthenticationService.getMaskedUserIdentifiers).toHaveBeenCalledTimes(1);
      });



.. or in actual tests

      it('should have span id="default-otp-channel" display correct mfaOtpDestination', () => {
        // create a spy
        spyOn(mockAuthenticationService, 'getMaskedUserIdentifiers')
          .and
          .returnValue(Observable.of(mockMaskedIdentifiers_emailPreferred_noOtherVerifiedDefaults));

        // make component do something
        component.getUserOtpDeliveryChannelOptions();

        // expect spy to have been called
        expect(mockAuthenticationService.getMaskedUserIdentifiers).toHaveBeenCalledTimes(1);

        // test view .. 

      });

Be aware that you cannnot spy on the same object.method within the same
scope:

  describe

    beforeEach
      spy either here, or in "it"s, but not both.

    it
      spy here 

    it 
      spy here


  If you need your component template to reload (refresh view)
  ------------------------------------------------------------

use 

  async()
  fixture.whenStable().then()

    it('should display alt options accordion with 4 channels', async(() => {
      createComponent();
      spyOn(mockAuthenticationService, 'getMaskedUserIdentifiers')
        .and
        .returnValue(Observable.of(mockMaskedIdentifiers_mobileTextPrefered_plus_email_and_phone_verified_defaults));
      component.ngOnInit();
      fixture.detectChanges();

      // wait for it ..
      fixture.whenStable().then(() => {
        fixture.detectChanges();
        expect(mockAuthenticationService.getMaskedUserIdentifiers).toHaveBeenCalledTimes(1);
        expect(component.viewModel.altChannels.length).toBe(4);
        const accordions = ce.querySelectorAll('accordion');
        expect(accordions.length).toBe(1);
      });
    }));



================================================================================

async() 

  the async function is one of the Angular testing activities.
  it simplifies coding of asynch tests by arranging for the tester's
  code to run in a special 'async test zone'.

  async hides most of the asynchronous boilerplate, but some functions
  called within a test (such as fixture.whenStable) continue to reveal
  their async behavior

whenStable

  the test must wait for the getQuote() promise to resolve in the next 
  turn of the JS engine.

  getQuote() is called within the TwainComponent.ngOnInit() method and
  therefore inaccessible to a test that probes only the component API.

  fortunately, the getQuote promise is accessible to the 'async test zone', 
  which intercepts all promises issued with the async method call 
  NO MATTER WHERE THEY OCCUR

  The ComponentFixture.whenStable returns its own promise which resolves
  when the getQuote promise finishes.  In fact, the 'whenStable' promise
  resolves when all pending async activities within this test complete -
  the definition of "stable".

    it('should show quote after getQuote promise (async)', async(() => {
      fixture.detectChanges();

      fixture.whenStable().then(() => { // wait for async getQuote
        fixture.detectChanges();        // update view with quote
        expect(el.textContent).toBe(testQuote);
      });
    }));

  then, the test resumes and kicks off another round of change detection
  which tells Angular to update the DOM with the quote.


fakeAsync

  it('should do something.. ', fakeAsync( () => {
    fixture.detectChanges();
    tick();                   // wait for async getQuote
    fixture.detectChanges();  // update view with quote
    expect(el.textContent).toBe(testQuote);
  }));

  fakeAsync is used instead of async.
  It enables a linear coding style by running the test body in a special fakeAsync test zone.

  main advantage of fakeAsync over async is that the test appears to be synchronous.  
  There is no then(...) to disrupt the visible flow of control.
  the promise-returning 'fixture.whenStable' is gone replaced by tick()

    The limitation - you cannot make XHR calls from within a fakeAsync


tick()

  is a companion to fakeAsync and you can only call it within faceAsync body.

  simulates the passage of time until all pending async activities flush
  it returns nothing
  there's no promise to wait for - proceed with the same test code that 
  appeared in the whenStable.then() callback.


jasmine.done

  while the 'async' and 'fakeAsync' simplify Angular async testing, you can
  still use the traditional Jasmine async testing technique:

    it('should show quote after getQuote promise is done', (done: any) => {
      fixture.detectChanges();

      // get the spy promise and wait for it to resolve
      spy.calls.mostRecent().returnValue.then( () => {
        ...
        fixture.detectChanges();
        expect(..);
        done();
      });
    });

  Although there is no direct access to the getQuote promise inside
  TwainComponent, the spy has direct access which makes it possible to 
  wait for 'getQuote' to finish.    


  Async setTimeout gets interfered with by another component
  -----------------------------------------------------------

If you have another component that uses setTimeout, your async() tests
will fail with   

  Error: Timeout - Async callback was not invoked within timeout 
  specified by jasmine.DEFAULT_TIMEOUT_INTERVAL

You will need to replace this child component with a Dummy if it is 
not key to testing this component


/**
 * Reason for the dummy idle timeout component is:
 * idle-timeout component has its own setTimeout which interferes with the Async callback timeout
 */
@Component({
  selector: 'lgn-idle-timeout',
  template: '<p>Dummy Timeout Component</p>'
}) class DummyIdleTimeoutComponent {}



  beforeEach(async(() => {

    TestBed.configureTestingModule({
      declarations: [
        DummyIdleTimeoutComponent,  // <====
      ],
      imports: [
()
      ],
      providers: [

      ]
    })
      .compileComponents();
  }));




  Test a component with routing
  -----------------------------

Particularly, when your component has ActivatedRoute.

Use a mock component and a mock router, the implement RouterTestingModule.withRoutes
In your tests, validate that expected routes 


in your some-component.component.spec.ts:

  @Component({
    template: `
      <router-outlet></router-outlet>
    `
  })
  class MockRoutingComponent {}

  /**
   * this mock component is a mock routing destination
   */
  @Component({
    template: ``
  })
  class MockComponent {}

  describe('... ', () => {
    
    beforeEach(async(() => {
      TestBed.configureTestingModule({
        declarations: [
          MockRoutingComponent,
          MockComponent
        ],
        imports: [
          FormsModule,
          RouterTestingModule.withRoutes([
            { path: '', component: MockComponent },
            { path: 'password-changed', component: MockComponent }
          ])
        ],
        providers: [
          AuthenticationService
        ]
      })
      .compileComponents();
    }));

  })

Validating examples:



  it('navigate to "" redirects you to /home', fakeAsync( () => {
    router.navigate(['']);
    tick();
    expect(location.path()).toBe('/home');
  }));


  if('navigate to "search" takes you to /search', fakeAsync(() => {
    router.navigate(['search']);
    tick().
    expect(location.path()).toBe('/search');
  }));


Another approach is to use a routerStub as a provider as shown here:
https://stackoverflow.com/questions/39623722/angular-2-final-release-router-unit-test



  Test a component with inputs and outputs 
  ----------------------------------------


such component typically appears inside the view template of the host component. the host uses a property binding to set the input property and an event binding to listen to events raised by the output property.

the testing goal is to verify that such bindings work as expected.
the tests should set input values and listen for output events.

the 'DashboardHeroComponent' is a tiny component that displays an individual
hero provided by the 'DashboardComponent'.

    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts

    NOTE:  ONCE YOU ADD routing YOUR app.component.spec.ts will fail -
           as it doesn't know what <router-outlet> is

          NO_ERRORS_SCHEMA

            adding NO_ERRORS_SCHEMA to the testing module's 'schema' metadata
            will tell the compiler to ignore unrecognized elements and attributes.

              beforeEach( async( () => {

                TestBed.configureTestingModule({
                  declarations: [
                    AppComponent,
                    RouterLinkStubDirective
                  ],
                  schemas: [ NO_ERRORS_SCHEMA ]
                })
                .compileComponents()
                .then( () => {
                  fixture = TestBed.createComponent(AppComponent);
                  comp = fixture.componentInstance;
                });
              });


            these tests are SHALLOW b/c they only "go deep" into the components
            you want to test

  create dashboard-hero component:

    $ ng g c dashboard/dashboard-hero --flat -is -it -m dashboard/dashboard.module.ts


  note: when you have properties declared with @Input(),
  you need to initialize those in your test:


  create 'hero' module

    $ ng g m hero --module=app --routing
    installing module
      create src/app/hero/hero-routing.module.ts
      create src/app/hero/hero.module.ts
      update src/app/app.module.ts


  create 'hero-list' component within 'hero' module

    $ ng g c hero/hero-list --module hero
    installing component
      create src/app/hero/hero-list/hero-list.component.css
      create src/app/hero/hero-list/hero-list.component.html
      create src/app/hero/hero-list/hero-list.component.spec.ts
      create src/app/hero/hero-list/hero-list.component.ts
      update src/app/hero/hero.module.ts


  create 'hero-detail' component within 'hero' module

    $ ng g c hero/hero-detail --module hero
    installing component
      create src/app/hero/hero-detail/hero-detail.component.css
      create src/app/hero/hero-detail/hero-detail.component.html
      create src/app/hero/hero-detail/hero-detail.component.spec.ts
      create src/app/hero/hero-detail/hero-detail.component.ts
      update src/app/hero/hero.module.ts


    note: hero-detail view has two-way binding:

      <input id="name" [(ngModel)]="hero.name" placeholder="name" />

      Error: Can't bind to 'ngModel' since it isn't a known property of 'input'

    in order to use two-way binding for form inputs, you need to import 
    the 'FormsModule' in your Angular module.

      also, if you are working in its module, like 'hero.module.ts', you 
      need to import 'FormsModule' in that module regardless of whether 
      it is already imported in app.module.ts:

          @NgModule({
            imports: [
              CommonModule,
              HeroRoutingModule,
              FormsModule
            ],
            declarations: [
              HeroListComponent,
              HeroDetailComponent
            ]
          })  
          export class HeroModule {}    





================================================================================

  Testing Component with ActivatedRoute
  *************************************

When component accesses route: ActivatedRoute to extract path params or queryParams,
you will need to provide both Router and ActivatedRoute in your tests.

Since you probably will use those facilities in many tests specs, it is best to
create a 'testing' module at the same level as 'app':

src/
  app/
  testing/
    router-stubs.ts

with router-stubs.ts containing the RouterStub and ActivatedRouteStub:

router-stubs.ts
---------------

// export for convenience.
export { ActivatedRoute, Router, RouterLink, RouterOutlet} from '@angular/router';

import {Injectable} from '@angular/core';


/**
 * stub out the router
 */
@Injectable()
export class RouterStub {
  navigateByUrl(url: string) {
    return url;
  }
}

// Only implements params and part of snapshot.paramMap
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { convertToParamMap, ParamMap } from '@angular/router';

@Injectable()
export class ActivatedRouteStub {

  // ActivatedRoute.paramMap is Observable
  private subject = new BehaviorSubject(convertToParamMap(this.testParamMap));
  paramMap = this.subject.asObservable();

  // Test parameters
  private _testParamMap: ParamMap;
  get testParamMap() { return this._testParamMap; }
  set testParamMap(params: {}) {
    this._testParamMap = convertToParamMap(params);
    this.subject.next(this._testParamMap);
  }

  // ActivatedRoute.snapshot.paramMap
  get snapshot() {
    return { paramMap: this.testParamMap };
  }
}


Then use those in your test specs:

See source: app/hero/hero-detail.component.spec.ts

https://angular.io/generated/live-examples/testing/app-specs.eplnkr.html


hero-detail.component.spec.ts
-----------------------------


import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { HeroDetailComponent } from './hero-detail.component';
import {FormsModule} from '@angular/forms';
import {ActivatedRoute, Router} from '@angular/router';
import {HeroService} from '../../model/hero.service';

import {
  ActivatedRouteStub,
  RouterStub
} from '../../../testing/router-stubs';


/////////// Testing Variables ////////////

let activatedRoute: ActivatedRouteStub;


describe('HeroDetailComponent', () => {
  let component: HeroDetailComponent;
  let fixture: ComponentFixture<HeroDetailComponent>;

  beforeEach(async(() => {

    activatedRoute = new ActivatedRouteStub();

    TestBed.configureTestingModule({
      declarations: [ HeroDetailComponent ],
      imports: [ FormsModule ],
      providers: [
        { provide: HeroService, useClass: HeroService },
        { provide: Router, useClass: RouterStub },
        { provide: ActivatedRoute, useValue: activatedRoute }
      ]

    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(HeroDetailComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  describe('when hero id is 12', () => {

    beforeEach( () => {
      activatedRoute.testParamMap = { id: 12 }
    });

    it('should be created', () => {
      expect(component).toBeTruthy();
    });


  })


});


  Error: Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'
  ---------------------------------------------------------------------------

    Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest': 
    Failed to load 'ng:///DynamicTestModule/HeroDetailComponent_Host.ngfactory.js

    Most likely, the @Input() property in your Component is not initialized.

    Tests will crash if inputs are not set with this unintuitive error.


================================================================================

  default test template created by angular-cli
  ********************************************

  angular-cli creates a new describe Suite for the new component
  it just created.

  It comes with (2) beforeEach:

    beforeEach(async) - compileComponents
    beforeEach()      - creates fixture/component/etc instances
                        and runs detectChanges on the fixture.


  describe('GreeterComponent', () => {
    let component: GreeterComponent;
    let fixture: ComponentFixture<GreeterComponent>;

    beforeEach(async(() => {
      console.log('beforeEach(async)');
      TestBed.configureTestingModule({
        declarations: [ GreeterComponent ]
      })
      .compileComponents();
    }));

    beforeEach(() => {
      console.log('beforeEach()');
      fixture = TestBed.createComponent(GreeterComponent);
      component = fixture.componentInstance;
      fixture.detectChanges();  // I'VE SEEN THIS CREATE PROBLEM IF TEST ALSO do this!!!
    });

    it('should create', () => {
      expect(component).toBeTruthy();
    });
  });



================================================================================

  Example: test LanguageService component
  ----------------------------------------

1. load the dependencies requireq for the test with TestBed.configureTestingModule
2. use 'inject' to automatically instantiate each dependency

  describe('Service: LanguageService', () => {

    beforeEach( () => TestBed.configureTestingModule({
      providers: [ LanguageService ]
    }));

    it('should return available languages', inject([LanguageService], service => {
      expect(service.get()).toContain('en');
    }));

  })

3. refactor the 'inject' so it is not repeated for each spec:


  describe('Service: LanguageService', () => {

    let service;

    beforeEach( () => TestBed.configureTestingModule({
      providers: [ LanguageService ]
    }));

    beforeEach(inject([LanguageService], s => {
      service = s;
    }));

    it('should return available languages', () => {
      expect(service.get()).toContain('en');
    });
 
  })


  Example: instantiating a Component
  ----------------------------------

    // Synchronous:

    beforeEach( () => {
      fixture = TestBed.createComponent(MyComponentUnderTest);
    });

    // Async

    beforeEach( async( () => {
      TestBed.configureTestingModule({
        declarations: [ MyComponentUnderTest ],
      }).compileComponents();  // compile external templates and css
    }));

  we can use async() when dependencies involve async handling. 
  this will internally create a zone and deal with async processing.
  

  Example: testing a component
  ----------------------------

  // Component
  // usage: <greeter name="Joe"></greeter>
  // renders: <h1>Hello Joe!</h1>

  @Component({
    selector: 'greeter',
    template: `<h1>Hello {{name}}!</h1>`
  })

  export class Greeter {
    @Input() name;
  }


================================================================================

  Access elements
  ***************

let de: DebugElement;
let el: HTMLElement;

de = fixture.debugElement.query(By.css('#some-id'));
el = de.nativeElement;

expect(nativeElement.querySelector('#some-id') === null).toBe(false);

// trigger the button
nativeElement.querySelector('#some-id').click();


================================================================================

	Type 'void' is not assignable to type 'ObservableInput<{}>'
	***********************************************************

when trying to use catch()

Need to return Observable from catch:

		return request
		    .map((res: Response) => res.json())
		    .catch((error: any) => {
		        // todo: log?

		        if (error.status == 500) {
		            this.alertService.showError(error.statusText);
		        } else if (error.status == 588) {
		            this.alertService.showAlert(error.statusText);
		        }

		        return Observable.throw(error.statusText);
		    });

or 

	return Observable.of({});



================================================================================

  Controlling which tests run in Jasmine
  **************************************

http://thejsguy.com/2016/01/03/controlling-which-tests-run-in-jasmine.html


Only Running Specific Tests / Specs
------------------------------------

If you want to run a specific test, use fit() instead of it(). The f stands for focused.

  describe("description", function() {
    fit("test 1", function() {

    });

    it("test 2", function() {

    });
  });

In the example above, only test 1 will execute. You can use as many fit() calls as you would like and only those tests will execute. Similar to when you exclude tests, if you are using Jasmine with Karma, the output on the terminal will note how many tests executed and how many were skipped.

What if you want to only run a specific describe() block? As you might guess, use fdescribe() instead of describe().

  fdescribe("description", function() {
    it("test 1", function() {

    });

    it("test 2", function() {

    });

    it("test 3", function() {

    });
  });

It is also worth noting that you can have focused and unfocused tests/specs inside nested fdescribe() blocks. When you do this, only the focused tests will run. For example:

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });

    fit("test 2", function() {

    });
  });

  fit("test 3", function() {

  });

  it("test 4", function() {

  });
});

In the example above, only test 2 and test 3 will run.

If your fdescribe() block only has a single test/spec, you can just use it() and that test will execute.

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });
  });

  fit("test 2", function() {

  });

  it("test 3", function() {

  });
});
In the example above, only test 1 and test 2 will execute.    


Excluding Tests / Specs
-----------------------

If you want to exclude a specific test, simply use xit() instead of it(). The x means exclude.

  describe("description", function() {
    xit("description", function() {

    });
  });

If you want to exclude an entire describe block, use xdescribe() instead of describe().

  xdescribe("description", function() {
    it("description", function() {

    });

    it("description", function() {

    });
  });

When you exclude tests, these tests will be noted as “skipped”.



================================================================================



Test Debugging

  Debug specs in browser in the same way that you debug an application

  1. click DEBUG button in the browser
    it opens a new tab and re-runs the test(s)

  2. open Developer Tools (ctr-shift-i)

  3. pick the "sources" section

    important: for the next step to work, you need to FIRST
      right-click anywhere in the Sources view
      and "Add folder to workspace" and select src/app


  4. open your ".spec.ts" test file (ctrl-P, then start typing name of file)

  5. set a breakpoint in the test

  6. refresh the browser and it stops at the breakpoint.


================================================================================

  Karma Configuration
  *******************


Add a new reporter
-------------------

$ npm install karma-spec-reporter --save-dev

in your karma.conf.js, add

  plugins: [
        . . .
        require('karma-spec-reporter')
      ],

and add reporters array:


  reporters: ['kjhtml', 'spec']





================================================================================
