
	********************

		Angular Material 

	********************

Resources: 
Hamburger menu
https://thesoftwayfarecoder.com/hamburger-menu-using-angular-material/


Tooltip with Angular CDK
-------------------------

https://indepth.dev/posts/1146/tooltip-with-angular-cdk




================================================================================


Wrapping Angular Material button in custom Angular component 
------------------------------------------------------------

Part 1
https://dev.to/this-is-angular/wrapping-angular-material-button-in-custom-angular-component-part-1-1ph1
Part 2
https://dev.to/this-is-angular/wrapping-angular-material-button-in-custom-angular-component-part-2-3oml


When you want to build your own Design System on top of Angular Material (or pretty much any other 3rd party component library), you have a couple of options:

1. Build a custom Angular Material theme and use the components as they are described in the documentation.

2. Build a custom Angular Material theme and build your own component library on top of Angular Material by wrapping their components in your own components.


ngComponentOutlet

  this directive provides a declarative approach for dynamic component creation.

================================================================================


Material sidenav
-------------------

==>  https://zoaibkhan.com/blog/create-a-responsive-sidebar-menu-with-angular-material/

https://careydevelopment.us/blog/how-to-add-a-responsive-sidebar-navigation-menu-to-your-angular-app
https://github.com/thisiszoaib/angular-responsive-sidebar



https://github.com/thisiszoaib/angular-responsive-sidebar


1.  

ng new angular-responsive-sidebar
ng add @angular/material

2. import 

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    AppRoutingModule,
    BrowserAnimationsModule,
    MatToolbarModule,
    MatSidenavModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}



3. Add toolbar and sidebar



<mat-toolbar>

Responsive side navigation
</mat-toolbar>

<mat-sidenav-container>
    <mat-sidenav>
    </mat-sidenav>
    <mat-sidenav-content>
        <div class="content mat-elevation-z8">
            Main content here!
        </div>
    </mat-sidenav-content>
</mat-sidenav-container>


mat-sidenav-container
---------------------

has

  mat-sidenav

    is your sidebar menu


  mat-sidenav-content

    main content of your app



4. add menu items


  <mat-sidenav class="mat-elevation-z8">

    <button mat-button class="menu-button" routerLink="/home">
      <mat-icon>home</mat-icon>
      <span>Home</span>
    </button>
    <button mat-button class="menu-button" routerLink="/profile">
      <mat-icon>person</mat-icon>
      <span>Profile</span>
    </button>
    <button mat-button class="menu-button" routerLink="/about">
      <mat-icon>info</mat-icon>
      <span>About</span>
    </button>

    </mat-sidenav>



5. Making the sidebar responsive


To make the sidebar responsive, the material sidenav component provides us with a property called mode. 
For large screen sizes, we want the mode to be "side". 
This means that the sidenav will always remain visible and our main content displayed with it.

The other mode is "over". We’ll need this when we want the sidebar to be hidden normally, but only appear over the content when we want to navigate to some other section.

So all we need is a way to switch between these modes when the screen size changes. Fortunately, we can detect screen size changes with the Angular CDK layout package and its BreakpointObserver service.


export class AppComponent {
  @ViewChild(MatSidenav)
 sidenav!: MatSidenav;

  constructor(private observer: BreakpointObserver) {}

  ngAfterViewInit() {
    this.observer.observe(['(max-width: 800px)']).subscribe((res) => {
      if (res.matches) {
        this.sidenav.mode = 'over';
        this.sidenav.close();
      } else {
        this.sidenav.mode = 'side';
        this.sidenav.open();
      }
    });
  }
}


First, we have a few ViewChild decorator at the very top to get the MatSidenva
component reference in our code.  Then, we include the BreakpointObserver service.

We're using the "observe" method of the BreakpointObserver which can take in any 
number of points.  If anby of them matches or changes state (i.e. stops matching),
all subscriptions to the method are notified.

In our case, we’re using 800px as our breakpoint. This means if it matches, 
we’ve to switch to the "over" mode for our sidebar and close it. And vice versa, if it doesn’t match.

  NOTE: Remember to keep the subscription in the ngAfterViewInit lifecycle method, 
  so that we’re assured we have the sidenav initialized before calling it!


6.  Adding the sidebar menu toggle button (Hamburger) for smaller screens


while the sidebar navigation menu hides on smaller screens, 
we have no way for it to show itself when we need it. 
We need a menu toggle button allow opening and closing of the menu on smaller screens! 


    <mat-toolbar class="mat-elevation-z8">
        <button mat-icon-button *ngIf="sidenav.mode === 'over'" (click)="sidenav.toggle()">
            <mat-icon *ngIf="!sidenav.opened">
                menu
            </mat-icon>
            <mat-icon *ngIf="sidenav.opened">
                close
            </mat-icon>
        </button>
        Responsive side navigation
    </mat-toolbar>

    <mat-sidenav #sidenav="matSidenav" class="mat-elevation-z8">
    ...
    </mat-sidenav>


We’ve added a template variable for the sidenav component using the #sidenav="matSidenav" syntax. 
This is basically doing the same thing as we did with the ViewChild decorator before, 
but this makes the reference available in the template.


For the toggle button, we’re using a material icon button. We’ve added an *ngIf directive to it so that it only shows when the sidenav has the over mode, which will happen on smaller screens. The button’s click event simply calls the toggle function of the sidenav component.

Lastly, we add some additional *ngIf directives to check whether the sidenav is open or not and show a different icon so it’s visually clear to the user.





================================================================================


Installation
-------------

	$ ng add @angular/material

this adds 

	@angular/cdk
	@angular/material



Configure animations
--------------------

should be done by the CLI.

@NgModule({
  imports: [BrowserAnimationsModule],
})

export class AppModule { }


Import the Angular Material component modules
---------------------------------------------

Imports the Angular Material component modules which you need in App.


Gesture Support
----------------


Some components (mat-slide-toggle, mat-slider, matTooltip) rely on HammerJS for gestures.

In order to urge the complete feature-set of those elements, HammerJS should be loaded into the appliance.

 npm install hammerjs --save
Complete installing HammerJS then import it on ‘main.ts’ file

import 'hammerjs';

================================================================================

  add Bootstrap Reboot to Angular Material project
  ------------------------------------------------

https://www.amadousall.com/the-good-parts-of-bootstrap-4-you-are-missing-in-your-angular-material-projects/


add bootstrap

  npm install bootstrap --save

import the Reboot Sass file into our global stylesheet src/styles.scss

// Imports functions, variables, and mixins that are needed by other Bootstrap files
@import "~bootstrap/scss/functions";
@import "~bootstrap/scss/variables";
@import "~bootstrap/scss/mixins";
// Import Bootstrap Reboot
@import "~bootstrap/scss/reboot";



Unfortunately it has introduced some styles that we do not want:

an outline when focus is set on buttons,
blue colored, and underlined button-links on hover,
blue links (blue is the primary color in Bootstrap)

To fix these issues, we create two Sass partials that we import in styles.scss:

src/_variables.scss: we import it before any Bootstrap import.
src/_reset.scss: we import it after all our Bootsrap imports

@import "variables";
@import "~bootstrap/scss/functions";
@import "~bootstrap/scss/variables";
@import "~bootstrap/scss/mixins";
@import "~bootstrap/scss/reboot";
@import "reset";



_variables.scss


The _variables.scss Sass partial allows us to customize Bootstrap - more precisely, the parts of Bootstrap that we will be using. That's why we added it before any Bootstrap import. This makes Bootstrap use our values instead of its default values. Those defaults are defined in ~bootstrap/scss/variables . For instance, $link-color: theme-color("primary") !default;.

Here is the content of the _variables.scss partial:

$link-color: #3f51b5;
$link-hover-color: currentColor;
$link-hover-decoration: none;
$label-margin-bottom: 0;


We set our links color to our primary color (#3f51b5) (we could have used our secondary color, if we wanted) as per the Material Design specification. We also set text-decoration: none; for hovered links.


_reset.scss



The _reset.scss Sass partial allows us to override some of the Bootstrap styles we don't want. That's why we added it after all Bootstrap imports.

* {
  &:active,
  :focus {
    outline: none !important;  // 1
  }
}

a:not(.mat-button):not(.mat-raised-button):not(.mat-fab):not(.mat-mini-fab):not([mat-list-item]) {
    color: #3f51b5; // 2
  }
Remove the blue outline on links, and buttons when they are active; or the focus is set on them.
Use our primary color for all links that are not Angular Material elements. Those have one of the following classes: .mat-button, mat-raised-button, mat-fab-button, mat-list-item, etc.






================================================================================

	<mat-button-toggle>
	<mat-button-toggle-group>
	*****************************


The <mat-button-toggle>, an Angular Directive, is used to create a toggle or on/off button with material styling and animations. 

mat-button-toggle buttons can be configured to behave as radio buttons or checkboxes. 

Typically they are part of <mat-button-toggle-group>.

app.module.ts
--------------

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { AppComponent } from './app.component';
import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
import {MatButtonToggleModule, MatIconModule} from '@angular/material'
import {FormsModule, ReactiveFormsModule} from '@angular/forms';
@NgModule({
   declarations: [
      AppComponent
   ],
   imports: [
      BrowserModule,
      BrowserAnimationsModule,
      MatButtonToggleModule, MatIconModule,
      FormsModule,
      ReactiveFormsModule
   ],
   providers: [],
   bootstrap: [AppComponent]
})
export class AppModule { }

app.component.css
-----------------

.tp-selected-value {
   margin: 15px 0;
}

app.component.div
------------------

<mat-button-toggle-group #group = "matButtonToggleGroup">
   <mat-button-toggle value = "left">
      <mat-icon>format_align_left</mat-icon>
   </mat-button-toggle>
   <mat-button-toggle value = "center">
      <mat-icon>format_align_center</mat-icon>
   </mat-button-toggle>
   <mat-button-toggle value = "right">
      <mat-icon>format_align_right</mat-icon>
   </mat-button-toggle>
   <mat-button-toggle value = "justify" disabled>
      <mat-icon>format_align_justify</mat-icon>
   </mat-button-toggle>
</mat-button-toggle-group>
<div class = "tp-selected-value">Selected value: {{group.value}}</div>



another example
----------------

template:
-----------

<form [formGroup]="outerForm">
	<div formGroupName="secondFormGroup">
		<mat-button-toggle-group #group="matButtonToggleGroup" (change)="onEndpointValChange(group.value)" multiple="false" formControlName='endpoints'
		 [(ngModel)]="myFlagForButtonToggle">
			<mat-button-toggle *ngFor="let item of endpointToggleOptions;" [value]="item">{{item}}</mat-button-toggle>
		</mat-button-toggle-group>
	</div>
</form>

component:
------------

import { Component } from '@angular/core';

import { FormGroup, FormBuilder, Validators, FormControl } from '@angular/forms';

/**
 * @title Exclusive selection
 */
@Component({
  selector: 'button-toggle-exclusive-example',
  templateUrl: 'button-toggle-exclusive-example.html',
  styleUrls: ['button-toggle-exclusive-example.css'],
})
export class ButtonToggleExclusiveExample {

  myFlagForButtonToggle: String = "Single";
  endpointToggleOptions: Array<String> = ["Single", "Multiple"];
  outerForm: FormGroup;
  constructor(private _formBuilder: FormBuilder) {
    this.outerForm = this._formBuilder.group({
      firstFormGroup: this._formBuilder.group({ pidNumber: new FormControl(''), }), secondFormGroup:
        this._formBuilder.group({ endpoints: new FormControl(''), })
    });
  }
}






================================================================================

  Custom Theme
  ************

A custom theme is created by composing multiple palettes:


  primary palette

    most widely used colors across all screens and components


  accent palette

    colors used for the floating action buttons and interactive elements


  warn palette

    colors used to convey error state


  foreground palette

    text and icon colors


  background palette

    colors used for element backgrounds





================================================================================

  mat-dialog Angular Material Dialog 
  **********************************

  https://blog.angular-university.io/angular-material-dialog/


1. declare material dialog body component

import MatDialogModule

2. how can we open a dialog from one of our components?

  - inject MatDialog service via constructor 

    constructor(private dialog: MatDialog) {}

  - create an instance of `MatDialogConfig` 

    const dialogConfig = new MatDialogConfig();

  - override default behaviours if nec.

    dialogConfig.disableClose = true; // cannot close by clicking out
    dialogConfig.autoFocus = true;







Dialog Configuration Options
-----------------------------

hasBackdrop:
    whether the dialog should have a shadow backdrop that blocks the user from 
    clicking on the rest of the UI while the dialog is opened (default: true)

panelClass:
    adds a list of custom CSS classes to the Dialog panel

backdropClass:
    adds a list of custom CSS classes to the dialog backdrop

position:
    defines a starting absolute position for the dialog

direction:
    defines if the elements inside the dialog are right or left justified.
    default:  l-to-r (ltr)

closeOnNavigation:
    defines if the dialog should auto close itsel when we navigate to 
    another route in our SPA, 
    default: true


MatDialogConfig
    also provides properties width, height, minWidth, minHeight, maxWidth and 
    MaxHeight


Directives
-----------

mat-dialog-title

mat-dialog-content

mat-dialog-actions



Passing Input data into Material Dialog
-----------------------------------------

dialogs are often used to edit existing data.
we can pass data to the dialog component
by using the `data` property of the dialog configuration object


    openDialog() {
        const dialogConfig = new MatDialogConfig();
    }

    dialogConfig.disableClose = true;
    dialogConfig.autoFocus = true;

    dialogConfig.data = {
      id: 1,
      title: 'Angular for Beginners'
    };

    this.dialog.open(CourseDialogComponent, dialogCongig);


We can then get a reference to this data object in 
`CourseDialogComponent` by using the `MAT_DIALOG_DATA` 
injectable:



  export class CourseDialogComponent implements OnInit {

    form: FormGroup;
    description: string;

    constructor(
      private fb: FormBuilder,
      private dialogRef: MatDialogRef<CourseDialogComponent>,
      @Inject(MAT_DIALOG_DATA) data) {

        this.description = data.description;

    }

    save() {
      this.dialogRef.close(this.form.value);
    }

    close() {
      this.dialogRef.close();
    }
    
  }



      <div class="col-12 col-md-4 pt-2 pt-md-0 px-md-0 justify-content-start justify-content-md-center">
        <span> {{drupalContent?.footerCenterPrefix}}
          <a (click)="showIdentityProtectionNavModal()">{{drupalContent?.footerCenter}}</a>
        </span>
      </div>


================================================================================

  mat-radio-button


::ng-deep .custom-radio-button-error .mat-radio-outer-circle{
  border-color: rgb(255, 49, 49); /* default outer ring color */
}

::ng-deep .custom-radio-button-error .mat-radio-label-content {
  color: red; /* label color */
}






::ng-deep .mat-radio-inner-circle {
  background-color: #3f51b5;
}

/deep/ .mat-radio-ripple .mat-ripple-element {
  background-color: rgba(#3f51b5, 0.26);
}

::ng-deep .mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element {
  background-color: blue !important;
}

::ng-deep .mat-radio-button.mat-accent .mat-radio-inner-circle {
  background-color: blue!important;   /*inner circle color change*/
}

::ng-deep.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle {
  border-color:blue!important; /*outer ring color change*/
}



================================================================================

  mat-table
  *********

1. add <table mat-table>  component to template and pass in data.

simplest way is to pass in a data array to the tables's `dataSource` input.

<table mat-table [dataSource]="myDataArray">
  ...
</table>

the table is optimized for performance - it will not automatically check for 
changes to the data array.

instead, when the data changes, you can trigger an update to the table's
rendered rows by calling it's 

  renderRows() 

method.

2. define the column templates  

matColumnDef
--------------

Each column definition should be given a unique name and contain the content
for its header and row cells.

  `matColumnDef` directive uniquely identifies a given column with a key.


matHeaderCellRef
----------------

matHeaderCellDef
matCellDef
----------------

    <ng-container matColumnDef="score">
      <th mat-header-cell *matHeaderCellDef> Score </th>
      <td mat-cell *matCellDef="let user"> {{user.score}} </td>
    </ng-container>


3. Define your row templates

finally, once you've defined your columns, you need to tell the table which 
columns will be rendered in the header and data rows.

Create a variable in your component that contains the list of the columns 
you want to render:

  columnsToDisplay = [ 'userName', 'age' ];


mat-header-row
mat-row
--------------------
  applies some minimum Material styling


matHeaderRowDef
matRowDef
---------------
  identifies a configuration element for the table header row,
  but does not apply any styling



Then, add `mat-header-row` and `mat-row`  to the content of your `mat-table`
and provide your column list as inputs 


<tr mat-header-row *matHeaderRowDef="columnsToDisplay"></tr>
<tr mat-row *matRowDef="let myRowData; columns: columnsToDisplay"></tr>

The list of columns provided to the rows can be in any order, not necessarily
the order in which you wrote the column definitions.

By changing your column list provided to the rows, you can easily re-order
and include/exclude columns dynamically.


Sourtable Table Headers
matSort and mat-sort-header
---------------------------

https://stackoverflow.com/questions/46743115/default-sorting-in-angular-material-sort-header

add `matSort` directive to `mat-table`


<mat-table  ....
    matSort matSortActive="seqNo" matSortDirection="asc" matSortDisableClear>


matSortActive
  when the data is passed to the data table, it is usually already sorted.
  this directive allows us to inform the data table that the data is already sorted
  by the "seqNo" column, so the "seqNo" column sorting icon will be displayed
  as an UPwards arrow.

matSortDirection
  this is a companion directive to `matSortActive`
  it specifies the driection of the initial sort.
  In this case, the data is initially sorted by the `seqNo` column in "asc" order
  so the header will adapt the sorting icon accordingly.

matSortDisableClear
  To prevent the user from clearing the sort state from an already sorted column, 
  set matSortDisableClear to true on the matSort to affect all headers, 

  or set disableClear to true on a specific header.


The above is the SORT Configuration for the whole data table.
But we also need to identify exactly WHAT table headers are sortable!

mat-sort-header
----------------

use `mat-sort-header` directive to annotate which column is sortable

   <ng-container matColumnDef="seqNo">
        <mat-header-cell *matHeaderCellDef mat-sort-header>#</mat-header-cell>
        <mat-cell *matCellDef="let lesson">{{lesson.seqNo}}</mat-cell>
    </ng-container>




Advanced data sources
*********************

  The simplest way to provide data to your table is by passing a data array.

  More complex use cases may be using Observable streams, or

  encapsulate your data source logic into a DataSource class.


Observable stream that emits the data array to be rendered each time it is changed.


DataSource

  is meant to serve as a place to encapsulate any sorting, filtering, pagination, 
  and data retrieval logic specific to the application.


  It is a class that has a minimum the following methods:

    connect()
    disconnect()

  Material provides a ready-made  DataSource class -  MatTableDataSource

  you may want to create your own custom DataSource class for more complex
  use cases.

  You can extend the abstract DataSource class and implement your own
  connect() and disconnect()

  or 

  MyCustomDataSource  extends SomeOtherBaseClass implements DataSource


MatTableDataSource
------------------

  designed for filtering, sorting and pagination of a `client-side` data array.

  when you have those functions done on the backend, you will need to provide
  your own reactive DataSource



Styling Rows 
------------------------

applies style defined in  $headerColor  to  `mat-header-cell`

          <!-- Name Column -->
          <ng-container matColumnDef="name">
            <th mat-header-cell *matHeaderCellDef [style.background-color]="headerColor"> Name </th>
            <td mat-cell *matCellDef="let element"> {{element.name}} </td>
          </ng-container>



  Styling Columns
--------------------------

Each table cell has an automatically generated class based on which column 
it appears in.

in the format of    `mat-column-NAME`


Column Width
---------------------

using `mat-column-NAME` convention

https://fireflysemantics.medium.com/making-the-angular-material-data-table-rows-fit-content-f227f4d9355e


.mat-footer-row,
.mat-header-row,
.mat-row {
  display: inline-flex;
  min-width: 100%;
}

.mat-column-position {
  flex: 0 0 10%;
}
.mat-column-name {
  flex: 0 0 30%;
}
.mat-column-weight {
  flex: 0 0 30%;
}
.mat-column-symbol {
  flex: 0 0 30%;
}




Apply style to table row
-------------------------

row template

 <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
 <tr mat-row *matRowDef="let row; columns: displayedColumns;" [ngClass]="{'highlight': isOdd(row.position) }"></tr>

scss

  ::ng-deep .highlight{
    background: lightgray;
  }



Row Templates
-------------------------

Event handlers and property binding on the row tempalates will be applied
to each row rendered by the table.

E.g.    adding a (click) handler to the row template will cause each 
individual row to call the handler when clicked.




Custom DataSource
*************************************


connect() method

  This method will be called ONCE by the Data Table at table bootstrap time. 


  The Data Table expects this method to return an Observable, and the values of that observable contain the data that the Data Table needs to display.

  As the user clicks on the paginator and changes to a new page,
  this observable will emit a new value with the lessons page.

  This method will be implemented using a BehaviorSubject.
  It will return data  as Observable.

    return this.lessonsSubject.asObservable();

  BehaviorSubject means the subscribers will always get its latest emitted value
  or initial value, even if they subscribed late (after the value was emitted)

  BehaviorSubject is perfect for writing code that works independently of the order
  of operations.





mat-table elevation
----------------------

https://stackoverflow.com/questions/54626039/how-to-change-elvation-of-a-row-in-mat-table
https://stackblitz.com/edit/angular-ecrvzg?embed=1&file=app/table-basic-example.css




row box shadow
--------------
https://stackoverflow.com/questions/57524201/need-box-shadow-for-mat-row-angular
https://stackblitz.com/edit/angular-rows-with-boxshadow



================================================================================

  mat-elevation helpers
  ---------------------

The core-theme Sass mixin, described in the [theming guide][], emits CSS classes for applying elevation. These classes follow the pattern 

mat-elevation-z#, 

where # is the elevation number you want, from 0 to 24. 

These predefined classes use the CSS box-shadow settings defined by the Material Design specification.

You can dynamically change elevation on an element by swapping elevation CSS classes.

<div [class.mat-elevation-z2]="!isActive" [class.mat-elevation-z8]="isActive"></div>


================================================================================

  how to center mat-spinner
  **************************

By default progress spinner will be displayed at the top-left corner of the webpage.


To center the progress spinner, set the margin of mat-spinner element to “0 auto”

  <mat-spinner style="margin:0 auto;"></mat-spinner>

The above code will center mat-spinner horizontally.




To center it in the middle of the page
--------------------------------------

In some cases, we will display a progress spinner overlay over an HTML element or entire DOM.

Follow the below steps to display mat-spinner, overlay over entire webpage.

1. First center the mat-spinner in the middle of the webpage.
2. Place it inside an overlay div element

https://www.angularjswiki.com/angular/creating-progress-spinner-in-angular/



================================================================================

  mat-paginator  
  --------------

Angular Material Pagination Datasource by Nils Mehlhorn
https://medium.com/angular-in-depth/angular-material-pagination-datasource-73080d3457fe

https://material.angular.io/components/paginator/overview


Each paginator instance requires:

  - the number of items per page ( defautl 50 )
  - the total number of items being paged


Get rid of the spinner for now 


      <div *ngIf="dataSource.loading$ | async; then loadingProgressTemplate else elementTableTemplate"></div>

      <ng-template #loadingProgressTemplate>
        <div>
          <mat-spinner style="margin:0 auto;"></mat-spinner>
        </div>
      </ng-template>

      <ng-template #elementTableTemplate>
      </ng-template>




EventListener on mat-paginator last or first button
---------------------------------------------------


I need to listen when I especially click on mat-paginator last-button.


MatPaginator have method lastPage you can trigger it from ts file like in this example:

@ViewChild(MatPaginator) paginator: MatPaginator;

 ngAfterViewInit() {
  this.paginator.lastPage = () => this.yourMethodToTrigger();
 }

 yourMethodToTrigger(){
  console.log('Triggered!')
 }

https://material.angular.io/components/paginator/api


================================================================================

  mat-input-container
  ********************

seems to be replaced with `mat-form-field`


================================================================================

  mat-form-field
  **************

https://material.angular.io/components/form-field/overview

a wrapper component to apply common Text field styles like underline,
floating label, and hint messages.

"form field"  - the wrapper component
"form field control" - input, text area, or select that <mat-form-field> is wrapping.



================================================================================

  mat-tab
  ********

Lazy Loading and routing
------------------------

https://medium.com/nerd-for-tech/implement-lazy-loading-with-mat-tabs-in-angular-2d291f5f5315


overriding label color for a particular tab
--------------------------------------------


https://stackoverflow.com/questions/62810892/overwriting-css-for-angular-mat-tab

You can use the component tag label,

 app-component-name .mat-tab-label {
    min-width: 25px !important;
    padding: 5px;
    background-color: transparent;
    color: white;
    opacity: 1 !important;
    font-weight: 700;
}

Or add a class to the tab



================================================================================

  mat-progress-bar custom theme
  -----------------------------

Got the idea from 
https://stackoverflow.com/questions/48869915/angular-material-progressbar-custom-color


$height: 8px;

mat-progress-bar.mat-progress-bar {
  height: $height;

  // background for the progress bar
  &.mat-accent .mat-progress-bar-buffer {
    background: $color-base-subdued-1;
  }

  // fill indicating progress
  &.mat-accent .mat-progress-bar-fill::after {
    background-color: $color-brand-default;
  }
}

...........................................

another option

https://newbedev.com/angular-material-progressbar-custom-color


mat-progress-bar .mat-progress-bar-buffer {
  background: #E4E8EB;
}


<mat-progress-bar  mode="determinate" value="{{progress}}"></mat-progress-bar>



@Component({
  selector: '...',
  templateUrl: '...',
  styleUrls: ['...'],
  encapsulation: ViewEncapsulation.None,
})



.audio-progress-bar {
  &.mat-progress-bar {
    height: 10px;
  }

  .mat-progress-bar-fill::after {
    background-color: #37474f;
  }

  .mat-progress-bar-buffer {
    background-color: #90a4ae;
  }

  /* remove animation and the dots*/ 
  .mat-progress-bar-background {
    animation: none;
    background-color: #eceff1;
    fill: #eceff1;
  }
}


<mat-progress-bar
  class="audio-progress-bar"
  mode="buffer"
></mat-progress-bar>



--------------------

.green-progress .mat-progress-bar-fill::after {
    background-color: green !important;
}


<mat-progress-bar class="green-progress" mode="indeterminate"></mat-progress-bar>


================================================================================

Creating Custom Overlay OverlayContainter
------------------------------------------

https://stackoverflow.com/questions/63579801/how-do-i-create-a-custom-overlay-container-for-angular-material

https://github.com/angular/components/issues/7349#issuecomment-337513040


https://stackoverflow.com/questions/67556161/angular-cdk-injecting-the-custom-overlay-container-class-into-a-component-crea




================================================================================

Angular Material CDK
*********************


Overlay module
--------------------


An overlay requires 3 things:

1. a template - to render the contents of the overlay on the screen
2. an origin  - the location where to render the overlay
3. a condition - to decide whether to show the overlay or not


Example 1: dropdown, and the trigger will be a button click




template with  a button
- - - - - - - - - - - - 

define the button as the origin and connect it to the template.
the template is also marked as cdkConnectedOverlay so that the CDK knows that this template will be an overlay


<button
  cdkOverlayOrigin
  *trigger="cdkOverlayOrigin"
>
   Open/close overlay
</button>
<div>This content will be under the overlay</div>

<ng-template
  cdkConnectedOverlay
  [cdkConnectedOverlayOrigin]="trigger"
>
   <ul class="example-overlay">
      <li>Item 1</li>
      <li>Item 2</li>
      <li>Item 3</li>
   </ul>
</ng-template>




================================================================================

ErrorStateMatcher

https://www.youtube.com/watch?v=yWw7CYFIDVw


https://material.angular.io/components/input/overview

import {Component} from '@angular/core';
import {FormControl, FormGroupDirective, NgForm, Validators} from '@angular/forms';
import {ErrorStateMatcher} from '@angular/material/core';

/** Error when invalid control is dirty, touched, or submitted. */
export class MyErrorStateMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
    const isSubmitted = form && form.submitted;
    return !!(control && control.invalid && (control.dirty || control.touched || isSubmitted));
  }
}

/** @title Input with a custom ErrorStateMatcher */
@Component({
  selector: 'input-error-state-matcher-example',
  templateUrl: './input-error-state-matcher-example.html',
  styleUrls: ['./input-error-state-matcher-example.css'],
})
export class InputErrorStateMatcherExample {
  emailFormControl = new FormControl('', [Validators.required, Validators.email]);

  matcher = new MyErrorStateMatcher();
}
================================================================================

  Material password field with Visibility toggle
  ------------------------------------------------

https://fireflysemantics.medium.com/angular-material-password-field-with-visibilitytoggle-d5342f97afbe


https://nitishkaushik.com/show-hide-password-in-angular-with-angular-material/


================================================================================

  Angular material extensions  password strength
  ----------------------------------------------
  https://github.com/angular-material-extensions/password-strength

https://github.com/angular-material-extensions/password-strength


<mat-form-field appearance="outline" style="width: 100%" [color]="passwordComponent.color">
  <mat-label>Password</mat-label>
  <!-- HERE DOWN :D-->
  <mat-pass-toggle-visibility #toggle matSuffix></mat-pass-toggle-visibility>
  <!-- THERE ABOVE ;)-->
  <input matInput #password
         [type]="toggle.type"
         required
         placeholder="Password">
  <mat-hint align="end" aria-live="polite">
    {{password.value.length}} / 25
  </mat-hint>
</mat-form-field>

<mat-password-strength #passwordComponent
                                   (onStrengthChanged)="onStrengthChanged($event)"
                                   [password]="password.value">
</mat-password-strength>

================================================================================

  Material mat-error 
-------------------------

  ErrorStateMatcher

  Custom Validator

how to change the default behavior of Angular Material input and other form controls.

https://material.angular.io/components/input/overview#custom-error-matcher

If you wish to override this behavior (e.g. to show the error as soon as the invalid control is dirty or when a parent form group is invalid), you can use the errorStateMatcher property of the matInput. The property takes an instance of an ErrorStateMatcher object. An ErrorStateMatcher must implement a single method isErrorState which takes the FormControl for this matInput as well as the parent form and returns a boolean indicating whether errors should be shown. (true indicating that they should be shown, and false indicating that they should not.)


https://stackoverflow.com/questions/46745171/angular-material-show-mat-error-on-button-click

I would make a separate file such as default.error-matcher.ts

/** Error when invalid control is dirty or touched*/
export class MyErrorStateMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
    return !!(control && control.invalid && (control.dirty || control.touched));
  }
}


Then in the TS file add:

matcher = new MyErrorStateMatcher();

Then change the input to use matcher:

<mat-form-field>
    <input matInput 
    placeholder="Due Date" 
    name="dueDate" 
    [(ngModel)]="dueDate" 
    [formControl]="dueDateValidator" 
    [errorStateMatcher]="matcher" 
    required>
    <mat-error *ngIf="dueDateValidator.invalid">Due Date is required for Tasks</mat-error>
</mat-form-field>


Angular: mat-error is not working on custom validator
---------------------
https://stackoverflow.com/questions/68937343/angular-mat-error-is-not-working-on-custom-validator

https://stackblitz.com/edit/angular-mat-form-validation-eg-mcnmba?file=app%2Finput-error-state-matcher-example.html,app%2Finput-error-state-matcher-example.ts


function dateCheck(): ValidatorFn {
  return (control: AbstractControl): { [key: string]: boolean } | null => {
    if (
      control.value.end_date &&  //<--check only if has value, not !==undefined
      (isNaN(control.value.end_date) ||
        control.value.end_date < control.value.start_date)
    ) {
      return { validator: true };  //<--see that it's "validator"
    }
    return null;
  };
}


export class DateEndMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
    const isSubmitted = form && form.submitted;
    //see the comparision
    return !!(control && (control.invalid || form.invalid) && (control.dirty || control.touched || isSubmitted));
  }
}

================================================================================

  Angular Material CDK Overlay
  ****************************

Custom Overlays with Angular's CDK

https://blog.thoughtram.io/angular/2017/11/20/custom-overlays-with-angulars-cdk.html  


https://levelup.gitconnected.com/help-popup-with-angular-material-cdk-overlay-babc2ab127a


https://juanac2021.medium.com/angular-create-your-own-overlay-with-customized-position-strategy-builder-to-attach-overlay-to-fde54a5eeea7




The overlay package provides a way to open floating panels on the screen.

The CDK overlays depend on a small set of structural styles to work correctly. If you're using Angular Material, these styles have been included together with the theme, otherwise if you're using the CDK on its own, you'll have to include the styles yourself. 


  @import '@angular/cdk/overlay-prebuilt.css';



Position strategies
====================


The positionStrategy configuration option determines how the overlay will be positioned on-screen. There are two position strategies available as part of the library: 

GlobalPositionStrategy 

  and 

ConnectedPositionStrategy


GlobalPositionStrategy
-----------------------

  is used for overlays that require a specific position in the viewport, unrelated to other elements. 
  This is commonly used for modal dialogs and application-level notifications.

ConnectedPositionStrategy
--------------------------

  is used for overlays that are positioned relative to some other "origin" element on the page. This is commonly used for menus, pickers, and tooltips. When using the connected strategy, a set of preferred positions is provided; the "best" position will be selected based on how well the overlay would fit within the viewport.



// top-left
originX: 'start', // left corner of the button
originY: 'bottom', // bottom corner of the button
overlayX: 'start', // left corner of the overlay to the origin
overlayY: 'top', // top corner of the overlay to the origin

// top-right
originX: 'end', // right corner of the button
originY: 'bottom', // bottom corner of the button
overlayX: 'end', // right corner of the overlay to the origin
overlayY: 'top', // top corner of the overlay to the origin

// bottom-left
originX: 'start', // left corner of the button
originY: 'top', // top corner of the button
overlayX: 'start', // left corner of the overlay to the origin
overlayY: 'bottom', // top corner of the overlay to the origin

// bottom-right
originX: 'end', // right corner of the button
originY: 'top', // top corner of the button
overlayX: 'end', // right corner of the overlay to the origin
overlayY: 'bottom', // top corner of the overlay to the origin


Custom Position Strategy
------------------------

  A custom position strategy can be created by implementing the PositionStrategy interface. Each PositionStrategy defines an apply method that is called whenever the overlay's position should be updated. A custom position strategy can additionally expose any other APIs necessary as related to the positioning of the overlay element.




Scroll strategies
-----------------



================================================================================

