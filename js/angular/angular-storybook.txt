	*****************

		Storybook JS

	*****************


================================================================================

	Storybook for Angular
	*********************

$ npx -p @storybook/cli sb init --type angular

manually:
---------

	$ npm install @storybook/angular --save-dev
	$ npm install babel-loader @babel/core --save-dev 

add npm script:

	{
	  "scripts": {
	    "storybook": "start-storybook"
	  }
	}

create main file:

	.storybook/main.js

	module.exports = {
		stories: ['../src/**/*.stories.[tj]s'],
	};

storybook typescript configuration:

	.storybook/tsconfig.json

	{
		"extends": "../tsconfig.json",
		"exclude": [
		  "../src/test.ts",
		  "../src/**/*.spec.ts",
		  "../projects/**/*.spec.ts"
		],
		"include": [
		  "../src/**/*",
		  "../projects/**/*"
		]
	}	

================================================================================

	writing stories
	***************

A Storybook is a collection of stories. Each story represents a single visual state of a component.

Technically, a story is a function that returns something that can be rendered to screen.




supported formats
*****************



	Component Story Format (CSF)
	------------------------------------------------------------------------------

	https://storybook.js.org/docs/formats/component-story-format/
	https://medium.com/storybookjs/component-story-format-66f4c32366df

	CSF has every affordance of the storiesOf API, but brings many additional benefits:
		ğŸ’ Simple. 
			Writing stories is as easy as exporting ES6 functions from your story file in a clean, standard format you know and love.
		ğŸšš Portable. 
			Component stories are easily consumed anywhere ES6 modules live, including your favorite testing tools like Jest and Cypress.
		ğŸ”¥ Optimized. 
			Component stories donâ€™t need any libraries other than your components. And because theyâ€™re ES6 modules, theyâ€™re even tree-shakeable!
		â˜ï¸ Declarative. 
			The declarative syntax is isomorphic to higher-level formats like MDX, enabling clean, verifiable transformations.
		ğŸ‘¾ Future-proof. 
			Component stories hide Storybookâ€™s underlying API, giving maintainers flexibility to improve Storybook without breaking any contracts.

	CSF is supported in all frameworks except React Native, where you should use the storiesOf API instead.


	example:

		export default { title: 'atoms/Button' };
		export const text = () => <Button>Hello</Button>;
		export const emoji = () => <Button>ğŸ˜€ğŸ˜ğŸ‘ğŸ’¯</Button>;



	Default Export
	--------------

		The default export defines metadata about your component, including 
			the component itself, 
			its title (where it will show up in the navigation UI story hierarchy), 
			decorators, and 
			parameters. 

		title should be unique, i.e. not re-used across files.

			import MyComponent from './MyComponent';

			export default {
			  title: 'Path/To/MyComponent',
			  component: MyComponent,
			  decorators: [ ... ],
			  parameters: { ... }
			}


	Named Story Exports
	-------------------

		With CSF, every named export in the file represents a story function by default.

			import MyComponent from './MyComponent';

			export default { ... }

			export const Basic = () => <MyComponent />;
			export const WithProp = () => <MyComponent prop="value" />;

		Itâ€™s recommended to start export names with a capital letter.

		Story functions can be annotated with a story object 
		to define story-level decorators and parameters, and also 
		to define the name of the story.


		export const Simple = () => <MyComponent />;

		Simple.story = {
		  name: 'So simple!',
		  decorators: [ ... ],
		  parameters: { ... }
		};

	Non-story exports
	------------------

		In some cases, you may want to export a mixture of story and non-stories. 
		For example, it can be useful to export data thatâ€™s used in your stories.

		you can use optional includeStories and excludeStories configuration fields in the default export, 
		which can be set to either an array of strings, or a regular expression.

			export default {
			  title: 'MyComponent',
			  component: MyComponent,
			  includeStories: ['SimpleStory', 'ComplexStory']
			}

			export const simpleData = { foo: 1, bar: 'baz' };
			export const complexData = { foo: 1, { bar: 'baz', baz: someData }};

			export const SimpleStory = () => <MyComponent data={simpleData} />;
			export const ComplexStory = () => <MyComponent data={complexData} />;

		For this specific example the equivalent result can be achieved in a few ways depending on whatâ€™s convenient:

			includeStories: ['SimpleStory', 'ComplexStory']
			includeStories: /.*Story$/
			excludeStories: ['simpleData', 'complexData']
			excludeStories: /.*Data$/


	storiesOf API 
	------------------------------------------------------------------------------


		storiesOf('atoms/Button', module)
	  .add('text', () => <Button>Hello</Button>)
	  .add('emoji', () => <Button>ğŸ˜€ğŸ˜ğŸ‘ğŸ’¯</Button>);




	MDX Syntax
	------------------------------------------------------------------------------






================================================================================

	Markdown Support
	****************

Markdown seems to be now added by default in .storybook/main.js


module.exports = {
  stories: ['../src/**/*.stories.ts'],
  addons: ['@storybook/addon-actions', '@storybook/addon-links', '@storybook/addon-notes'],
};


However, you will still get an error

TS2307: Cannot find module './notes/component-a.notes.md'.

So to fix it, create globals.d.ts file in the root folder with:

declare module '*.md';


================================================================================

	angular material 
	****************

angular material stories examples
---------------------------------

https://github.com/amcdnl/material-storybook
https://amcdnl.github.io/material-storybook/


================================================================================