
	*****************************

		Angular Architecture

	*****************************


==============================================================================

https://www.angulararchitects.io/aktuelles/the-new-treeshakable-providers-api-in-angular/


The new Treeshakable Providers API in Angular
---------------------------------------------

angular service modules
-----------------------
https://stackoverflow.com/questions/57289971/are-angular-service-modules-still-required

A service module would be required if you are using lazy loaded modules which have specific services only provided inside that module.

You can't provide a service into the same module where components of that module get the service injected.

So assume you have a MyFeatureModule

  @NgModule({
    imports:      [ ],
    providers:    [ ],
    declarations: [ MyFeatureComponent ],
    exports:      [ ],
  })
  export class MyFeatureModule { }


and you have a service which contains logic only for your feature, then you cannot do the following:

  Injectable({ providedIn: MyFeatureModule})
  export class MyFeatureService {}


You would get a cycle!

To resolve the issue you need to create a specific service module and import that module into the feature module:

  @NgModule({
    imports:      [ ],
    providers:    [ ],
    declarations: [ ],
    exports:      [ ],
  })
  export class MyFeatureServiceModule { }
  Injectable({ providedIn: MyFeatureServiceModule})
  export class MyFeatureService {}
  @NgModule({
    imports:      [ MyFeatureServiceModule ],
    providers:    [ ],
    declarations: [ MyFeatureComponent ],
    exports:      [ ],
  })
  export class MyFeatureModule { }



==============================================================================

  Component

  @Input
  @output


Parent and Child components can communicate with each other via Inputs and
Outputs.


<parent-component>
  <child-component></child-component>
</parent-component>

The <parent-component> serves as the context for the <child-component>.

@Input() and @Output() give a child component a way to communicate with its parent component. 

@Input() allows a parent component to update data in the child component. 

Conversely, @Output() allows the child to send data to a parent component.


Sending data to Child
----------------------

The @Input() decorator in a child component or directive signifies that 
the property can receive its value from its parent component.


  configure child

  export class ChildComponent {
    @Input() item = '';  // decorate property with @Input()
  }

  <p>
    Today's item; {{item}}
  </p>


  Configure parent

  In the parent's template:

    <child [item]="currentItem"></child>

  In parent's class

  export class Parent {

  }


    <child [item]="currentItem"></child>

The target in the square brackets, [], is the property you decorate with @Input() in the child component. 


Sending data to Parent
----------------------

@Output() marks a property in a child component as a doorway through which data can travel from the child to the parent.

The CHILD uses the @Output() property to raise an event to notiy the parent of the change.
To raise an event, an @Output() must have the type of EventEmitter.


  Configure Child

here, you have an <input> where a user can enter a value and click a <button>
that raises an event.

The EventEmitter then relays the data to the parent component.


  @Output() newItemEvent = new EventEmitter<string>();

  addNewItem(value: string) {
    this.newItemEvent.emit(value);
  }

child's template

  <label for="item-input">Add an item:</label>
  <input type="text" id="item-input" #newItem>
  <button (click)="addNewItem(newItem.value)">Add to parent's list</button>


  Configure Parent



<child (newItemEvent)="addItem($event)"></child>


  addItem(newItem: string) {
    this.items.push(newItem);  // adds new item coming from the child
  }



Using both @Input and @Output() together
-----------------------------------------


<child [item]="currentItem" (deleteRequest)="crossOffItem($event)"></child>


The child selector is <child> with item and deleteRequest being @Input() and @Output() properties in the child component class. 

The property currentItem and the method crossOffItem() are both in the parent component class.










================================================================================


  @ViewChild
  **********************

https://blog.angular-university.io/angular-viewchild/


Sometimes, a component needs references to the multiple elements that it contains inside
its template, in order to mediate their interaction.


If that's the case, then we can obtain references to those template elements and have them injected into the AppComponent class by querying the template: that's what @ViewChild is for.

Let's say that AppComponent needs a reference to the <color-sample> component that it uses inside its template, in order to call a method directly on it.


Here, we inject a reference to <color-sample> instance named #primaryColorSample:

  @ViewChild('primaryColorSample')
  primarySampleComponent: ColorSampleComponent;


this variable is not immediately available - angular will fill this property AFTER
view initialization is complete.


  ngAfterViewInit() {
    console.log('Values on ngAfterViewInit():');
    console.log("primaryColorSample:", this.primarySampleComponent);
  }  


SCOPE:  only the template of the component itself.


create a reference to an HTML tag
----------------------------------

<h2 #title>Choose Brand Colors:</h2>

  @ViewChild('title')
  title: ElementRef;



when injecting a reference applied to a component, we get back the component instance

when injecting a reference to a plain HTML element, we get back the corresponding wrapped DOM element



@ViewChild options argument
----------------------------

  @ViewChild('primaryColorSample', {read: ElementRef})
  sample: ElementRef;

we are passing a second argument containing a configuration object with the read property set to ElementRef.





================================================================================

	View Layer Architecture
	************************

https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/


Smart Components vs Presentation Components
*******************************************

smart components

	app-level components, or controller components
	very tied to this particular application
	it would be hard to reuse it in another app

	knows where data comes from, or what type of data there is .. 
	does not know how to present data to the user

	receives application-specific dependencies via constructor, e.g. LessonService.
	injects data to the presentation component via @Input, and 
	receives any actions that the presentation component might trigger via @Output
	by using @Output, the presentation component remains isolated from the 
	smart component via a cleanly defined interface.


presentation components

	pure or dumb components

	receives data via @Input
	does not know/care where the data comes from
	responsibility: purely present data to user and not fetch from any location


==> PROBLEM: custom events don't bubble up!

	If you have a deep tree of components and you want a component multiple levels
	above to know about the event, the event will not bubble.

		Let's say, we have several levels: the lesson list is inside a collapsible
		panel which is inside a tab panel.
		The lesson still wants to notify the home component that a lesson was 
		selected via the `lesson` event.  But the two components in the middle,
		TabPanel and CollapsiblePanel, are non application-specific Presentation
		Components (e.g. they are Angular Material lib components) - they do not
		know about the `lesson` event, so they cannot bubble it up.



Presentation Component
-----------------------

	import {Component, OnInit, Input, EventEmitter, Output} from '@angular/core';
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'lessons-list',
	  template: `
	      <table class="table lessons-list card card-strong">
	          <tbody>
	          <tr *ngFor="let lesson of lessons" (click)="selectLesson(lesson)">
	              <td class="lesson-title"> {{lesson.description}} </td>
	              <td class="duration">
	                  <i class="md-icon duration-icon">access_time</i>
	                  <span>{{lesson.duration}}</span>
	              </td>
	          </tr>
	          </tbody>
	      </table>  
	  `,
	  styleUrls: ['./lessons-list.component.css']
	})
	export class LessonsListComponent {

	  @Input()
	  lessons: Lesson[];

	  @Output('lesson')
	  lessonEmitter = new EventEmitter<Lesson>();

	    selectLesson(lesson:Lesson) {
	        this.lessonEmitter.emit(lesson);
	    }

	}
  

Smart Component
-------------------

Using @Output the presentation component remains isolated from the smart component via a clearly defined interface:

 - the lessons list presentation component only knows that it emitted an event, but does not know what are the receivers of the event or what will the receivers do in response to the event

 - the home screen smart component subscribes to the lesson custom event and reacts to the event, but it does not know what triggered the event. Did the user double click on the lessons list or did the user click a view button? This is transparent to the smart component.


	import { Component, OnInit } from '@angular/core';
	import {LessonsService} from "../shared/model/lessons.service";
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'app-home',
	  template: `
	      <h2>All Lessons</h2>
	      <h4>Total Lessons: {{lessons?.length}}</h4>

	      <div class="lessons-list-container v-h-center-block-parent">
	          <lessons-list [lessons]="lessons" (lesson)="selectLesson($event)"></lessons-list>
	      </div>
	`,
	  styleUrls: ['./home.component.css']
	})
	export class HomeComponent implements OnInit {

	    lessons: Lesson[];

	  constructor(private lessonsService: LessonsService) {
	  }

	  ngOnInit() {
	     ...
	  }

	  selectLesson(lesson) {
	    ...
	  }

	}


======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  


Example
-------

  Root Module

    app.module.ts

  Dashboard Module

    dashboard/
      dashboard-hero.component.ts
      dashboard.component.ts
      dashboard.module.ts
      dashboard-routing.module.ts


    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts  



  Dependency Injection with Modules
  ---------------------------------

Providers are injected differently than components and directives.

typically, when decorating a class with @Injectable and regisering as a Provider
in an NgModule, this class is created once and that one instance is shared amongst
the entire application.

When Angular bootstraps the root NgModule, all available imports in all NgModules
are registered at that time and made available to the whole application - they
are global.  This is why providers registered in a child NgModule are available
throughout the whole application.


Components and directives on the other hand are instantiated multiple times, 
once per instance in the markup. In addition, these items are scoped to the NgModule 
in which they are imported to prevent naming conflicts where two components 
might have the same selector for example. Because of this difference in 
dependency injection (DI) behavior, the need to differentiate an NgModule 
containing components and directives from a ModuleWithProviders containing components, 
directives, and providers is helpful which is where the forRoot() method 
makes that distinction.


There are times when all the application's NgModules are not available during
the bootstrap process -- Lazy Loading!

When lazy-loading an NgModule during routing, the providers registered in the
lazy-loaded NgModule and its children aren't available during the bootstrap 
process, and Angular is uanble to register them at that time.  Therefore, they
are added as providers only when the route is loaded and furthermore they are
scoped to be injected starting at the lazily-loaded NgModule and its children.

If there are multiple lazy-loaded NgModules attemtping to register the same
providers, each of these nodes of the NgModule tree end up with different 
instances.

By importing providers at the root, it helps ensure that all lazily-loaded 
NgModules get the same instance of the provider and is why forRoot() is named
as such.


  Lazy loading feature modules
  ----------------------------

Another advantage of using modules to group related pieces of functionality of our application is the ability to load those pieces on demand. Lazy loading modules helps us decrease the startup time. With lazy loading our application does not need to load everything at once, it only needs to load what the user expects to see when the app first loads. Modules that are lazily loaded will only be loaded when the user navigates to their routes.


https://angular-2-training-book.rangle.io/handout/modules/lazy-loading-module.html

Example


  application has only two paths: eager and lazy

    <nav>
      <a routerLink="eager">Eager</a>
      <a routerLink="lazy">Lazy</a>
    </nav>
    <router-outlet></router-outlet>

  routes:

    const routes: Routes = [
      { path: '', redirectTo: 'eager', pathMatch: 'full' },
      { path: 'eager', component: EagerComponent },
      { path: 'lazy', loadChildren: 'lazy/lazy.module#LazyModule' }
    ];  

NOTE:

  1. we use the property 'loadChildren' instead of 'component'
  2. we pass a string instead of symbol to avoid loading the module eagerly
  3. we define not only the path to the module, but the name of the class
     as well

There is nothing special about LazyModule other than it has its routing
and a component called LazyComponent.


  why does lazy loading create a child injector?
  -----------------------------------------------

angular adds @NgModule.providers to the application root injector,
unless the module is lazy loaded.

for a lazy-loaded module, angular creates a child injector and adds
the modules's providers to the child injector.

this means that a module behaves differently depending on whether
it's loaded during application start, or lazy loaded later.

why doesn't angular add lazy-loaded providers to the app root injector
as it does for eagerly loaded modules?

the answer is in a fundamental characteristic of the Angular DI
system.  An injector can add providers until it's first used.
Once an injector starts creating and delivering services, its provider
list is frozen; no new providers are allowed.

When an app starts, angular first configures the root injector with the
providers of all eagerly loaded modules BEFORE creating its first 
component and injecting any of the provided services.  Once the app
begins, the app root injector is closed to new providers.

Time passes and application logic triggers lazy loading of a module.
Angular must add the lazy-loaded module's providers to an injector
somewhere.  It can't add them to the root injector, so it creates a 
new child injector for the lazy loaded module context.



  sharing services from lazy-loaded modules
  ------------------------------------------

https://angular-2-training-book.rangle.io/handout/modules/feature-modules.html


While components, pipes and directives are scoped to its modules
unless explicitly exported, services are globally avialable
unless the module is lazy loaded.

when a module is lazy loaded, angular will create a child injector
(which is a child of the root injector from the root module) and will
create an instance of our service there.

Imagine we have a CreditCardModule that is configured to be lazy loaded.

If you provide CreditCardService as follows:

  @NgModule({
    imports: [],
    providers: [CreditCardService],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {}


When the app is bootstrapped and the root module is loaded into memory,
an instance of the CreditCardService (a singleton) is going to be added
to the root injector.  But when the CreditCardModule is LAZY loaded sometime
in the future, a child injector will be created for that module WITH A
NEW INSTANCE of the CreditCardService.  At this point, we have a
hierarchical injector with TWO instances of the same service, which is not
what we want.

So in order to have our feature's module's service ONLY added to the root
injector, we need to use a different approach:

  @NgModule({
    imports: [CommonModule],
    declarations: [
      CreditCardMaskPipe,
      CreditCardComponent
    ],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {
    static forRoot(): ModuleWithProviders {
      return {
        ngModule: CreditCardModule,
        providers: [CreditCardService]
      }
    }
  }

This time, we are defining a static method called 'forRoot' where
we define the module and the service we want to export.




  how can i tell if a module or service was previously loaded
  -----------------------------------------------------------
https://angular.io/guide/ngmodule-faq#how-can-i-tell-if-a-module-or-service-was-previously-loaded

some modules and their services should only be loaded once by the root
AppModule.  Importing the module a second time by lazy loading a module
could produce errant behavior that may be difficult to detect and diagnose.

To prevent, write a constructor that attempts to inject the module or service
from the root app injector.  If the injection succeeds, the class has been
loaded a second time. You can now throw an error or take other remedial 
action.

E.g. BrowserModule implements such a guard.


  constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
    if (parentModule) {
      throw new Error(
        'CoreModule is already loaded. Import it in the AppModule only');
    }
  }

  do NOT specify app-wide singleton providers in SharedModule
  -----------------------------------------------------------

  https://angular.io/guide/ngmodule-faq#why-is-it-bad-if-sharedmodule-provides-a-service-to-a-lazy-loaded-module

 it is important to keep providers out of the SharedModule.

 When the app starts, Angular eagerly loads the AppModule and potentially other early-loaded modules that use the SharedModule. No problem so far..

 But when a lazy-loaded module using SharedModule is loaded, it creates a child injector and registers all the providers available which would include any providers in the SharedModule if we had any.


  providers with SharedModules
  ---------------------------

when you write a shared module for your application, you typically want
all the services in that module shared only once.

if you just put the services in the 'providers' array of the SharedModule
NgModule() decorators, you might get weird cases, especially when 
lazy loading, when it feels like there's more than one instance of the 
service.

There is a better way to share providers in your SharedModules.

You also see 'SomeLibraryModule' being imported, and then exported with
'forRoot()'.

    export const providers = [
        // ... your shared services here
    ];

    @NgModule({
        declarations: [...],
        imports: [
            CommonModule, 
            SomeLibraryModule,
            ...],
        exports: [
            SomeLibraryModule.forRoot()
            ...
        ]
    })
    export class SharedModule {
        static forRoot() : ModuleWithProviders {
            return {
                ngModule: SharedModule,
                providers: [...providers]
            };
        }
    }


Shared services are listed in the 'static forRoot(): ModuleWithProviders {}' method of the SharedModule.

Then in your AppModule, there will be the only place where you add 
'SharedModule.forRoot()':

    @NgModule({
      declarations: [... ],
      imports: [
        BrowserModule,
        SharedModule.forRoot()
      ]
    })
    export class AppModule {}

In other application modules, you can add SharedModule to their
NgModule's 'imports'.

================================================================================

    NgModule forRoot() convention
    -----------------------------

https://angularfirst.com/the-ngmodule-forroot-convention/


The 'forRoot()' pattern/convention is very common in libraries, and
you'll see it in things like ngx-bootstrap.   The name isn't special to
the compiler, but it's a common pattern.

The most common example is the RouterModule:

  @NgModule({
    imports: [
      RouterModule.forRoot(routes)
    ],

The return type of the static forRoot() method is an object conforming to
the ModuleWithProviders interface:

  interface ModuleWithProviders { 
    ngModule: Type<any>
    providers: Provider[]
  }

Simply put, the forRoot() method returns an NgModule and its provider 
dependencies.  


Typically, when Angular bootstraps the root NgModule, all available imports
in all NgModules are registered at that time and made available to the whole
application - they are global.  This is why providers registered in a child
NgModule are available throughout the whole application.

There are times when all the application's NgModules are not available during the bootstrap process. Lazy-loading is such an example. When lazy-loading an NgModule during routing, the providers registered in the lazy-loaded NgModule and its children aren't available during the bootstrap process and Angular is unable to register them at that time. Therefore, they are added as providers only when the route is loaded and furthermore they are scoped to be injected starting at the lazily-loaded NgModule and its children. If there are multiple lazy-loaded NgModules attempting to register the same providers, each of these nodes of the NgModule tree end up with different instances. By importing the providers at the root, it helps ensure that all lazy-loaded NgModules get the same instance of the provider and is why forRoot() is named as such.



Take ngx-bootstrap as an example.
Notice how the ModalModule does not declare any providers in the @NgModule
decorator but does so in the static forRoot() method:

  @NgModule({
    declarations: [ModalBackdropComponent, ModalDirective],
    exports: [ModalBackdropComponent, ModalDirective],
    entryComponents: [ModalBackdropComponent]

      <-- no providers

  })
  export class ModalModule {

    public static forRoot(): ModuleWithProviders {
      return {
        ngModule: ModalModule, 
        providers: [   <-- providers
          ComponentLoaderFactory, PositioningService
        ]
      };
    }

  }

the forRoot() convention represents a way to import an NgModule along with
its providers using the `ModuleWithProviders` interface.

When a feature module exports components and directives that require sharing
the same custom provider instances, consider registering these providers in 
the `root` NgModule with a forRoot() method.

That will help ensure that all child NgModules have access to the same provider
instances.

================================================================================

  @Inject vs constructor injection
  ********************************

Should use @Inject only in situation where the injectable token is not a class.

Example:

  providers: [
    AuthService,
    { provide: Http, useValue: new CustomHttpImpl() }
  ]

Here we have two different providers, the AuthService and the CustomHttpImpl.
In the first case, the token is AuthService which means we can inject AuthService
using obviously AuthService type:

  constructor(private authService: AuthService) {}

With this constructor, Angular knows to look for AuthService with the token
`AuthService`.

In the second case, we provide CustomHttpImpl with the token `Http`. So we cannot
inject `CustomHttpImpl` - we need to inject Http:

  // error: no provider for CustomHttpImpl
  constructor(private http: CustomHttpImpl) {}

  // this will actually be the CustomHttpImpl, not Angular's Http
  constructor(private http: Http) {}


So you can tell from this that the tokens are all classes, which is enough for
Angular to figure out how to inject.

But let's say we have a String, or an Array of something we want to inject.
We cannot tie it to any class token - so we need to create an artificial token
like InjectionToken:

let config = '{ "some": "json", "config": "data" }'

export const CONFIG = new InjectionToken<Config>('Config');

Now we have a token we want to inject:

  providers: [
    { provide: CONFIG, useValue: config }
  ]

and when we inject, we @Inject(TOKEN)


  constructor(@Inject(CONFIG) config: string) {}



================================================================================

  injectable angular modules
  **************************

https://medium.com/@michelestieven/angular-writing-configurable-modules-69e6ea23ea42

A component could have a dependency on Classes, Values and Objects.

useClass
--------
  when you use a classname to specify a provider

    providers: [ MyService ]  

  it's interpreted like this:

    providers: [
      {
        provide: MyService,
        useClass: MyService
      }
    ]

  which means you could take a class, even a blank one, and exchange it with another

    class MyService {}
    class MyOtherService {}

    providers: [
      {
        provide: MyService,
        useClass: MyOtherService
      }
    ]

  useful for mocking services, you can use this to intro a new service keeping
  the old classname for compatibility reasons

useValue
---------

  useful when you don't want to provide a class but a value (object)

  let myObject = { greeting: 'Hello'} 

  providers: [
    {
      provide: 'MyService',
      useValue: myObject
    }
  ]

  @Component({...})
  export class AwesomeComponent {

    constructor(@Inject('MyService') myService) {
      console.log(myService.greeting);
    }
  }


useFactory
----------

  uses a factory (a simple function) and angular provides the return value of that
  function.  Useful when you want to do some checks or some operations before 
  knowing what to provide.

  let firstObject = { greeting: 'Hello World'};
  let secondObject = { greeting: 'Hello Earth'};

  providers: [
    {
      provide: 'MyService',
      useFactory: () => {
        if(...) return firstObject
        else return secondObject
      }
    }
  ]

  @Component
  export class AwesomeComp {
    constructor(@Inject('MyService') myService) {
      console.log(myService.greeting);
    }
  }


InjectionToken
---------------

  now we want to provide string names and classes that will be overritten.

  InjectionToken provides a name to us in the provide field, instead of using
  strings or classes.

  Since every instance of the InjectionToken is different, there are no 
  naming collisions:

    import { InjectionToken } from '@angular/core';
    import { MyInterface } from '...';

    const NewToken = new InjectionToken<MyInterface>('TOKEN');


Injectable Modules
******************

Suppose you have a library that provides the ability to pull different models
from a CMS.  The library will be in its own module.


1. the library will expose a static forRoot() method that will accept a 
configuration object

2. the configuration object will be an InjectionToken and useValue

3. the configuration object is defined by an interface


  // the service
  import { ContentfullService } from '...';

  // interface to define the configuration object
  interface ContentfulConfig {
    appId: string;
    appKey: string;
  }


  // InjectionToken
  const InjectedContentfulConfig = new InjectionToken<ContentfulConfig>('Config');


  @NgModule()
  export class ContentfulModule {

    static forRoot(config: ContentfulConfig): ModuleWithProviders {
      return {
        ngModule: ContentfulModule,
        providers: [
          ContentfulService,
          {
            provide: InjectedContentfulConfig,
            useValue: config
          }
        ]
      }
    }
  }

 -----------------------------------------

 Now, in the consuming application:


 const contentfulConfig: ContentfulConfig = {
  appId: 'cool-app',
  appKey: '94qera09fad09fads'
 }


 @NgModule({
  imports: [
    ...
    ContentfulModule.forRoot(contentfulConfig)
  ]
 })
 export class AppModule {}

and in a service where this config is needed:

  @Injectable()
  export class ContentfulService {
    private client;

    constructor(@Inject(ContentfulConfig) private  config)

  }



 Another example:
 ============================================

 library:

ng-brand-library-config.ts
---------------------------

import {BuildInfo} from './build-info';
import {InjectionToken} from '@angular/core';

export interface SfgNgBrandLibraryConfig {
  buildInfo: BuildInfo;
  env: string;
}

/**
 * This is an injection token to accept the config object seeded with values injected by the consuming app.
 */
export const InjectedLibraryConfiguration = new InjectionToken<NgBrandLibraryConfig>('NgBrandLibraryConfig');


ng-brand-library.module.ts
---------------------------

import {ModuleWithProviders, NgModule} from '@angular/core';
import {FooterComponent} from './footer/footer.component';
import {InjectedLibraryConfiguration, NgBrandLibraryConfig} from './model/ng-brand-library.config';
import {AuthenticationService} from './services/authentication.service';
import {NullComponent} from './pages/null/null.component';
import {CommonModule} from '@angular/common';
import {BsDropdownModule, ModalModule} from 'ngx-bootstrap';
import {NgIdleModule} from '@ng-idle/core';



@NgModule({
  providers: [ /* Do not add services here */ ],
  imports: [
    CommonModule,
    ModalModule.forRoot(),
    BsDropdownModule.forRoot(),
    NgIdleModule.forRoot()
  ],
  declarations: [
    NullComponent,
    FooterComponent
  ],
  entryComponents: [
    NullComponent
  ],
  exports: [
    FooterComponent
  ]
})
export class NgBrandLibraryModule {
  static forRoot(libraryConfig: NgBrandLibraryConfig): ModuleWithProviders {
    return {
      ngModule: NgBrandLibraryModule,
      providers: [
        // your library providers here
        {
          provide: InjectedLibraryConfiguration,
          useValue: libraryConfig
        },
        AuthenticationService,
      ]
    };
  }
}


In a library component:

footer.component.ts
--------------------

export class FooterComponent implements OnInit {

  public buildInfo: BuildInfo;

  constructor(
    @Inject(InjectedLibraryConfiguration) private libraryConfig
  ) {}

  ngOnInit() {
    this.buildInfo = this.libraryConfig.buildInfo; 
  }

}


In a consuming app's AppModule

app.module.ts
--------------

const ngBrandLibraryConfig: NgBrandLibraryConfig = {
  buildInfo: {
    timestamp: environment.buildTimestamp,
    version: environment.buildVersion
  },
  env: environment.env
};

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule,
    RouterModule.forRoot(appRoutes),
    ModalModule.forRoot(),
    NgBrandLibraryModule.forRoot(ngBrandLibraryConfig)
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

================================================================================

  HostBinding
  ***********

@Component({
  selector: 'some-component',
  . . .
})
export class SomeComponent implements NgOnInit {
  
  @HostBinding('attr.class') cssClass = 'row';

}

In the above example, the styling library provides a style class 'row'.

You could certainly configure that class on the tag name for this component:

  <some-component class="row"></some-component>

but it would be nice to be able to encapsulate the component configuration
within the component itsefl.

@HostBinding() decorator allows us to set properties on the 'host' element 
this component is attached to:

  <some-component>

class attribute with the value of 'row' in this example.

================================================================================

  Monorepo
  ********

Resources
----------

Misconceptions about Monorepos: Monorepo != Monolith
https://blog.nrwl.io/misconceptions-about-monorepos-monorepo-monolith-df1250d4b03c

Monorepo vs multirepo 
https://medium.com/@johnclarke_82232/mono-or-multi-repo-6c3674142dfc


Goals
-----------

Increase Visibility

  teams within organization are often unaware of changes that other teams
  are making.   


Reuse Code Directly

  traditional way to modularize and share code is to create a package.
  there is a large amount of overhead when making changes to these.

  versioning of various packages and staying current to update consuming 
  applications is a challenge.

  developer can work with the code directly.


Ensure Consistent Version of Dependencies

  Single version policy

  Organizations or business units can choose to have 

    - a single version of dependencies across all projects, or

    - to have a "latest-minus-X" policy to ensure all are up-to-date.




OSS projects vs Apps
--------------------

Ownership

  OSS projects owned by a single team.

  Apps in an Org are built by multiple teams


Variability

  OSS project is built for a single purpose by a single team.
  The team can agree on the choice of tools and tech.

  Apps are built by diff teams within an Org.




3 Reasons for creating Libs
---------------------------

  1. Code Sharing 

  2. Run tasks on less code 

  3. Organization




================================================================================

  Angular service interface
  *************************

https://medium.com/hackernoon/creating-interfaces-for-angular-services-1bb41fbbe47c


Interface
----------

import { Injectable } from '@angular/core';

export interface Todo {
  title: string;
  description: string;
  done: boolean;
}

@Injectable()
export abstract class TodoListService {
  /**
   * Returns a list of all of the current user's todos.
   */
  abstract getTodos(): Todo[];
}


Implementation 
---------------

import { Injectable } from '@angular/core';
import { Todo, TodoListService } from './todo-list.service';

@Injectable()
export class TodoListPublicService implements TodoListService {
  getTodos() {
    const todos: Todo[] = [
      {
        title: 'get groceries',
        description: 'eggs, milk, etc.',
        done: false
      }
    ];

    return todos;
  }
}


Another implementation
-----------------------

import { Injectable } from '@angular/core';
import { Todo, TodoListService } from './todo-list.service';

@Injectable()
export class TodoListPrivateService implements TodoListService {
  getTodos() {
    const todos: Todo[] = [
      {
        title: 'secret',
        description: 'All of my deepest, darkest secrets.',
        done: false
      }
    ];

    return todos;
  }
}


Using concrete implementation at component level
-------------------------------------------------

import { Component } from '@angular/core';
import { Todo, TodoListService } from './services/todo-list.service';
import { TodoListPublicService } from './services/todo-list-public.service';

@Component({
  selector: 'app-todo-list',
  template: `
    <div *ngFor="let todo of todos">
      <h3>{{ todo.title }}</h3>
      <p>{{ todo.description }}</p>
    </div>
  `,
  providers: [
    { provide: TodoListService, useClass: TodoListPublicService }
  ]
})
export class TodoListComponent {
  todos: Todo[];

  constructor(private todoListService: TodoListService) {}

  ngOnInit() {
    this.todos = this.todoListService.getTodos();
  }
}


  
Another option:

Injecting service implementation at Module level
------------------------------------------------

@NgModule({
  declarations: [

  ],
  imports: [
    TodoServideModule.forRoot(TodoListPublicService),
  ],
  providers: [
    TodoListPublicService
  ],
================================================================================

  Never function calls in Templates
  *********************************

  https://medium.com/showpad-engineering/why-you-should-never-use-function-calls-in-angular-template-expressions-e1a50f9c0496

property bindings

    <ng-container *ngIf="isLoggedIn">
      <h1>Welcome {{ fullName }}!</h1>
    </ng-container>

but we can also do function calls

  <ng-container *ngIf="isLoggedIn">
    <h1>Welcome {{ fullName }}!</h1>
    <a href="files" *ngIf="hasAccessTo('files')">Files</a>
    <a href="photos" *ngIf="hasAccessTo('photos')">Photos</a>
  </ng-container>



Problem - function calls will be made EVERY TIME Angular change detection runs

Depending on the logic inside the function, running a function hundreds of times can become a serious performance issue.
This becomes painfully hidden in templates when getters are used:


  @Component({
    template: `
      <p>Welcome {{ fullName }}!</p>
  `
  })
  export class PersonComponent {
    @Input() person: { firstName: string, lastName: string };
    constructor() { }
    get fullName() {
      return this.person.firstName + ' ' + this.person.lastName
    }
  }

ChangeDetectionStrategy.OnPush
-------------------------------

  @Component({
    template: `
      <p>Welcome {{ fullName() }}!</p>
      <div (mousemove)="onMouseMove()">Drop a picture here</div>
  `
    changeDetection: ChangeDetectionStrategy.OnPush
  })
  export class PersonComponent {
    @Input() person: { firstName: string, lastName: string };
    constructor() { }
    fullName() {
      return this.person.firstName + ' ' + this.person.lastName
    }
    onMouseMove() {
      console.log('Mouse was moved');
    }
  }

the fullName() function inside PersonComponent is no longer executed when the button outside of PersonComponent is clicked.

but is still executed every time change detection is initiated inside the PersonComponent itself


Solutions:


Option 1 - Pure Pipes


By telling Angular that a pipe is pure, Angular knows that the pipe’s return value does not change if the pipe’s input does not change.

Create a pure pipe:


  import { Pipe, PipeTransform } from '@angular/core';
  @Pipe({
    name: 'fullName',
    pure: true
  })
  export class FullNamePipe implements PipeTransform {
    transform(person: any, args?: any): any {
      return person.firstName + ' ' + person.lastName;
    }
  }

A pipe in Angular is pure by default, so we can skip the pure: true part in the pipe decorator...

Consume the pipe 

  @NgModule({
    declarations: [ AppComponent, PersonComponent, FullNamePipe ]
  })
  export class AppModule { }

and in the template:


  @Component({
    template: `
      <p>Welcome {{ person | fullName }}!</p>
      <div (mousemove)="onMouseMove()">Drop a picture here</div>
  `
    changeDetection: ChangeDetectionStrategy.OnPush
  })
  export class PersonComponent implements OnChanges {
  @Input() person: { firstName: string, lastName: string };
  constructor() { }
  onMouseMove() {
      console.log('Mouse was moved');
    }
  }

Angular is now smart enough to know that the expression 

  {{ person | fullName }} 

does not change if the person does not change.

But what if our logic is more complex and cannot be handled by a pipe?



Option 2 - Manually calculate the values


    ngOnChanges(changes: SimpleChanges) {
      if (changes.person) {
        this.fullName = this.calculateFullName();
      }
    }


we use a simple property  {{ fullName }}
rather than the function call  {{ fullName() }}

fullName property is recalculated only when the component's 
`person` input changes.


  @Component({
    template: `
      <p>Welcome {{ fullName }}!</p>
      <div (mousemove)="onMouseMove()">Drop a picture here</div>
  `
    changeDetection: ChangeDetectionStrategy.OnPush
  })
  export class PersonComponent implements OnChanges {
    @Input() person: { firstName: string, lastName: string };
    fullName = '';
    constructor() { }
    ngOnChanges(changes: SimpleChanges) {
      if (changes.person) {
        this.fullName = this.calculateFullName();
      }
    }
    calculateFullName() {  
      return this.person.firstName + ' ' + this.person.lastName;
    }
    onMouseMove() {
      console.log('Mouse was moved');
    }
  }


================================================================================


  Angular Route Resolver
  **********************


https://www.digitalocean.com/community/tutorials/angular-route-resolvers

Generate resolver:

./node_modules/@angular/cli/bin/ng generate resolver news


implementation:

  must have resolve() method


  @Injectable({
    providedIn: 'root'
  })
  export class NewsResolver implements Resolve<Observable<string>> {
    resolve(): Observable<string> {
      return of('Route!').pipe(delay(2000));
    }
  }

  whatever is returned from that method will be the resolved data.
  this examples returns an Observable that wraps a string after a delay of 2 seconds.

set up routing
app-routing.module.ts

  { path: 'news', component: NewsComponent, resolve: {message: NewsResolver}},


To access the resolved data in the component

  whatever property you have configured in your routing - "message" in this case

you can access in your component via

  {{ data.message }}

if you change to   resolve: {newsData: NewsResolver}, then you'll need to access via

  {{ data.newsData}}

Dealing with Errors in the Resolver
-----------------------------------

One option: catch and deal with the error in the resolver using RxJS  catchError()

  resolve(): Observable<any> {
    return this.newsService.getTopPosts().pipe(catchError(() => {
      return of('data not available at this time');
    }));
  }

Or, you could return EMPTY

  resolve(): Observable<any> {
    return this.newsService.getTopPosts().pipe(catchError(() => {
      this.router.navigate(['/']);
      return EMPTY;
    }));
  }

In case there's an error retrieving data from the API.



================================================================================