
	*****************************

		Angular Architecture

	*****************************


================================================================================

	View Layer Architecture
	************************

https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/


Smart Components vs Presentation Components
*******************************************

smart components

	app-level components, or controller components
	very tied to this particular application
	it would be hard to reuse it in another app

	knows where data comes from, or what type of data there is .. 
	does not know how to present data to the user

	receives application-specific dependencies via constructor, e.g. LessonService.
	injects data to the presentation component via @Input, and 
	receives any actions that the presentation component might trigger via @Output
	by using @Output, the presentation component remains isolated from the 
	smart component via a cleanly defined interface.


presentation components

	pure or dumb components

	receives data via @Input
	does not know/care where the data comes from
	responsibility: purely present data to user and not fetch from any location


==> PROBLEM: custom events don't bubble up!

	If you have a deep tree of components and you want a component multiple levels
	above to know about the event, the event will not bubble.

		Let's say, we have several levels: the lesson list is inside a collapsible
		panel which is inside a tab panel.
		The lesson still wants to notify the home component that a lesson was 
		selected via the `lesson` event.  But the two components in the middle,
		TabPanel and CollapsiblePanel, are non application-specific Presentation
		Components (e.g. they are Angular Material lib components) - they do not
		know about the `lesson` event, so they cannot bubble it up.



Presentation Component
-----------------------

	import {Component, OnInit, Input, EventEmitter, Output} from '@angular/core';
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'lessons-list',
	  template: `
	      <table class="table lessons-list card card-strong">
	          <tbody>
	          <tr *ngFor="let lesson of lessons" (click)="selectLesson(lesson)">
	              <td class="lesson-title"> {{lesson.description}} </td>
	              <td class="duration">
	                  <i class="md-icon duration-icon">access_time</i>
	                  <span>{{lesson.duration}}</span>
	              </td>
	          </tr>
	          </tbody>
	      </table>  
	  `,
	  styleUrls: ['./lessons-list.component.css']
	})
	export class LessonsListComponent {

	  @Input()
	  lessons: Lesson[];

	  @Output('lesson')
	  lessonEmitter = new EventEmitter<Lesson>();

	    selectLesson(lesson:Lesson) {
	        this.lessonEmitter.emit(lesson);
	    }

	}
  

Smart Component
-------------------

Using @Output the presentation component remains isolated from the smart component via a clearly defined interface:

 - the lessons list presentation component only knows that it emitted an event, but does not know what are the receivers of the event or what will the receivers do in response to the event

 - the home screen smart component subscribes to the lesson custom event and reacts to the event, but it does not know what triggered the event. Did the user double click on the lessons list or did the user click a view button? This is transparent to the smart component.


	import { Component, OnInit } from '@angular/core';
	import {LessonsService} from "../shared/model/lessons.service";
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'app-home',
	  template: `
	      <h2>All Lessons</h2>
	      <h4>Total Lessons: {{lessons?.length}}</h4>

	      <div class="lessons-list-container v-h-center-block-parent">
	          <lessons-list [lessons]="lessons" (lesson)="selectLesson($event)"></lessons-list>
	      </div>
	`,
	  styleUrls: ['./home.component.css']
	})
	export class HomeComponent implements OnInit {

	    lessons: Lesson[];

	  constructor(private lessonsService: LessonsService) {
	  }

	  ngOnInit() {
	     ...
	  }

	  selectLesson(lesson) {
	    ...
	  }

	}


======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  


Example
-------

  Root Module

    app.module.ts

  Dashboard Module

    dashboard/
      dashboard-hero.component.ts
      dashboard.component.ts
      dashboard.module.ts
      dashboard-routing.module.ts


    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts  



  Dependency Injection with Modules
  ---------------------------------

Providers are injected differently than components and directives.

typically, when decorating a class with @Injectable and regisering as a Provider
in an NgModule, this class is created once and that one instance is shared amongst
the entire application.

When Angular bootstraps the root NgModule, all available imports in all NgModules
are registered at that time and made available to the whole application - they
are global.  This is why providers registered in a child NgModule are available
throughout the whole application.


Components and directives on the other hand are instantiated multiple times, 
once per instance in the markup. In addition, these items are scoped to the NgModule 
in which they are imported to prevent naming conflicts where two components 
might have the same selector for example. Because of this difference in 
dependency injection (DI) behavior, the need to differentiate an NgModule 
containing components and directives from a ModuleWithProviders containing components, 
directives, and providers is helpful which is where the forRoot() method 
makes that distinction.


There are times when all the application's NgModules are not available during
the bootstrap process -- Lazy Loading!

When lazy-loading an NgModule during routing, the providers registered in the
lazy-loaded NgModule and its children aren't available during the bootstrap 
process, and Angular is uanble to register them at that time.  Therefore, they
are added as providers only when the route is loaded and furthermore they are
scoped to be injected starting at the lazily-loaded NgModule and its children.

If there are multiple lazy-loaded NgModules attemtping to register the same
providers, each of these nodes of the NgModule tree end up with different 
instances.

By importing providers at the root, it helps ensure that all lazily-loaded 
NgModules get the same instance of the provider and is why forRoot() is named
as such.


  Lazy loading feature modules
  ----------------------------

Another advantage of using modules to group related pieces of functionality of our application is the ability to load those pieces on demand. Lazy loading modules helps us decrease the startup time. With lazy loading our application does not need to load everything at once, it only needs to load what the user expects to see when the app first loads. Modules that are lazily loaded will only be loaded when the user navigates to their routes.


https://angular-2-training-book.rangle.io/handout/modules/lazy-loading-module.html

Example


  application has only two paths: eager and lazy

    <nav>
      <a routerLink="eager">Eager</a>
      <a routerLink="lazy">Lazy</a>
    </nav>
    <router-outlet></router-outlet>

  routes:

    const routes: Routes = [
      { path: '', redirectTo: 'eager', pathMatch: 'full' },
      { path: 'eager', component: EagerComponent },
      { path: 'lazy', loadChildren: 'lazy/lazy.module#LazyModule' }
    ];  

NOTE:

  1. we use the property 'loadChildren' instead of 'component'
  2. we pass a string instead of symbol to avoid loading the module eagerly
  3. we define not only the path to the module, but the name of the class
     as well

There is nothing special about LazyModule other than it has its routing
and a component called LazyComponent.


  why does lazy loading create a child injector?
  -----------------------------------------------

angular adds @NgModule.providers to the application root injector,
unless the module is lazy loaded.

for a lazy-loaded module, angular creates a child injector and adds
the modules's providers to the child injector.

this means that a module behaves differently depending on whether
it's loaded during application start, or lazy loaded later.

why doesn't angular add lazy-loaded providers to the app root injector
as it does for eagerly loaded modules?

the answer is in a fundamental characteristic of the Angular DI
system.  An injector can add providers until it's first used.
Once an injector starts creating and delivering services, its provider
list is frozen; no new providers are allowed.

When an app starts, angular first configures the root injector with the
providers of all eagerly loaded modules BEFORE creating its first 
component and injecting any of the provided services.  Once the app
begins, the app root injector is closed to new providers.

Time passes and application logic triggers lazy loading of a module.
Angular must add the lazy-loaded module's providers to an injector
somewhere.  It can't add them to the root injector, so it creates a 
new child injector for the lazy loaded module context.



  sharing services from lazy-loaded modules
  ------------------------------------------

https://angular-2-training-book.rangle.io/handout/modules/feature-modules.html


While components, pipes and directives are scoped to its modules
unless explicitly exported, services are globally avialable
unless the module is lazy loaded.

when a module is lazy loaded, angular will create a child injector
(which is a child of the root injector from the root module) and will
create an instance of our service there.

Imagine we have a CreditCardModule that is configured to be lazy loaded.

If you provide CreditCardService as follows:

  @NgModule({
    imports: [],
    providers: [CreditCardService],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {}


When the app is bootstrapped and the root module is loaded into memory,
an instance of the CreditCardService (a singleton) is going to be added
to the root injector.  But when the CreditCardModule is LAZY loaded sometime
in the future, a child injector will be created for that module WITH A
NEW INSTANCE of the CreditCardService.  At this point, we have a
hierarchical injector with TWO instances of the same service, which is not
what we want.

So in order to have our feature's module's service ONLY added to the root
injector, we need to use a different approach:

  @NgModule({
    imports: [CommonModule],
    declarations: [
      CreditCardMaskPipe,
      CreditCardComponent
    ],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {
    static forRoot(): ModuleWithProviders {
      return {
        ngModule: CreditCardModule,
        providers: [CreditCardService]
      }
    }
  }

This time, we are defining a static method called 'forRoot' where
we define the module and the service we want to export.




  how can i tell if a module or service was previously loaded
  -----------------------------------------------------------
https://angular.io/guide/ngmodule-faq#how-can-i-tell-if-a-module-or-service-was-previously-loaded

some modules and their services should only be loaded once by the root
AppModule.  Importing the module a second time by lazy loading a module
could produce errant behavior that may be difficult to detect and diagnose.

To prevent, write a constructor that attempts to inject the module or service
from the root app injector.  If the injection succeeds, the class has been
loaded a second time. You can now throw an error or take other remedial 
action.

E.g. BrowserModule implements such a guard.


  constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
    if (parentModule) {
      throw new Error(
        'CoreModule is already loaded. Import it in the AppModule only');
    }
  }

  do NOT specify app-wide singleton providers in SharedModule
  -----------------------------------------------------------

  https://angular.io/guide/ngmodule-faq#why-is-it-bad-if-sharedmodule-provides-a-service-to-a-lazy-loaded-module

 it is important to keep providers out of the SharedModule.

 When the app starts, Angular eagerly loads the AppModule and potentially other early-loaded modules that use the SharedModule. No problem so far..

 But when a lazy-loaded module using SharedModule is loaded, it creates a child injector and registers all the providers available which would include any providers in the SharedModule if we had any.


  providers with SharedModules
  ---------------------------

when you write a shared module for your application, you typically want
all the services in that module shared only once.

if you just put the services in the 'providers' array of the SharedModule
NgModule() decorators, you might get weird cases, especially when 
lazy loading, when it feels like there's more than one instance of the 
service.

There is a better way to share providers in your SharedModules.

You also see 'SomeLibraryModule' being imported, and then exported with
'forRoot()'.

    export const providers = [
        // ... your shared services here
    ];

    @NgModule({
        declarations: [...],
        imports: [
            CommonModule, 
            SomeLibraryModule,
            ...],
        exports: [
            SomeLibraryModule.forRoot()
            ...
        ]
    })
    export class SharedModule {
        static forRoot() : ModuleWithProviders {
            return {
                ngModule: SharedModule,
                providers: [...providers]
            };
        }
    }


Shared services are listed in the 'static forRoot(): ModuleWithProviders {}' method of the SharedModule.

Then in your AppModule, there will be the only place where you add 
'SharedModule.forRoot()':

    @NgModule({
      declarations: [... ],
      imports: [
        BrowserModule,
        SharedModule.forRoot()
      ]
    })
    export class AppModule {}

In other application modules, you can add SharedModule to their
NgModule's 'imports'.

================================================================================

    NgModule forRoot() convention
    -----------------------------

https://angularfirst.com/the-ngmodule-forroot-convention/


The 'forRoot()' pattern/convention is very common in libraries, and
you'll see it in things like ngx-bootstrap.   The name isn't special to
the compiler, but it's a common pattern.

The most common example is the RouterModule:

  @NgModule({
    imports: [
      RouterModule.forRoot(routes)
    ],

The return type of the static forRoot() method is an object conforming to
the ModuleWithProviders interface:

  interface ModuleWithProviders { 
    ngModule: Type<any>
    providers: Provider[]
  }

Simply put, the forRoot() method returns an NgModule and its provider 
dependencies.  


Typically, when Angular bootstraps the root NgModule, all available imports
in all NgModules are registered at that time and made available to the whole
application - they are global.  This is why providers registered in a child
NgModule are available throughout the whole application.

There are times when all the application's NgModules are not available during the bootstrap process. Lazy-loading is such an example. When lazy-loading an NgModule during routing, the providers registered in the lazy-loaded NgModule and its children aren't available during the bootstrap process and Angular is unable to register them at that time. Therefore, they are added as providers only when the route is loaded and furthermore they are scoped to be injected starting at the lazily-loaded NgModule and its children. If there are multiple lazy-loaded NgModules attempting to register the same providers, each of these nodes of the NgModule tree end up with different instances. By importing the providers at the root, it helps ensure that all lazy-loaded NgModules get the same instance of the provider and is why forRoot() is named as such.



Take ngx-bootstrap as an example.
Notice how the ModalModule does not declare any providers in the @NgModule
decorator but does so in the static forRoot() method:

  @NgModule({
    declarations: [ModalBackdropComponent, ModalDirective],
    exports: [ModalBackdropComponent, ModalDirective],
    entryComponents: [ModalBackdropComponent]

      <-- no providers

  })
  export class ModalModule {

    public static forRoot(): ModuleWithProviders {
      return {
        ngModule: ModalModule, 
        providers: [   <-- providers
          ComponentLoaderFactory, PositioningService
        ]
      };
    }

  }

the forRoot() convention represents a way to import an NgModule along with
its providers using the `ModuleWithProviders` interface.

When a feature module exports components and directives that require sharing
the same custom provider instances, consider registering these providers in 
the `root` NgModule with a forRoot() method.

That will help ensure that all child NgModules have access to the same provider
instances.

================================================================================