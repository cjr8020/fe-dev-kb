
	*****************************

		Angular Architecture

	*****************************


================================================================================

  Component

  @Input
  @output


Parent and Child components can communicate with each other via Inputs and
Outputs.

This is how parent (app.component) could use a chiild component (product-list.component)
to display a list of components and accept an input (products) and emit an 
output ($event)

<product-list
  
    @Input  <---------- coming from parent property "products"

  [procuctList]="products"


    @Output ----------> $event going out to parent method productWasSelected()


  (onProductSelected)="productWasSelected($event)">

</products-list>


using built-in events
--------------------------------------

@Component({
  selector: 'button-clicked',
  template: `
    {{ value }}
    <button (click)="increase()">Increase</button>
    <button (click)="decrease()">Decrease</button>
  `
})
export class ButtonClickedComponent {
  value: number;

  constructor() {
    this.value = 1;
  }

  increase(): number {
    this.value = this.value + 1;
    return this.value;
  }

  decrease(): number {
    this.value = this.value -1;
    return this.value;
  }
}


To emit a custom event
--------------------------------------

Custom event emitter component:

  @Component({
    selector: 'custom-event',
    template: `
      <button (click)="liked()">Like it?</button>
    `
  })
  export class CustomEventComponent {
    @Output() meLikey: EventEmitter<string>;

    constructor() {
      this.meLikey = new EventEmitter<string>();
    }

    liked(): void {
      this.meLikey.emit('i like it a lot');
    }
  }

Parent comp consuming the event emitted by its child:


<div>
  <custom-event
    (meLikey)="somebodyLikedSomething($event)"
    ></custom-event>
</div>


  somebodyLikedSomething(message: string) {
    console.log(`ok say it: ${message}`);
  }




================================================================================

	View Layer Architecture
	************************

https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/


Smart Components vs Presentation Components
*******************************************

smart components

	app-level components, or controller components
	very tied to this particular application
	it would be hard to reuse it in another app

	knows where data comes from, or what type of data there is .. 
	does not know how to present data to the user

	receives application-specific dependencies via constructor, e.g. LessonService.
	injects data to the presentation component via @Input, and 
	receives any actions that the presentation component might trigger via @Output
	by using @Output, the presentation component remains isolated from the 
	smart component via a cleanly defined interface.


presentation components

	pure or dumb components

	receives data via @Input
	does not know/care where the data comes from
	responsibility: purely present data to user and not fetch from any location


==> PROBLEM: custom events don't bubble up!

	If you have a deep tree of components and you want a component multiple levels
	above to know about the event, the event will not bubble.

		Let's say, we have several levels: the lesson list is inside a collapsible
		panel which is inside a tab panel.
		The lesson still wants to notify the home component that a lesson was 
		selected via the `lesson` event.  But the two components in the middle,
		TabPanel and CollapsiblePanel, are non application-specific Presentation
		Components (e.g. they are Angular Material lib components) - they do not
		know about the `lesson` event, so they cannot bubble it up.



Presentation Component
-----------------------

	import {Component, OnInit, Input, EventEmitter, Output} from '@angular/core';
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'lessons-list',
	  template: `
	      <table class="table lessons-list card card-strong">
	          <tbody>
	          <tr *ngFor="let lesson of lessons" (click)="selectLesson(lesson)">
	              <td class="lesson-title"> {{lesson.description}} </td>
	              <td class="duration">
	                  <i class="md-icon duration-icon">access_time</i>
	                  <span>{{lesson.duration}}</span>
	              </td>
	          </tr>
	          </tbody>
	      </table>  
	  `,
	  styleUrls: ['./lessons-list.component.css']
	})
	export class LessonsListComponent {

	  @Input()
	  lessons: Lesson[];

	  @Output('lesson')
	  lessonEmitter = new EventEmitter<Lesson>();

	    selectLesson(lesson:Lesson) {
	        this.lessonEmitter.emit(lesson);
	    }

	}
  

Smart Component
-------------------

Using @Output the presentation component remains isolated from the smart component via a clearly defined interface:

 - the lessons list presentation component only knows that it emitted an event, but does not know what are the receivers of the event or what will the receivers do in response to the event

 - the home screen smart component subscribes to the lesson custom event and reacts to the event, but it does not know what triggered the event. Did the user double click on the lessons list or did the user click a view button? This is transparent to the smart component.


	import { Component, OnInit } from '@angular/core';
	import {LessonsService} from "../shared/model/lessons.service";
	import {Lesson} from "../shared/model/lesson";

	@Component({
	  selector: 'app-home',
	  template: `
	      <h2>All Lessons</h2>
	      <h4>Total Lessons: {{lessons?.length}}</h4>

	      <div class="lessons-list-container v-h-center-block-parent">
	          <lessons-list [lessons]="lessons" (lesson)="selectLesson($event)"></lessons-list>
	      </div>
	`,
	  styleUrls: ['./home.component.css']
	})
	export class HomeComponent implements OnInit {

	    lessons: Lesson[];

	  constructor(private lessonsService: LessonsService) {
	  }

	  ngOnInit() {
	     ...
	  }

	  selectLesson(lesson) {
	    ...
	  }

	}


======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  


Example
-------

  Root Module

    app.module.ts

  Dashboard Module

    dashboard/
      dashboard-hero.component.ts
      dashboard.component.ts
      dashboard.module.ts
      dashboard-routing.module.ts


    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts  



  Dependency Injection with Modules
  ---------------------------------

Providers are injected differently than components and directives.

typically, when decorating a class with @Injectable and regisering as a Provider
in an NgModule, this class is created once and that one instance is shared amongst
the entire application.

When Angular bootstraps the root NgModule, all available imports in all NgModules
are registered at that time and made available to the whole application - they
are global.  This is why providers registered in a child NgModule are available
throughout the whole application.


Components and directives on the other hand are instantiated multiple times, 
once per instance in the markup. In addition, these items are scoped to the NgModule 
in which they are imported to prevent naming conflicts where two components 
might have the same selector for example. Because of this difference in 
dependency injection (DI) behavior, the need to differentiate an NgModule 
containing components and directives from a ModuleWithProviders containing components, 
directives, and providers is helpful which is where the forRoot() method 
makes that distinction.


There are times when all the application's NgModules are not available during
the bootstrap process -- Lazy Loading!

When lazy-loading an NgModule during routing, the providers registered in the
lazy-loaded NgModule and its children aren't available during the bootstrap 
process, and Angular is uanble to register them at that time.  Therefore, they
are added as providers only when the route is loaded and furthermore they are
scoped to be injected starting at the lazily-loaded NgModule and its children.

If there are multiple lazy-loaded NgModules attemtping to register the same
providers, each of these nodes of the NgModule tree end up with different 
instances.

By importing providers at the root, it helps ensure that all lazily-loaded 
NgModules get the same instance of the provider and is why forRoot() is named
as such.


  Lazy loading feature modules
  ----------------------------

Another advantage of using modules to group related pieces of functionality of our application is the ability to load those pieces on demand. Lazy loading modules helps us decrease the startup time. With lazy loading our application does not need to load everything at once, it only needs to load what the user expects to see when the app first loads. Modules that are lazily loaded will only be loaded when the user navigates to their routes.


https://angular-2-training-book.rangle.io/handout/modules/lazy-loading-module.html

Example


  application has only two paths: eager and lazy

    <nav>
      <a routerLink="eager">Eager</a>
      <a routerLink="lazy">Lazy</a>
    </nav>
    <router-outlet></router-outlet>

  routes:

    const routes: Routes = [
      { path: '', redirectTo: 'eager', pathMatch: 'full' },
      { path: 'eager', component: EagerComponent },
      { path: 'lazy', loadChildren: 'lazy/lazy.module#LazyModule' }
    ];  

NOTE:

  1. we use the property 'loadChildren' instead of 'component'
  2. we pass a string instead of symbol to avoid loading the module eagerly
  3. we define not only the path to the module, but the name of the class
     as well

There is nothing special about LazyModule other than it has its routing
and a component called LazyComponent.


  why does lazy loading create a child injector?
  -----------------------------------------------

angular adds @NgModule.providers to the application root injector,
unless the module is lazy loaded.

for a lazy-loaded module, angular creates a child injector and adds
the modules's providers to the child injector.

this means that a module behaves differently depending on whether
it's loaded during application start, or lazy loaded later.

why doesn't angular add lazy-loaded providers to the app root injector
as it does for eagerly loaded modules?

the answer is in a fundamental characteristic of the Angular DI
system.  An injector can add providers until it's first used.
Once an injector starts creating and delivering services, its provider
list is frozen; no new providers are allowed.

When an app starts, angular first configures the root injector with the
providers of all eagerly loaded modules BEFORE creating its first 
component and injecting any of the provided services.  Once the app
begins, the app root injector is closed to new providers.

Time passes and application logic triggers lazy loading of a module.
Angular must add the lazy-loaded module's providers to an injector
somewhere.  It can't add them to the root injector, so it creates a 
new child injector for the lazy loaded module context.



  sharing services from lazy-loaded modules
  ------------------------------------------

https://angular-2-training-book.rangle.io/handout/modules/feature-modules.html


While components, pipes and directives are scoped to its modules
unless explicitly exported, services are globally avialable
unless the module is lazy loaded.

when a module is lazy loaded, angular will create a child injector
(which is a child of the root injector from the root module) and will
create an instance of our service there.

Imagine we have a CreditCardModule that is configured to be lazy loaded.

If you provide CreditCardService as follows:

  @NgModule({
    imports: [],
    providers: [CreditCardService],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {}


When the app is bootstrapped and the root module is loaded into memory,
an instance of the CreditCardService (a singleton) is going to be added
to the root injector.  But when the CreditCardModule is LAZY loaded sometime
in the future, a child injector will be created for that module WITH A
NEW INSTANCE of the CreditCardService.  At this point, we have a
hierarchical injector with TWO instances of the same service, which is not
what we want.

So in order to have our feature's module's service ONLY added to the root
injector, we need to use a different approach:

  @NgModule({
    imports: [CommonModule],
    declarations: [
      CreditCardMaskPipe,
      CreditCardComponent
    ],
    exports: [CreditCardComponent]
  })
  export class CreditCardModule {
    static forRoot(): ModuleWithProviders {
      return {
        ngModule: CreditCardModule,
        providers: [CreditCardService]
      }
    }
  }

This time, we are defining a static method called 'forRoot' where
we define the module and the service we want to export.




  how can i tell if a module or service was previously loaded
  -----------------------------------------------------------
https://angular.io/guide/ngmodule-faq#how-can-i-tell-if-a-module-or-service-was-previously-loaded

some modules and their services should only be loaded once by the root
AppModule.  Importing the module a second time by lazy loading a module
could produce errant behavior that may be difficult to detect and diagnose.

To prevent, write a constructor that attempts to inject the module or service
from the root app injector.  If the injection succeeds, the class has been
loaded a second time. You can now throw an error or take other remedial 
action.

E.g. BrowserModule implements such a guard.


  constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
    if (parentModule) {
      throw new Error(
        'CoreModule is already loaded. Import it in the AppModule only');
    }
  }

  do NOT specify app-wide singleton providers in SharedModule
  -----------------------------------------------------------

  https://angular.io/guide/ngmodule-faq#why-is-it-bad-if-sharedmodule-provides-a-service-to-a-lazy-loaded-module

 it is important to keep providers out of the SharedModule.

 When the app starts, Angular eagerly loads the AppModule and potentially other early-loaded modules that use the SharedModule. No problem so far..

 But when a lazy-loaded module using SharedModule is loaded, it creates a child injector and registers all the providers available which would include any providers in the SharedModule if we had any.


  providers with SharedModules
  ---------------------------

when you write a shared module for your application, you typically want
all the services in that module shared only once.

if you just put the services in the 'providers' array of the SharedModule
NgModule() decorators, you might get weird cases, especially when 
lazy loading, when it feels like there's more than one instance of the 
service.

There is a better way to share providers in your SharedModules.

You also see 'SomeLibraryModule' being imported, and then exported with
'forRoot()'.

    export const providers = [
        // ... your shared services here
    ];

    @NgModule({
        declarations: [...],
        imports: [
            CommonModule, 
            SomeLibraryModule,
            ...],
        exports: [
            SomeLibraryModule.forRoot()
            ...
        ]
    })
    export class SharedModule {
        static forRoot() : ModuleWithProviders {
            return {
                ngModule: SharedModule,
                providers: [...providers]
            };
        }
    }


Shared services are listed in the 'static forRoot(): ModuleWithProviders {}' method of the SharedModule.

Then in your AppModule, there will be the only place where you add 
'SharedModule.forRoot()':

    @NgModule({
      declarations: [... ],
      imports: [
        BrowserModule,
        SharedModule.forRoot()
      ]
    })
    export class AppModule {}

In other application modules, you can add SharedModule to their
NgModule's 'imports'.

================================================================================

    NgModule forRoot() convention
    -----------------------------

https://angularfirst.com/the-ngmodule-forroot-convention/


The 'forRoot()' pattern/convention is very common in libraries, and
you'll see it in things like ngx-bootstrap.   The name isn't special to
the compiler, but it's a common pattern.

The most common example is the RouterModule:

  @NgModule({
    imports: [
      RouterModule.forRoot(routes)
    ],

The return type of the static forRoot() method is an object conforming to
the ModuleWithProviders interface:

  interface ModuleWithProviders { 
    ngModule: Type<any>
    providers: Provider[]
  }

Simply put, the forRoot() method returns an NgModule and its provider 
dependencies.  


Typically, when Angular bootstraps the root NgModule, all available imports
in all NgModules are registered at that time and made available to the whole
application - they are global.  This is why providers registered in a child
NgModule are available throughout the whole application.

There are times when all the application's NgModules are not available during the bootstrap process. Lazy-loading is such an example. When lazy-loading an NgModule during routing, the providers registered in the lazy-loaded NgModule and its children aren't available during the bootstrap process and Angular is unable to register them at that time. Therefore, they are added as providers only when the route is loaded and furthermore they are scoped to be injected starting at the lazily-loaded NgModule and its children. If there are multiple lazy-loaded NgModules attempting to register the same providers, each of these nodes of the NgModule tree end up with different instances. By importing the providers at the root, it helps ensure that all lazy-loaded NgModules get the same instance of the provider and is why forRoot() is named as such.



Take ngx-bootstrap as an example.
Notice how the ModalModule does not declare any providers in the @NgModule
decorator but does so in the static forRoot() method:

  @NgModule({
    declarations: [ModalBackdropComponent, ModalDirective],
    exports: [ModalBackdropComponent, ModalDirective],
    entryComponents: [ModalBackdropComponent]

      <-- no providers

  })
  export class ModalModule {

    public static forRoot(): ModuleWithProviders {
      return {
        ngModule: ModalModule, 
        providers: [   <-- providers
          ComponentLoaderFactory, PositioningService
        ]
      };
    }

  }

the forRoot() convention represents a way to import an NgModule along with
its providers using the `ModuleWithProviders` interface.

When a feature module exports components and directives that require sharing
the same custom provider instances, consider registering these providers in 
the `root` NgModule with a forRoot() method.

That will help ensure that all child NgModules have access to the same provider
instances.

================================================================================

  @Inject vs constructor injection
  ********************************

Should use @Inject only in situation where the injectable token is not a class.

Example:

  providers: [
    AuthService,
    { provide: Http, useValue: new CustomHttpImpl() }
  ]

Here we have two different providers, the AuthService and the CustomHttpImpl.
In the first case, the token is AuthService which means we can inject AuthService
using obviously AuthService type:

  constructor(private authService: AuthService) {}

With this constructor, Angular knows to look for AuthService with the token
`AuthService`.

In the second case, we provide CustomHttpImpl with the token `Http`. So we cannot
inject `CustomHttpImpl` - we need to inject Http:

  // error: no provider for CustomHttpImpl
  constructor(private http: CustomHttpImpl) {}

  // this will actually be the CustomHttpImpl, not Angular's Http
  constructor(private http: Http) {}


So you can tell from this that the tokens are all classes, which is enough for
Angular to figure out how to inject.

But let's say we have a String, or an Array of something we want to inject.
We cannot tie it to any class token - so we need to create an artificial token
like InjectionToken:

let config = '{ "some": "json", "config": "data" }'

export const CONFIG = new InjectionToken<Config>('Config');

Now we have a token we want to inject:

  providers: [
    { provide: CONFIG, useValue: config }
  ]

and when we inject, we @Inject(TOKEN)


  constructor(@Inject(CONFIG) config: string) {}



================================================================================

  injectable angular modules
  **************************

https://medium.com/@michelestieven/angular-writing-configurable-modules-69e6ea23ea42

A component could have a dependency on Classes, Values and Objects.

useClass
--------
  when you use a classname to specify a provider

    providers: [ MyService ]  

  it's interpreted like this:

    providers: [
      {
        provide: MyService,
        useClass: MyService
      }
    ]

  which means you could take a class, even a blank one, and exchange it with another

    class MyService {}
    class MyOtherService {}

    providers: [
      {
        provide: MyService,
        useClass: MyOtherService
      }
    ]

  useful for mocking services, you can use this to intro a new service keeping
  the old classname for compatibility reasons

useValue
---------

  useful when you don't want to provide a class but a value (object)

  let myObject = { greeting: 'Hello'} 

  providers: [
    {
      provide: 'MyService',
      useValue: myObject
    }
  ]

  @Component({...})
  export class AwesomeComponent {

    constructor(@Inject('MyService') myService) {
      console.log(myService.greeting);
    }
  }


useFactory
----------

  uses a factory (a simple function) and angular provides the return value of that
  function.  Useful when you want to do some checks or some operations before 
  knowing what to provide.

  let firstObject = { greeting: 'Hello World'};
  let secondObject = { greeting: 'Hello Earth'};

  providers: [
    {
      provide: 'MyService',
      useFactory: () => {
        if(...) return firstObject
        else return secondObject
      }
    }
  ]

  @Component
  export class AwesomeComp {
    constructor(@Inject('MyService') myService) {
      console.log(myService.greeting);
    }
  }


InjectionToken
---------------

  now we want to provide string names and classes that will be overritten.

  InjectionToken provides a name to us in the provide field, instead of using
  strings or classes.

  Since every instance of the InjectionToken is different, there are no 
  naming collisions:

    import { InjectionToken } from '@angular/core';
    import { MyInterface } from '...';

    const NewToken = new InjectionToken<MyInterface>('TOKEN');


Injectable Modules
******************

Suppose you have a library that provides the ability to pull different models
from a CMS.  The library will be in its own module.


1. the library will expose a static forRoot() method that will accept a 
configuration object

2. the configuration object will be an InjectionToken and useValue

3. the configuration object is defined by an interface


  // the service
  import { ContentfullService } from '...';

  // interface to define the configuration object
  interface ContentfulConfig {
    appId: string;
    appKey: string;
  }


  // InjectionToken
  const InjectedContentfulConfig = new InjectionToken<ContentfulConfig>('Config');


  @NgModule()
  export class ContentfulModule {

    static forRoot(config: ContentfulConfig): ModuleWithProviders {
      return {
        ngModule: ContentfulModule,
        providers: [
          ContentfulService,
          {
            provide: InjectedContentfulConfig,
            useValue: config
          }
        ]
      }
    }
  }

 -----------------------------------------

 Now, in the consuming application:


 const contentfulConfig: ContentfulConfig = {
  appId: 'cool-app',
  appKey: '94qera09fad09fads'
 }


 @NgModule({
  imports: [
    ...
    ContentfulModule.forRoot(contentfulConfig)
  ]
 })
 export class AppModule {}

and in a service where this config is needed:

  @Injectable()
  export class ContentfulService {
    private client;

    constructor(@Inject(ContentfulConfig) private  config)

  }



 Another example:
 ============================================

 library:

ng-brand-library-config.ts
---------------------------

import {BuildInfo} from './build-info';
import {InjectionToken} from '@angular/core';

export interface SfgNgBrandLibraryConfig {
  buildInfo: BuildInfo;
  env: string;
}

/**
 * This is an injection token to accept the config object seeded with values injected by the consuming app.
 */
export const InjectedLibraryConfiguration = new InjectionToken<NgBrandLibraryConfig>('NgBrandLibraryConfig');


ng-brand-library.module.ts
---------------------------

import {ModuleWithProviders, NgModule} from '@angular/core';
import {FooterComponent} from './footer/footer.component';
import {InjectedLibraryConfiguration, NgBrandLibraryConfig} from './model/ng-brand-library.config';
import {AuthenticationService} from './services/authentication.service';
import {NullComponent} from './pages/null/null.component';
import {CommonModule} from '@angular/common';
import {BsDropdownModule, ModalModule} from 'ngx-bootstrap';
import {NgIdleModule} from '@ng-idle/core';



@NgModule({
  providers: [ /* Do not add services here */ ],
  imports: [
    CommonModule,
    ModalModule.forRoot(),
    BsDropdownModule.forRoot(),
    NgIdleModule.forRoot()
  ],
  declarations: [
    NullComponent,
    FooterComponent
  ],
  entryComponents: [
    NullComponent
  ],
  exports: [
    FooterComponent
  ]
})
export class NgBrandLibraryModule {
  static forRoot(libraryConfig: NgBrandLibraryConfig): ModuleWithProviders {
    return {
      ngModule: NgBrandLibraryModule,
      providers: [
        // your library providers here
        {
          provide: InjectedLibraryConfiguration,
          useValue: libraryConfig
        },
        AuthenticationService,
      ]
    };
  }
}


In a library component:

footer.component.ts
--------------------

export class FooterComponent implements OnInit {

  public buildInfo: BuildInfo;

  constructor(
    @Inject(InjectedLibraryConfiguration) private libraryConfig
  ) {}

  ngOnInit() {
    this.buildInfo = this.libraryConfig.buildInfo; 
  }

}


In a consuming app's AppModule

app.module.ts
--------------

const ngBrandLibraryConfig: NgBrandLibraryConfig = {
  buildInfo: {
    timestamp: environment.buildTimestamp,
    version: environment.buildVersion
  },
  env: environment.env
};

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule,
    RouterModule.forRoot(appRoutes),
    ModalModule.forRoot(),
    NgBrandLibraryModule.forRoot(ngBrandLibraryConfig)
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

================================================================================

  HostBinding
  ***********

@Component({
  selector: 'some-component',
  . . .
})
export class SomeComponent implements NgOnInit {
  
  @HostBinding('attr.class') cssClass = 'row';

}

In the above example, the styling library provides a style class 'row'.

You could certainly configure that class on the tag name for this component:

  <some-component class="row"></some-component>

but it would be nice to be able to encapsulate the component configuration
within the component itsefl.

@HostBinding() decorator allows us to set properties on the 'host' element 
this component is attached to:

  <some-component>

class attribute with the value of 'row' in this example.

================================================================================

  Monorepo
  ********


Goals
-----------

Increase Visibility

  teams within organization are often unaware of changes that other teams
  are making.   


Reuse Code Directly

  traditional way to modularize and share code is to create a package.
  there is a large amount of overhead when making changes to these.

  versioning of various packages and staying current to update consuming 
  applications is a challenge.

  developer can work with the code directly.


Ensure Consistent Version of Dependencies

  Single version policy

  Organizations or business units can choose to have 

    - a single version of dependencies across all projects, or

    - to have a "latest-minus-X" policy to ensure all are up-to-date.




OSS projects vs Apps
--------------------

Ownership

  OSS projects owned by a single team.

  Apps in an Org are built by multiple teams


Variability

  OSS project is built for a single purpose by a single team.
  The team can agree on the choice of tools and tech.

  Apps are built by diff teams within an Org.




3 Reasons for creating Libs
---------------------------

  1. Code Sharing 

  2. Run tasks on less code 

  3. Organization




================================================================================