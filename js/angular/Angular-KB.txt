  
	@@@@@@@@@@@

		Angular

	@@@@@@@@@@@



  Architecture
  *************

Angular applications are composed of:
  1. HTML templates with angularized markup,
  2. component classes to manage those templates
  3. services with application logic
  4. modules combing components and services

You launch the app by bootstrapping the root module


8 main building blocks of an Angular app:

1. Modules
2. Components
3. Templates
4. Metadata
5. Data binding
6. Directives
7. Services
8. DI

================================================================================

Routing
-------


  Good tutorial for nested  3-level routing 
  https://www.freakyjolly.com/angular-nested-routing-with-multiple-routeroutlet-using-loadchildren-having-own-router-modules-example-application/

  


  Routing is another name for navigation.
  The router is the mechanism for navigating from view to view.
  Routes tell the router which views to display when a user clicks a link
  or pastes a URL into the browsers' address bar.


  Module Import Order Matters

    When you start using modules with their own routing modules, 
    and the routes are no longer defined in one file - import order
    becomes important.

    Each routing module augments the route configuration IN THE ORDER OF
    IMPORT.  

    If you list AppRoutingModule first, the WILDCARD route
    will be registered BEFORE the hero routes.

    app.module.ts
    -------------

      @NgModule({
        imports: [
          BrowserModule,
          FormsModule,
          HttpModule,
          AppRoutingModule,  <-- uh-oh
          DashboardModule,
          HeroModule,        <-- wildcard kicks in before hero module routes
          CrisisCenterModule     

      export class AppModule {
        // diagnostic only
        constructor(router: Router) {
          console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
        }
      }      


      The wildcard route - which matches every URL -- will intercept
      the attempt to navigate to a hero route.


        Routes:  [
          {
            "path": "heroes",
            "loadChildren": "app/hero/hero.module#HeroModule"
          },
          {
            "path": "crisis-center",
            "loadChildren": "app/crisis-center/crisis-center.module#CrisisCenterModule"
          },
          {
            "path": "dashboard",
            "loadChildren": "app/dashboard/dashboard.module#DashboardModule"
          },
          {
            "path": "",
            "redirectTo": "/dashboard",
            "pathMatch": "full"
          },
          {
            "path": "**"
          },
          {
            "path": ""
          },
          {
            "path": ""
          },
          {
            "path": ":id"
          },
          {
            "path": ""
          }
        ]


  Router 
  ----------------

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

  When the router navigates to a new component view, it updates the browser's 
  location and history with a URL for that view.  This is a strictly local URL.
  The browser should not send this URL to the server and should NOT reload the
  page.

  The Angular Router supports two techniques for achieving that with the help
  of two LocationStrategy providers:

  1. PathLocationStrategy - the default "HTML 5 pushState" style
  2. HashLocationStrategy - the "hash URL" style

  The first one relies on the modern HTML 5 browsers' support for history.pushState
  technique.

  Older browsers send page requests to the server when the location URL changes.. 
  unless the change occurs after a "#" hash.  Routers take advantage of this
  exception by composing in-application route URLs with hashes. e.g.:

    localhost:3002/src/#/crisis-center/



   <head>
    <base href="/">

    base href is important to make history.pushState work
    add the base href just under the <head> tag.

    if the "app" folder is the application root, set the href value to "/".

    The Router uses the browser's pushState for navigation.
    Thanks to pushState, we can make our in-app URL paths look the way 
    we want them to look.

    Our in-app URLs can be indistinguishable from server URLs.

    The browser also needs the base <href> value to prefix relative URLs.



Define Routes
-------------

  a router must be configured with a list of route definitions.



FIRST MATCH WINS

    The router selects the route with a 'first match wins' strtegy.
    Wildcard routes are the least specific routes in the route configuration.
    Be sure it is the last route in the configuration.


wildcard route

  add a wildcard route to intercept invalid URLs and handle them gracefully.
  a "wildcard" route has a path consisting of "**" - it matches every URL.

    { path: "**", component: PageNotFoundComponent }

DEFAULT route
redirect route

  when the application launches, the initial URL in the browser bar is something
  like 

    localhost:3000

  that doesn't match any of the concrete configured routes, which would mean 
  the router falls all the way through to the wildcard route and displays the
  PageNotFoundComponent.  

  The application needs a DEFAULT route to a valid page.
  The solution is to use a 'redirect' route that translates the initial
  relative URL ('') to the desired default path, /heroes for example.


      const appRoutes: Routes = [
        { path: 'crisis-center', component: CrisisListComponent },
        { path: 'heroes',        component: HeroListComponent },
        { path: '',   redirectTo: '/heroes', pathMatch: 'full' },
        { path: '**', component: PageNotFoundComponent }
      ];

  a redirect route requires 'pathMatch' property to tell the router how to 
  match a URL 

    pathMatch: 'full' 

  the other possible pathMatch value is 'prefix'

  Root routing module
  ...................

    const routes: Routes = [
      { path: '', redirectTo: 'dashboard', pathMatch: 'full' },
      { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' },
      { path: 'crisis-center', loadChildren: 'app/crisis-center/crisis-center.module#CrisisCenterModule' }
    ];

    @NgModule({
      imports: [
        RouterModule.forRoot(
          routes,
          // { enableTracing: true }
        )
      ],
      exports: [RouterModule]
    })
    export class AppRoutingModule { }  



  Module/Child routing module
  ............................

    const crisisCenterRoutes: Routes = [
      { path: '', component: CrisisCenterComponent }
    ];

    @NgModule({
      imports: [RouterModule.forChild(crisisCenterRoutes)],
      exports: [RouterModule]
    })
    export class CrisisCenterRoutingModule { }



Inspect Router's Configuration
------------------------------

  You can inspect the router's current cconfiguration by examining its
  'config' property.

      app.module.ts
      -------------

      export class AppModule {
        // diagnostic only: inspect router configuration
        constructor(router: Router) {
          console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
        }
      }

  Are routes listed in the order you expect them to?


    Routes:  [
      {
        "path": "heroes",
        "loadChildren": "app/hero/hero.module#HeroModule"
      },
      {
        "path": "crisis-center",
        "loadChildren": "app/crisis-center/crisis-center.module#CrisisCenterModule"
      },
      {
        "path": "dashboard",
        "loadChildren": "app/dashboard/dashboard.module#DashboardModule"
      },
      {
        "path": "",
        "redirectTo": "/dashboard",
        "pathMatch": "full"
      },
      {
        "path": "**"    <--- uh-oh 
      },
      {
        "path": ""
      },
      {
        "path": ""
      },
      {
        "path": ":id"    <--- will this one ever match?!
      },
      {
        "path": ""
      }
    ]  



RouterOutlet
------------

<router-outlet></router-outlet>

  directive from the router library that marks the spot in the template where
  the router should display the views for that outlet.

    The router adds the <router-outlet> element to the DOM and subsequently
    inserts the navigated view element immediately after the <router-outlet>

RouterLink binding
------------------

  <nav>
    <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
    <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
  </nav>

  routerLink=" path to a preconfigured route "


RouterLinkActive binding
------------------------

  on each <a> anchor tag, there is RouterLinkActive directive.

  toggles CSS classes for active RouterLinks based on the current RouterState.
  e.g.:

    nav a.active {
      color: #03d465;
    }

  will apply this style to <a> anchor tag defined inside <nav> element:

    <nav>
      <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
      <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
    </nav>  



Lazy Loading
-------------
https://enlear.academy/angular-lazy-loading-7450dbab8bf0



Eager Loading Modules
---------------------

https://enlear.academy/eager-loading-in-angular-7aab94c09ab3




Scroll to top on every Route click
-------------------------------------

https://stackoverflow.com/questions/48048299/angular-5-scroll-to-top-on-every-route-click


Option 1
<router-outlet (activate)="onActivate($event)"></router-outlet>

Option 2

for eagerly loaded modules:

RouterModule.forRoot(appRoutes, { scrollPositionRestoration: 'enabled' })






Router Fragment Scrolling
--------------------------


  For eager loaded modules
  -------------------------


Configure Router options in your App Routing Module or in your app module.

const routerOptions: ExtraOptions = {
  scrollPositionRestoration: 'enabled',
  anchorScrolling: 'enabled',
  // onSameUrlNavigation: 'reload',
  scrollOffset: [0, 50],
  // relativeLinkResolution: 'legacy',
}  

@NgModule({
  imports: [RouterModule.forRoot(routes, routerOptions)],
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }



NEED TO READ
Angular 5 Scroll to top on every Route click
https://stackoverflow.com/questions/48048299/angular-5-scroll-to-top-on-every-route-click



https://stackoverflow.com/questions/39941656/scroll-to-anchor-not-working

https://codecraft.tv/courses/angular/routing/nested-routes/

https://stackoverflow.com/questions/54574986/angular-7-x-x-easiest-way-to-scroll-to-a-fragment

https://stackoverflow.com/questions/44441089/angular4-scrolling-to-anchor/64185407#64185407



scroll position restoration
https://blog.angular.io/angular-v6-1-now-available-typescript-2-9-scroll-positioning-and-more-9f1c03007bb6


on EAGERLY LOADED MODULES

Since Angular6.1, we can also use { scrollPositionRestoration: 'enabled' } on eagerly loaded modules and it will be applied to all routes:

RouterModule.forRoot(appRoutes, { scrollPositionRestoration: 'enabled' })



does not work when the data is loaded asynchronously

https://github.com/angular/angular/issues/24547


  For lazy loaded modules
  -----------------------

You don't need extra router options for this.

component html template

  at the top of your component template

    <a id="top"></a>
    or
    <h1id="top">My Header</h1>

  ToC section


      <section id="toc">
        <br>
        <h2>Table of Contents</h2>
        <ul>
          <li><a routerLink="/lib-components/icon" fragment="font-awesome-icons">Font Awesome Icons</a></li>
          <li><a routerLink="/lib-components/icon" fragment="custom-decorative-icons">Custom Decorative Icons</a></li>
        </ul>
      </section>

  Later in the document


      <section id="custom-decorative-icons">
        <a routerLink="/lib-components/icon" fragment="top">Back to top</a>

        yada yada content

      </section>


================================================================================



1. Modules
-----------
  
every app has at least one module - root - named "AppModule"

other modules are "feature" modules

each module is a cohesive block of code dedicated to an app domain, a workflow, 
or a closely related set of capabilities.

any module, root or feature, is a class with @NgModule decorator


NgModule
--------

  NgModule is a decorator function that takes a single metadata object whose
  properties describe a module.

    - declarations

      = view classes that belong to this module. 3 types of view classes:
        1. components
        2. directives
        3. pipes
    
    - exports
      = subset of the declarations that should be visible and usable 
      in the component templates of OTHER modules
    
    - imports
      = other modules whose exported classes are needed by component
      templates declared in this module
    
    - providers
      = creators of services that this module contributes 
      to the global collection of services
      they become accessible in all parts of the app
    
    - bootstrap [ROOT only]
      = the main application view, called 'root component'
      only ROOT module should set this "bootstrap" property

example of root module

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  @NgModule({
    imports:      [ BrowserModule ],
    providers:    [ Logger ],
    declarations: [ AppComponent ],
    exports:      [ AppComponent ], // just for demo - no one needs root module
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

bootstrap root in main.ts

app/main.ts:

  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
  import { AppModule } from './app.module';

  platformBrowserDynamic().bootstrapModule(AppModule);

Angular modules and JavaScript modules

  be aware that you're using the two systems side by side:

    import { Component } from '@angular/core';
    .
    .
    .
    @NgModule({
      imports:  [ BrowserModule ],
      ...
    })

2. Components
----------------------------------------

   a component controls a patch of screen called a 'view'
   e.g., the following views are controlled by components:
    - app root with navigation links
    - list of heros
    - hero editor

  you define a component's logic - what it does to support the view - inside
  a class.  The class interacts with the view thru an API of properties and
  methods.

    e.g. this HeroListcomponent has a 'heroes' property that returns an array
    of heroes that is acquires from a service.
    it also has a selectHero() method that sets a selectedHero property when
    a user clicks to choose a hero from that list.



Component properties
====================

host
----
  adds class to host tag

  @Component({
    host: {
      'class': 'myclass1 myclass2 myclass3' 
    }
  })
  export class MyTagComponent {}

  View code:  <mytag></mytag>

  Result:  <mytag class="myclass1 myclass2 myclass3"></mytag>


3. Templates
----------------------------------------

  you define a component's view with its companion template.
  a template is a form of HTML that tells Angular how to render the component.
  In addition to HTML, templates use Angular's template syntax.


  Template syntax
  ***************

  Templates display data and consume user events with the help of data binding.

    MVC or MVVM (mode-view-viewmodel)

  In Angular, the component plays the part of the Controller/Viewmodel, and
  the template represents the view.

    Basic Elements of Template syntax

  HTML
  Interpolcation
  Template expressions
  Template statements
  Binding syntax
  Property binding
  Attribute, class and style bindings
  Event binding
  Two-way data binding
  Built-in directives (NgClass, NgStyle, NgIf, NgFor, etc.)

  HTML
    almost all HTML syntax is valid template syntax.
    <script> element is notable exception - forbidden due to injection risk

  interpolation
    we use interpolation to weave calculated strings into the text between HTML element
    tags and within attribute assignments

        <h3>
          {{title}}
          <img src="{{heroImg}}" ... >
        </h3>

  template expressions
    produce a value
    angular executes the expression and assigns it to a property of a binding target

      [property]="expression"

      [disabled]="isUnchanged"

    template expressions cannot refer to anything in the global namespace.
    can't refer to window or document, can't call console.log or Math.max

    the expression context is typically the component instance which is the source
    of binding values.

    Guidelines:

      - a template expression should not change any application state other than
        the value of the target property

      - quick execution
        template expressions execute frequently - can be called every key press or
        mouse move        

      - simplicity: a property or method call should be the norm. ! is OK occasionally

      - idempotence: should be free from side effects

        Binding syntax

          from data source to view target:

        {{expression}}
        [target-property] = "expression"

          from view target to data source:

        (target) = "statement"
        on-target = "statement"


          two-way

        [(target)] = "expression"
        bindon-target = "expression"

    <button disabled>Save</button>

  with data binding

    <button [disabled]="isUnchanged">Save</button>                  


    Binding Targets

      the target of data binding is something in DOM.
      it could be a element | component | diretive property
      an event (element | component | directive) 

      binding type: property

        target:

          element property:

                <img [src] = "heroImgUrl">

              component property

                <hero-detail [hero]="currentHero"></hero-detail>

              directive property:

                <div [ngClass] = "{selected: isSelected}"></div>

      binding type: event                  

        target: 

          element event

              <button (click) = "onSave()">Save</button>


              <button (click)="show = !show"> {{show ? 'hide' : 'show'}} </button>

              presuming the component owning this template has something like:

                show: boolean = false;

              the button is bound to DOM event (click) which will trigger 
              the action indicated by the text in quotes.  Here, variable
              `show` will assigned the opposite value of self.
              The button text is bound to that variable `show`, so clicking
              the button will toggle the button text.



          component event

              <hero-detail (deleteRequest)="deleteHero()"></hero-detail>

          directive event

              <div (myClick)="clicked=$event">click me</div>



      binding type: two-way              

        target

          event and property

              <input [(ngModel)]="heroName">


      attribute

        <button [attr.aria-label]="help">help</button>

      class

        <div [class.special]j="isSpecial">Special</div>

      style

        <button [style.color] = "isSpecial ? 'red' : 'green'">


      How the parent and child components can communicate with each other:
      ---------------------------------------------------------------------

        <hero-detail [hero]="currentHero"></hero-detail>
      


4. Metadata
----------------------------------------



5. Data binding
----------------------------------------

  you display data by binding controls in an HTML template to properties
  of an Angular component.


    Template binding works with DOM PROPERTIES, not HTML attributes.



datasource-to-view
-------------------

interpolation and template expressions

  {{expression}}
  [target]="expression"
  bind-target="expression"

  Element property
  Component property
  Directive property

  examples:

    <img [src]="heroImageUrl">
    <app-hero-detail [hero]="currentHero"></app-hero-detail>
    <div [ngClass]="{'special': isSpecial}"></div>


view-to-source
---------------

events

  (target)="statement"
  on-target="statement"

  Element event
  Component event
  Directive event

  examples:

    <button (click)="onSave()">Save</button>
    <app-hero-detail (deleteRequest)="deleteHero()"></app-hero-detail>
    <div (myClick)="clicked=$event" clickable>click me</div>

    <button (click)="deleteHero()">Delete hero</button>

      A template statement has a side effect. That's the whole point of an event. 
      It's how you update application state from user action.

      The statement context is typically the component instance. 
      The deleteHero in (click)="deleteHero()" is a method of the data-bound component.







  two-way 
  --------


      [(target)]="expression"

      bindon-target="expression"


      /**********************************
       *                                *
       * HTML attribute vs DOM property *
       *                                *
       **********************************/


  Attributes are defined by HTML.
  Properties are defined by the DOM.

  * a few HTML attributes have 1:1 mapping to properties.
    'id' is one example

  * some HTML attributes have no corresponding properties - e.g. colspan

  * some DOM props don't have corresponding attributes - textContent, e.g.

  * many HTML attrs seem to map to properties, but not the way you think!

  Attributes initialize DOM properties and then they are DONE.
  Property values can change; attributes do not.

  e.g. when the browser renders 

    <input type="text" value="Bob">

  it creates a corresponding DOM node with a 'value' property initialed to "Bob".
  when the user enters "Sally" into the input box, the DOM element 'value' 
  property becomes "Sally".  But the HTML 'value' attribute REMAINS 
  unchanged as you can confirm by asking:

    input.getAttribute('value');  // returns "Bob"

  the HTML attribute value specifies the INITIAL value; the DOM value property
  is the CURRENT value.

  The 'disabled' attribute is another peculiar example.
  A button's 'disable' PROPERTY is "false" by default so it is enabled.
  when you add the 'disabled' attribute, its presence alone initializes the 
  button's 'disabled' property to "true" to the button is disabled.

  Setting the button's 'disabled' property disables|enables the button - 
  the value of the PROPERTY matters (attribute does not).


Type

  Property

    element:  <img [src]="heroImageUrl">

    component:  <hero-detail [hero]="currentHero"</hero-detail>

    directive:  <div [ngClass]="{'special': isSpecial}">

                </div>

  Event

    element:   <button (click)="onSave()">Save</botton>

    component: <hero-detail (deleteRequest)="deletedHero()"></hero-detail>
     
    directive:  <div (myClick)="clicked=$event" clickable>click me</div>


  Attribute

    attribute:  <button [attr.aria-label]="help">help</button>

  Class

    property:   <div [class.special]="isSpecial">Special</div>


  Style

    property:   <button [style.color]="isSpecial ? 'red' : 'green'">



  Two-way

    event and property:   <input [(ngModel)]="name">



================================================================================



6. Directives
----------------------------------------

  A directive is a class with directive metadata.
  In TS, apply the @Directive decorator to attach metadata to the class.

  A component is a "directive-with-a-template".
  @Component decorator is actually a @Directive extended with template-oriented
  features.

  two other kinds of directives exist:

  1. structural
  2. attribute


Directives do not require a view.  They should be responsible for rendering 
logic: adding/removing elements and adding custom behavior to DOM elements or components.




  Directives Selectors
  ---------------------


Selectors:

selector : 'your-option'    // element selector
selector : '[your-option]'  // property selector
selector : '.your-option'   // class selector

To use this in HTML

<your-option></your-option>      /* this is element selector usage
<div your-option></div>          /* this is property selector usage
<div class="your-option"></div>  /* this is class selector usage





  Anatomy of Angular Attribute @Directive selector
  -------------------------------------------------
  https://medium.com/swlh/anatomy-of-angular-attribute-directive-selector-a1d83a73242



Selectors can be declared using any of the following as per the angular documentation:

    element name or tag name
    [attribute] or [attribute=value]
    .class
    :not(sub_selector)
    selector1, selector2











Properties of Directives
------------------------


[host] - adds classes to host tag



  structural directives
  ...................................

    alter layout by adding, removing, and replacing elements in DOM.
    the example template uses two built-in structural directives

      <li *ngFor="let hero of heroes"></li>
      <hero-detail *ngIf="selectedHero"></hero-detail>

    *ngFor tells Angular to stamp out one <li> per hero in the 'heroes' list

    *ngIf includes the HeroDetail component only if a selected hero exists.



    <ng-container>

      grouping element
      ----------------

        is a grouping element that doesn't interfere with styles or layout
        because Angular doesn't put it in the DOM.

        In order to avoid having to create an extra div, we can instead use 
        <ng-container> directive.
        
        E.g.:

          <p>
            I turned the corner
            <ng-container *ngIf="hero">
              and I saw {{hero.name}}. I waved
            </ng-container>
            and continued on my way.
          </p>


        <ng-container> is a syntax recognized by the Angular parser.
        It's more like the curly braces in a JavaScript 'if' block


          if (somecondition) {
            ..
            ..
            ..
          }


        Without those braces, JS would only execute the first statement
        when you intend to conditionally execute all of them as a single 
        block.

        <ng-container> satisfies a similar need.


      placeholder for injecting a template dynamically into the page
      ------------------------------------------------

      We can take the template itself and instantiate it anywhere on the page,
      using the 'ngTemplateOutlet' directive:

        <ng-container *ngTempalteOutlet="loading"></ng-container>

      we are using <ng-container> instantiate on the page the 'loading'
      template.




  attribute directives
  ...................................    

    alter the appearance or behaviour of an existing element.
    In templates, they look like regular HTML attributes, hence the name.

    ngModel directive implements two-way binding and is an example of an
    attribute directive.

    it modifies the behaviour of an existing element (typically <input>) by 
    setting its display value property and responding to change events:

      <input [(ngModel)]="hero.name">



================================================================================

  Create Custom Direcive
  **********************

- Create a basic directive and declare on an NgModule
- Use Selectors to associate an element with a directive based on HTML attribute.
- interactive with the raw DOM element of the associated element from the directive.

- use the renderer



## Generate new directive module

  $ ng g m common/directives --project au-components

and then a new directive

  $ ng g d common/directives/input-ref --project au-components


NOTE: that the selector 

  selector: '[libInputRef]'

is wrapped in square brackets - that's because angular uses CSS matching rules 
to match a component or directive to an HTML element

We want to associate the directive with an HTML element as an attibute (not as a css class)
that's why we use square brackets



================================================================================

7. Services
----------------------------------------

  Service is a broad category encompassing any value, function, or feture that
  your application needs.

  Almost anything can be a service.
  Typically is a class with a narrow, well-defined purpose.
  Examples:
  - logging service
  - data service
  - message bus
  - tax calculator
  - application configuration

Angular has no definition of services.
There is no service base class, and no place to register a service.
Yet services are fundamental - components are big consumers of services.

example of a service class that logs to browser console:
app/logger.service.ts:

  export class Logger {
    log(msg: any) { console.log(msg); }
    error(msg: any) { console.error(msg); }
    warn(msg: any) { console.warn(msg); }
  }

example of HeroService that fetches heroes and returns them in a resolved
Promise.  This services also depends on the Logger service and another 
BackendService that handles the server comm grunt work:

app/hero.service.ts

  export class HeroService {
    private heroes: Hero[] = [];

    constructor(
      private backend: BackendService,
      private logger: Logger
    ) {}

    getHeroes() {
      this.backend.getAll(Hero).then(
        (heroes: Hero[]) => {
          // ... 
        });
      );
    }
  }

Component classes should be lean - they don't fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.

A component's job is to enable the user experience - nothing more. 
It mediates between the view (rendered by the template) and the application
logic (which often includes some notion of a model).

A good component presents properties and methods for data binding.
It delegates everything non-trivial to services.



  Async Services and Promises
  ...........................

if a service calls a remote server like

  this.heroes = this.heroService.getHeroes();

the method call sig is synchronous - and we will have to wait for the server to
respond and we won't be able to block the UI while we wait.

  Promises
  --------

A Promise is a promise to call us back later when the results are ready - 
we ask an async service to do some work and give it a callback function.



8. DI
----------------------------------------

Main points:

  injector - main DI mechanism

    maintains a container of service instances that it created

    can create a new service instance from a provider

  provider is a recipe for creating a service

  you register providers with injector
  
      
      
  Services and DI
  ---------------

Most dependencies are services - Angular uses DI to provide new components with the 
services they need.
Angular can tell which services a component needs by looking at the types of 
its constructor parameters.

E.g. constuctor of the HeroListcomponent:

  constructor(private service: HeroService) {}

When Angular creates the component, it asks an INJECTOR for the services that 
the component requires.

An injector maintains a container of service instances that it has previously
created.  If a requested service instance is not in the container, the 
injector makes one and adds it to the container before returning the service 
to Angular.

    How does the injector know how to make one?

You must have previously registered a PROVIDER of the HeroService with the 
injector.  A provider is something that can create or return a service, 
typically a service class itself.  You can register providers in modules or
in components.

In general, add providers to the root module so that the same instance of a
service is available everywhere.

    root module
    app/app.module.ts

      providers: [
        BackendService,
        HeroService,
        Logger
      ],

alternatively, register at a component level in the providers property of 
the @Component metadata:

  app/hero-list.component.ts

    @Component({
      moduleId: module.id,
      selector: 'hero-list',
      templateUrl: 'hero-list.component.html',
      providers: [ HeroService ]
    })

registering at a component level means you get a NEW instance of the service
with each NEW instance of that component.



Pipes
------------------------------------------

Pipes are a good way to format strings, currency amounts, dates and other
display data.

Angular ships with several pipes and we can write out own.


  Async Pipe
  ----------

reactive templates with Async Pipe
https://blog.angular-university.io/angular-reactive-templates/


Usage:

  <div>{{ observableTime | async }}</div>

Purpose:

  unwrap a value from an asynchronous primitive.
  if we have an Observable or Promise instance, then we can use it directly
  with AsyncPipe using diretives like 'ngFor', 'ngIf' and 'NgSwitch'.

  subscribes to Observable or Promise and returns latest data.

  marks the component to check for data changes.

    NgFor Example
    .............

      @Injectable() service to fetch book data

      component to display that data

        <ul>
          <li *ngFor="let book of observableBooks | async" >

            Id: {{book.id}}, Name: {{book.name}}

          </li>
        </ul>

      in component:

        ngOnInit(): void {
          this.observableBooks = this.bookService.getBooks();
        }

    NgIf and NgSwitch Example
    .........................

      <div *ngIf="promiseBook | async as book; else loading">
        Id: {{book.id}}, Name: {{book.name}}
      </div>
      <ng-template #loading>Loading Data .. </ng-template>

      <h3>AsyncPipe with NgSwitch</h3>

      <div [ngSwitch]="(promiseBook | async)?.id">

        <div *ngSwitchCase="100">Find Actual Data</div>
        <div *ngSwitchDefault>Showing Default Data</div>

      </div>


  Access array elements in async pipe
  ------------------------------------

https://stackoverflow.com/questions/42614267/access-first-item-of-array-using-async-pipe-in-angular-2

I was able to access the Observable's first member by using angular's async pipe.

ypurComponent.html

(yourObservable | async | slice :0:1)

Q: How to access the first item of an array when using async pipe?

  <nav-tabs
     [tabs]="(pageTabs$ | async)"
     [activeTab]="(pageTabs$ | async)[0]">
  </nav-tabs>

I've tried (pageTabs$ | async)[0] but it didn't work.

Found an even easier way of doing it (without creating a custom pipe): add a map to the observable.

component.ts

  this.activeTab$ = this.pageTabs$.map(x => x[0]);

component.html

  <nav-tabs
     [tabs]="(pageTabs$ | async)"
     [activeTab]="(activeTab$ | async)">
  </nav-tabs>





Providers
------------------------------------------

  useExisting 

    example

      providers: [
          A, 
          {provide: B, useClass: A}, 
          {provide: C, useExisting: A}]    

      if you have 

        constructor(private a: A)

      an instance for the first provider will be created

        constructor(private b: B)

      an instance for the 2nd provider will be created

        constructor(private c: C)

      an instance of the first provider will be injected

      but if you had started fresh with 

        constructor(private c: C)

      an instance of the first provider is created and injected



==============================================================================

  template syntax
  ***************

https://angular.io/docs/ts/latest/guide/template-syntax.html

interpolation  
----------------------------------------

  {{title}}
  {{ 1 + 1 + getVal() }}


template expressions
----------------------------------------
  produces a value
  angular executes the expression, assigns it to a property of a binding
  target - a HTML element, a component, or a directive

    [property] = "expression"



template statements
----------------------------------------

  (event) = "statement"

  a template statement responds to an event raised by a binding target such as
  an element, component, or directive

  has side effect
  it's how we update application state from user input.
  there would be no point to responding to an event otherwise.



Data binding
************

  component logic interacts with component template (view)

  - string interpolation
    {{exp resolving to a string}}

  - property binding
    binding data to properties in your DOM
    <button [disabled] = "exp resolving to required value type">  

  - event binding 
    binding DOM events back to the model
    <button (click) = "expression handling the event">

  - two-way binding
    by default all Angular2 data binding is uni-diretional
    for performance reasons.
    <input [(ngModel)] = "bound model (e.g. object)">


binding syntax
----------------------------------------

  one-way
  from data source to view target   
        {{expression}}
        [target] = "expression"
        bind-target = "expression"

  one-way
  from view target to data source
        (target) = "statement"
        on-target = "statement"

  two-way
        [(target)] = "expression"
        bindon-target = "expression"



property binding
----------------------------------------
  we write a template property binding when we want to set a property of a
  view element to the value of a template expression. 
  e.g. binding the 'src' property of an image to 'heroImageUrl' property:

    <img [src] = "heroImageUrl">

  disabling a button when the component says that it "isUnchanged"

    <button [disabled] = "isUnchanged">Cancel is disabled</button>

  setting a property of a directive

    <div [ngClass] = "classes">[ngClass] binding to the classes property</div>
    <div (ngSubmit) = "..."></div>   

  binding to component properties

    <cmp [initObj] = "...">
    <cmp (rndEvent) = "...">    

  custom bindings

    Property Binding (@Input)

      @Input() propertyName: string 

    one-way in
    ----------

  property binding is described as "one-way data binding" because it
  flows a value in one direction, from a component's data property into
  a target element property.





attribute, class and style bindings
----------------------------------------





event binding
----------------------------------------

  User interact with your application
  - they click buttons
  - pick items from lists
  - enter text into input boxes

  Such user actions may result in data flowing in the opposite direction:

  data flow:

    from an element to a component

  The only way to know about a user action is to listent for certain events 
  such as keystrokes, mouse movements, clicks and touches.

  We declare our interest in user actions thru Angular event binding.

  Event Binding syntax

    (target event) = "template statement"

      TARGET EVENT - appears between parenthesis.

        <button (click) = "onSave()">Save</button>  

      Canonical form:

        some people prefer the "on-" prefix alternative, known as canonical form:

        <button on-click="onSave()">On Save</button>

  Matching order

    - directives
    - elements

    element events may be the more common targets, but Angular looks to see 
    if the name matches an event property of a known directive FIRST.

      <!-- 'myclick' is an event on the custom 'clickDirective' -->
      <div (myClick)="clickmessage=$event">click with myClick</div>


    $event 
    ........................

    In an event binding, Angular sets up an event handler for the target event.

    when the event is raised, the handler executes the template statement.
    The template statement typically involves a receiver which performs an action
    in response to the event, such as storing a value from the HTML control 
    into a model.

    the binding conveys info about the event, inclu data values, thru an
    event object named 

      $event

    the shape of the event object is determined by the target event.
    If the target event is a native DOM element event, then $event is a
    DOM event object, with properties such a "target" and "target.value"

      <input [value]="currentHero.firstname"
             (input)="currentHero.firstname=$event.target.value">

    this code:
      - sets the input box "value" property by binding to the "firstName" 
        property
      - to listen for changes to the value, the code binds to the input box's
        "input" event.  when the user makes changes, the "input" event is 
        raised, and the binding executes the statement within a context that
        includes the DOM event object, $event.
      - to update the "firstName" property, the changed text is retrieved from
          $event.target.value



    EventEmitter
    ........................                                   

      Directives typically raise custom events with an Angular EventEmitter.

      example

        consider a HeroDetailComponent that presents hero info and responds to 
        user actions.  Although the HeroDetailComponent has a delete button,
        it doesn't know how to delete the hero itself..
        The best it can do is raise an event reporting the user's delete request.

        template:
        -------------
          <div>
            <img src="{{heroImageUrl}}">
            <span>{{prefix}} {{hero?.fullName}}</span>
            <button (click)="delete()">Delete</button>
          </div>

        hero-detail.component.ts (delete logic):
        ----------------------------------------

          // this component make a request but it can't actually delete a hero
          deleteRequest = new EventEmitter<Hero>();

          delete() {
            this.deleteRequest.emit(this.hero);
          }

        the component defines a "deleteRequest" property that returns an 
        EventEmitter.  When the user clicks "delete", the component invokes
        the "delete()" method telling the EventEmitter to emit a Hero object.

        Now, imagine a hosting parent component that binds to the 
        HeroDetailComponent's "deleteRequest" event:

          <hero-detail 
            (deleteRequest)="deleteHero($event)"
            [hero]="currentHero"></hero-detail>

        when the "deleteRequest" event fires, Angular calls the parent 
        component's "deleteHero(..)" method, passing the hero-to-delete 
        in the $event variable.





    Event Binding (@Output)  
    .......................

      @Output() eventName = new EventEmitter();  
    or
      <button (click)="onClicked()">Click Me</button>

      onClicked() {
        alert('it worked');
      }

    Binding to Custom events
    ........................

      <button (click)="onClicked()">Click Me!</button>

      @Output() clicked = new EventEmitter<string>();
      onClicked() {
        this.clicked.emit('It Works!');
      }

      now, to consume this custom event:

      <app-event-binding (clicked)="onClicked($event)"></app-event-binding>
      and in this component.ts:

      onClicked(value: string) {
        alert(value);
      }





two-way binding
----------------------------------------

  when developing entry forms, we often want to both display a data property
  and update that property when the user makes changes.

  ngModel implements two-way binding and is an example of an attribute directive.

    NOTE: must import FormsModule in app.module.ts

    <input [(ngModel)]="currentHero.firstName">

  the above can also be achieve with separate bindings to the <input> 
  element's "value" property and "input" event:

    <input [value]="currentHero.firstName"
           (input)="currentHero.firstName=$event.target.value" >

  ngModel hides the complexity behind its own "ngModel" input and 
  "ngModelChange" output properties:

    <input
      [ngModel]="currentHero.firstName"
      (ngModelChange)="currentHero.firstName=$event" >


          Error: Can't bind to 'ngModel' since it isn't a known property of 'input'

    in order to use two-way binding for form inputs, you need to import 
    the 'FormsModule' in your Angular module.

      also, if you are working in its module, like 'hero.module.ts', you 
      need to import 'FormsModule' in that module regardless of whether 
      it is already imported in app.module.ts:

          @NgModule({
            imports: [
              CommonModule,
              HeroRoutingModule,
              FormsModule
            ],
            declarations: [
              HeroListComponent,
              HeroDetailComponent
            ]
          })  
          export class HeroModule {}    

    and in unit tests, you need to include FormsModule in imports:

      beforeEach(async(() => {
        TestBed.configureTestingModule({
          declarations: [ HeroDetailComponent ],
          imports: [ FormsModule ]
        })
        .compileComponents();
      }));    





built-in directives
----------------------------------------
* and <template>
----------------------------------------
template reference variables
----------------------------------------
input and output properties
----------------------------------------


     


======================================================================

  components
  ----------

Components are the main way we build and specify elements and logic on the page.

In angular 1, this was done with directives/controllers/scope.  In angular2, 
all those concepts are combined into components.

Here is a simple component:

import { Component } from '@angular/core';

  @Component({
    selector: 'my-component',
    // templateUrl: './my.component.html',
    // styleUrls: ['./my.component.css']
    template: '<div>Hello my name is {{name}}. <button (click)="sayMyName()">Say my name</button></div>'
  })
  export class MyComponent {
    console.log('My name is', this.name);
  }

selector
--------

  selectors work like a CSS selector.  so if we were to have 

    <my-component>

  element in our HTML document, angular would know what to load here.. 

  You can also use "hashtag" syntax:

    selector: '#app-root'

  Now, you can reference that selector via div id:

    <div id="app-root"> 






======================================================================

  View Encapsulation
  ------------------

angular 2 emulates the concept of shadow DOM:

  an HTML element has its 'shadow' DOM

<div>
  <component _nghost-pax-1>
    <h1 _ngcontent-pax-1>... </h1>
  </component>
  <h1>won't be styled the same</h1>
</div>

  This is based on CSS Attribute Selectors.

  a[target] {
    background-color: yellow;
  }

	

==============================================================================

  angular component lifecycle
  ***************************
https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html

ngOnChanges
ngOnInit
ngDoCheck

  ngAfterContentInit
  ngAfterContentChecked
  ngAfterViewInit
  ngAfterViewChecked

ngOnDestroy



  constructor versus ngOnInit
  ---------------------------

  use constructor for DI
  use ngOnInit as signal that all bindings are setup.

constructor 

  on an ES6 class is a feature of a class itself, rather than an Angular 
  feature.   It is out of Angular's control when the constructor is 
  invoked, which means that it's not a suitable hook to let you know when
  Angular has finished initializing the component.


  suitable scenario for using the constructor

    - when we want to utilize dependency injection - essentially for 
      wiring up dependencies into the component.


ngOnInit

  by adding this lifecycle hook, Angular can fire a method once it has 
  finished setting the component up.

    - ngOnInit is purely there to give us a signal that Angular has
      finished initilizing the component.

    - the first pass at Change Detection against the properties that 
      we may bind to the component itself - e.g. when using @Input()

      due to this, the @Input() properties are available inside ngOnInit
      however, are undefined inside the constructor.

  the ngOnInit lifecycle hook is a guarantee that your bindings are readily
  available.


ngDoCheck()

  detect and act upon changes that Angular cannot or won't detect on its own.
  Called immediatly after

    ngOnChanges() on every change detection run, 

  and immediately after 

    ngOnInit() on the first run



OnChanges
------------------------------------------------------

ngOnChanges

https://dev.to/nickraphael/ngonchanges-best-practice-always-use-simplechanges-always-1feg

use this lifecycle hook to respond to changes to our @Input() variables.


  ngOnChanges(changes: SimpleChanges): void {}


Typical antipattern - ngOnChanges gets called multiple times for each Input that changes.

  ngOnChanges() {
    if (this.myFirstInputParameter) {
      this.doSomething(this.myFirstInputParameter);
    }
  }  


What is SimpleChanges

  SimpleChange {
      previousValue: any;
      currentValue: any;
      firstChange: boolean;


How can we use SimpleChanges?
-----------------------------

ngOnChanges(changes: SimpleChanges): void {
    console.log(changes['YOUR_PROP'].currentValue);
}




  ngOnChanges(changes: SimpleChanges) {
    let change = changes['myInputProperty'];

    if(!change.firstChange) {
      this.someOtherClassField(change.currentValue);  // here we set some other field to current value but ONLY when not 1st change.
    }

  }


another example


  ngOnChanges(changes: SimpleChanges) {
        console.log('OnChanges');
        console.log(JSON.stringify(changes));
 
        // tslint:disable-next-line:forin
        for (const propName in changes) {
             const change = changes[propName];
             const to  = JSON.stringify(change.currentValue);
             const from = JSON.stringify(change.previousValue);
             const changeLog = `${propName}: changed from ${from} to ${to} `;
             this.changelog.push(changeLog);
        }
    }




Always use `SimpleChanges`
------------------------------------

Better Practices
- - - - - - - - -
https://medium.com/angular-in-depth/creatively-decouple-ngonchanges-fab95395cc6e



This example creates a reusable function
- - - - - - -

https://generic-ui.com/blog/how-to-make-angular-onChanges-better


    function ifChanged(
       prop: SimpleChange,
       callback: (value: any) => void
    ): void {
       if (prop !== undefined && prop.currentValue !== undefined) {
          callback(prop.currentValue);
       }
    }


https://stackblitz.com/edit/angular-ivy-6dwdue?file=src%2Fapp%2Fhello.component.ts


    @Component({ ... })
    export class UserComponent implements OnChanges {

       @Input()
       user: User;

       constructor(private readonly service: UserService) {}

       ngOnChanges(changes: SimpleChanges) {
          ifChanged(changes.user, () => service.set(changes.user))
       }
    }


This example runs a for loop
- - - - - - - - - - - - -- - 

the changes parameter tells us which @Input() caused the call. 
SimpleChanges also happens to provide the old value of the @Input() if there has been multiple changes to that value - pretty handy.


  ngOnChanges(changes: SimpleChanges) {
    for (const propName in changes) {
      if (changes.hasOwnProperty(propName)) {
        let change = changes[propName];
        switch (propName) {
          case 'pageSize': {
            console.log(`pageSize changed to:`, change.currentValue);
          }
        }
      }
    }
  }


we should always take the SimpleChanges parameter in our ngOnChanges methods. 
Even if we only have a single @Input() on our component. 
I don't want code that assumes there will always be only one @Input().



I think that '' if (changes.hasOwnProperty(propName)) '' is useless
better to use '' if (changes[propName].currentValue) ''









Testing your implementation of onOnChanges
------------------------------------------

@Component({
  selector: 'greeter',
  inputs: ['name'],
  template: `<div>{{ greeting }}</div>`,
})
export class Greeter implements OnChanges {
  @Input() name: string;
  greeting: string;
  
  constructor() {}

  ngOnChanges(changes: SimpleChanges) {
    if (changes['name']) {
      this.data = 'Hello ' + this.name;
    }
  }
}






==============================================================================

  Twitter Bootstrap

@see angular-cli

==============================================================================

  creating a new service
  **********************

  $ ng g s <service-name> --flat --spec 

    --flat (default: true)


create config service
---------------------
$ mkdir src/app/shared
craiskin@xubi-one:~/ws/acme/iam/iam-demo-ng2-product-app $ ng g s shared/Config
installing service
  create src/app/shared/config.service.spec.ts
  create src/app/shared/config.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

create mdm product service
$ ng g s MdmProduct
installing service
  create src/app/mdm-product.service.spec.ts
  create src/app/mdm-product.service.ts
  WARNING Service is generated but not provided, it must be provided to be used


create ConfigService
--------------------

import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';

@Injectable()
export class ConfigService {
  public production: boolean = environment.production;
  public mdmProductServer: string = environment.MDM_PRODUCT_SERVER;
  public mdmProductApi: string = environment.MDM_PRODUCT_API;

  public mdmProductApiURL(): string {
    return this.mdmProductServer + this.mdmProductApi;
  }
}


Provide ConfigService in @NgModule AppModule:
---------------------------------------------

import { AppComponent } from './app.component';
import { environment } from '../environments/environment';
import { ConfigService } from './shared/config.service';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AlertModule
  ],
  providers: [ ConfigService ],
  bootstrap: [AppComponent]
})
export class AppModule {

  constructor() { }
}

use ConfigService in MdmProductService
--------------------------------------

import { Injectable } from '@angular/core';
import { ConfigService } from './shared/config.service';

@Injectable()
export class MdmProductService {

  constructor(private configService: ConfigService) { 
    console.log(`
      I'm MdmProductService, and I'm configured with ConfigService
      ConfigService.mdmProductServer: ${configService.mdmProductApiURL()}
    `);
  }

}





================================================================================

  RouterModule
  ************

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

Initial version:

app.module.ts
-------------

import { RouterModule }   from '@angular/router';


@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot([
      {
        path: 'heroes',
        component: HeroesComponent
      }
    ])
  ],   
  .
  .
  .
})
export class AppModule {
}

We use the 'forRoot' method because we're providing a configured router at the 
ROOT of the application.  

The 'forRoot' method gives us the Router service providers and directives needed
for routing and performs the initial navigation based on the current browser URL.

    RouterModule.forRoot([
      {
        path: 'heroes',
        component:HeroesComponent
      },
      {
        path: 'dashboard',
        component: DashboardComponent
      },
      {
        path: '',
        redirectTo: '/dashboard',
        pathMatch: 'full'
      }
    ])

  forRoot vs forChild
  -------------------

forRoot()
  call only in the root application module, AppModule.
  calling it in any other module, particularly in a lazy loaded module,
  is contrary to the intent and is likely to produce runtime error.

forChild

  always call RouterModule.forChild in a feature-routing module



    Router Outlet

If we paste the path "/heroes" into the browser address bar, the router should 
match it to the 'heroes' route and display the 'HeroesComponent'.

    <a routerLink="/heroes">Heroes</a>
    <router-outlet></router-outlet>


    Parameterized Route


We can add the object's id to the URL.

  /detail/11

  {
    path: 'detail/:id',
    component: HeroDetailComponent
  },  

The (:) in the path indicates that :id is a placeholder to be filled with a
specific hero id when navigating to the HeroDetailComponent

The corresponding [routerLink] for the above route would look like this:

  [routerLink]="['/detail', hero.id]" 

Here, we are binding a link parameters array:

  ['/detail',hero.id]

to our destination route:

  path: 'detail/:id'

The array has two elements:
  path of the destination route
  route parameter set to the value of the current hero's id

routerLinkActive directive
---------------------------

Angular Router provides a routerLinkActive directive to add a class to the HTML 
navigation element whose route matches the active route. Ex:

  <nav>
    <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
    <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
  </nav>

  nav a.active {
    color: #039be5;
  }  



================================================================================

  Angular built-in directives
  ***************************

There are three kinds of Angular directives:

1. Components
2. Attribute directives
3. Structural directives


Attribute Directives
---------------------


ngModel

  when developing entry forms, we often want to both display a data property
  and update that property when the user makes changes.

  ngModel implements two-way binding and is an example of an attribute directive.

    NOTE: must import FormsModule in app.module.ts

    <input [(ngModel)]="currentHero.firstName">

  the above can also be achieve with separate bindings to the <input> 
  element's "value" property and "input" event:

    <input [value]="currentHero.firstName"
           (input)="currentHero.firstName=$event.target.value" >

  ngModel hides the complexity behind its own "ngModel" input and 
  "ngModelChange" output properties:

    <input
      [ngModel]="currentHero.firstName"
      (ngModelChange)="currentHero.firstName=$event" >



===============================================================================


class and style binding
----------------------------------------------------------

https://angular.io/guide/class-binding

https://angular.io/guide/style-precedence#style-precedence


single class binding

Angular adds the class the bound expression, onSale, is truthy, and it removes it
when the expression is falsy.

  [class.sale]="onSale"


multiple class binding

  [class]="classExpression"



ngClass
----------------------------------------------------------

ngClass is a directive in Angular that adds and removes CSS classes on an HTML element.


Property binding and interpolation:

  <!-- Normal HTML -->
  <input placeholder="some text">

  <!-- Interpolation -->
  <input placeholder="{{ variable }}">  

  <!-- Property Binding -->
  <input [placeholder]="variable">


  [ngClass]="{
    'prism-dialog-small': this.size === 'small',
    'prism-dialog-medium': this.size === 'medium',
    'prism-dialog-large': this.size === 'large'
  }"



Supports three types of expression "return values":

string, array and Object

<div [ngClass]="'first second'">
<div [ngClass]="['first', 'second']">
<div [ngClass]="{first: true, second: true, third: true}">
<div [ngClass]="{'first second': true}">



<!-- Given that val="foo", the class of the following div would be "foofoo" -->
<div [ngClass]="val + val">

<!-- Given that val="foo", the class of the following div would be "foo" -->
<div [ngClass]="[val]">

<!-- Given that func is a function that returns "foo", the class of the following div would be "foo" -->
<div [ngClass]="func()">


Using ngClass with a simple condition
--------------------------------------

  <td [ngClass]="val > 10 ? 'red' : 'green'">{{ val }}</td>

or if we want to toggle

  <input type="text" [ngClass]="control.isInvalid ? 'error' : ''" />



How to work with Object Literals and ngClass
--------------------------------------------

When we use object literals,  the 'key' represents the 'class' that are going
to configure for the element, while the 'value' represents whether the class
should be applied to the element.

The 'key' will be applied if the 'value' is truthy.

so here

  <i [ngClass]="classes"></i>

ngClass will be assigned the value of Object literal `classes` 

  get classes() {
    const cssClasses = {
      'fa': true
    }

    if (this.icon) {
      cssClasses['fa-' + this.icon] = true;
    }
    return cssClasses;
  }

so <i>  will get `fa` class (set to true) and `fa-something` class (also set to true)




===============================================================================

ngStyle

  allows us to set inline styles dynamically based on the state of the component.
  binding to ngStyle lets us set many inline styles simultaneously

  with this template:

    <div 
        id="using-ngStyle" 
        [ngStyle]="{'color': ngStyleDivColor, 'font-size': ngStyleDivFontSize + 'px', 'font-weight': 'bold'}">
      div style configured with ngStyle
    </div>
    <input [(ngModel)]="ngStyleDivColor" />
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize + 1">+</button>
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize - 1">-</button>

  we can manipulate the <div> element styles with the component state:

    export class AppComponent {

      ngStyleDivColor: string;
      ngStyleDivFontSize: number;
      spanDisplayedText: string;
      spanDisplayedTextVisible: boolean;

      constructor() {
        this.ngStyleDivColor = 'pink';
        this.ngStyleDivFontSize = 16;
        this.spanDisplayedText = 'show-class';
        this.spanDisplayedTextVisible = true;
      }
        
    }

===============================================================================

  angular component styles
  ************************

/deep/
>>> 

  component style normally applies only to the component's own template. Using /deep/ selector we can force a style down through the child component tree into all child component views. /deep/ selector forces its style to its own component, child component, nested component, view children and content children. Suppose we have components with parent child relationship as follows. 

    PersonComponent -> CompanyComponent -> AddressComponent

  In PersonComponent we are using following CSS file with /deep/ selector. 
  >>> will force PersonComponent style to Company and Address component.

NOTE: as of 11.2017:
https://angular.io/guide/component-styles
The shadow-piercing descendant combinator is deprecated and support is being removed from major browsers and tools. As such we plan to drop support in Angular (for all 3 of /deep/, >>> and ::ng-deep). Until then ::ng-deep should be preferred for a broader compatibility with the tools.




===============================================================================


Structural Directives
---------------------

  structural directives like ngIf do their magic by using HTML 5 template tag.



ngIf

  conditionally includes a template based on the value of an expression.

  element subtree is physically removed or added to the DOM.

    <div *ngIf="condition">...</div>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.
    The <div> containing "Text to show" is removed or added to the DOM based
    on the value of var 'show'.

      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show">Text to Show</div>


  safe navigation operator

    <table class='table' *ngIf='products?.length'>

      // safe navigation operator returns 'null' if the value is null 
      // and does not evaluate the expression 

    </table>



with else

    <div *ngIf="condition; else elseBlock">...</div>
    <ng-template #elseBlock>...</ng-template>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.  
    The <div> containing "Text to show" will either display "primary" text if 
    variable 'show' is true, or alternate - if false.


      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show; else elseBlock">Text to Show</div>
      <ng-template #elseBlock>Alternate text while primary is hidden</ng-template>


    <div *ngIf="isValid;else other_content">
    content here ...
    </div>

    <ng-template #other_content>other content here...</ng-template>

 also `then else`:


  <div *ngIf="isValid;then content else other_content">here is ignored</div>    
  <ng-template #content>content here...</ng-template>
  <ng-template #other_content>other content here...</ng-template>


or `then` alone:

  <div *ngIf="isValid;then content"></div>    
  <ng-template #content>content here...</ng-template>




with async

    <button (click)="nextUser()">Next User</button>
    <br>
    <div *ngIf="userObserbable | async as user; else loading">
      Hello {{user.first}} {{user.last}}!
    </div>
    <ng-template #loading let-user>Waiting ... (user is {{user|json}})
    </ng-template>


  

  NOTE: visibility (hiding) and ngIf are not the same!

    we can show/hide an element subtree with a class or style binding.
    when we hide the element subtree, it remains in the DOM.  the subtree may
    tie up substantial memory and resources.

    when ngIf is false, Angular physically removes the element subtree from the DOM.
    it destroys components in the subtree potentially freeing up resources and
    resulting in better performance.

    on the flip side, when ngIf becomes true again, the component will be 
    recreated along with its subtree.  This may be expensive.. 

      Design thought: minimize initialization effort and consider caching state
      in a companion service.


ngSwitch

  ~~  do NOT put an (*) in front of ngSwitch ~~  
  use property binding instead.

  ~~ do use (*) with ngSwitchCase and ngSwitchDefault.

  when we want to display one element tree (and its children) from a set of 
  possible element trees, based on some condition.

  Angular puts on the selected element tree into the DOM.

  <span [ngSwitch]="toeChoice">
    <span *ngSwitchCase="'Eenie'">Eenie</span>
    <span *ngSwitchCase="'Meanie'">Meanie</span>
    <span *ngSwitchCase="'Miney'">Miney</span>
    <span *ngSwitchCase="'Moe'">Moe</span>
    <span *ngSwitchDefault>other</span>
  </span>


  we bind the parent NgSwitch directive to an expression returnng a switch value.
  the value is string in this example but it could be anything.

  at any particular time, at most ONE of these spans is in the DOM.

  if none of the spans is a match, Angular adds the default span to the DOM.. 
  and removes and destroys all other spans.

  Three collaborating directives work together here:

    ngSwitch
    ngSwitchCase
    ngSwitchDefault





ngFor
  
  is a repeater directive - our goal is to represent a list of items.
  we define a block of HTML that defines how  a single item should be 
  displayed - and we tell angular to use that block as template for rendering 
  each item in the list.

    ngFor applied to a simple <div>:

      <div *ngFor="let hero of heroes">{{hero.fullName}}</div>

    ngFor applied to a component element

      <hero-detail *ngFor="let hero of heroes" [hero]="hero"></hero-detail>



* and <template>

  the (*) is a bit of syntactic sugar that makes it easier to read and write 
  directives that modify HTML layout with the help of templates.

  NgFor, NgIf, and NgSwitch all add and remove element subtrees that are wrapped
  in <template> tags.

  This is how Angular expands *ngIf for example:

    <hero-detail *ngIf="currentHero" [hero]="currentHero"></hero-detail>

  1st expansion:

    <hero-detail 
        template="ngIf:currentHero" [hero]="currentHero"></hero-detail>    

  2d expansion:

    <template [ngIf]="currentHero">
      <hero-detail [hero]="currentHero"></hero-detail>
    </template>


ngFor with Index
----------------

https://www.angularjswiki.com/angular/how-to-get-index-of-element-in-ngfor-angular/


     this.books = [
        {id:1,name:"Angular"},
        {id:2,name:"Typescript"},
        {id:3,name:"Javascript"},
        {id:4,name:"HTML"}
     ];



  <ul>
      <li *ngFor="let book of books; let indexOfelement=index;">
        ngFor index: {{indexOfelement}} value : {{book.name}} 
      </li>
  </ul>

or  `i` instead of indexOfElement:

  <ul>
      <li *ngFor="let book of books; index as i">
        ngFor index: {{indexOfelement}} value : {{book.name}} 
      </li>
  </ul>






Custom Attribute directives 

  HostListener
  HostBinding 
    class decorators
    prefer using these to the 'host' property of the @Directive and @Component decorators



HostBinding('value') myValue;     // is exactly the same as [value]="myValue"


HostListener('click') myClick(){ } // is exactly the same as (click)="myClick()"

================================================================================

  @HostBinding
  ************


function decorator 
allows you to set properties of the host element from the directive class.

@HostBinding() decorator takes one parameter - the name of the host element property 
which value we want to assign in the directive.



How I understood @HostBinding in Directives
https://medium.com/geekculture/how-i-understood-hostbinding-in-directives-34f4d64b6ec1

@HostBinding and Renderer2 are two good ways to manipulate the DOM without directly accessing it.


@HostBinding can manipulate the properties, attributes and classes of a DOM element.

Example 1: Toggle a class
----------






use @HostBinding to set class on host component
-----------------------------------------------


  @HostBinding('class.left-bar') leftBarClass = true;
  
or

  @HostBinding('class') leftBarClass = 'left-bar';


use of 

  host: { 'class': 'left-bar' },

is discouraged


================================================================================

  Applications Styles
  *******************

When we add styles to a component, we're keeping everything a component needs -
HTML, the CSS, the code - together in one convenient place.

We can also create styles at the application level outside of any component.

angular-cli provides styles.css at the index.html level and it's already 
integrated into the project via 

angular-cli.json:

      "styles": [
        "styles.css"
      ],

styles.css - allows users to add global styles and supports CSS imports

  if the project is created with the --style=sass option, this will be a
  .sass file instead and the same applies to scss/less/style.

You can add more global styles via the apps[0].styles property in
angular-cli.json


================================================================================

  go back browser back button
  ***************************

Go back button in Angular. Save route history.
----------------------------------------------

https://medium.com/quick-code/go-back-button-in-angular-save-route-history-in-angular-374f28c4a793


How to Navigate to Previous Page in Angular
https://nils-mehlhorn.de/posts/angular-navigate-back-previous-page


================================================================================    

  Guard Services
  **************
https://angular.io/docs/ts/latest/guide/router.html#guards  


================================================================================

  Caching Service options
  ***********************

ng2-cache
https://www.npmjs.com/package/ng2-cache
https://github.com/Jackson88/ng2-cache


angular2-cache





================================================================================

  Change Detection Strategies
  ***************************

  Default                           On Push

  uses default checkAlways          Improves performance by minimizing change
  every component is checked when   detection cycles
  any change is detected
                                    Component is only checked when:
                                      @Input properties change,
                                      Event emits, or
                                      a bound Observable emits

You set changeDetection strategy via a decorator:


  @Component({
    templateUrl: 
    changeDetection: ChangeDetectionStrategy.OnPush
  })


IMPORTANT: with OnPush, the template will not update (it won't check the Component)
unless:

  @Input properties change, or
  Event emits, or
  a bound Observable emits



OnPush — your new Default

https://medium.com/angularwave/onpush-your-new-default-ba3fd5bc9f6e

Container-Presentation pattern

https://indepth.dev/posts/1478/designing-angular-architecture-container-presentation-pattern


================================================================================

  Declarative Data Retrieval Strategy
  ***********************************

Contrast with a procedural approach:

  In the service, we have a procedure defined:

    getProducts(): Observable<Product[]> { ... }

  In the component, we call that procedure:

    ngOnInit() {
      this.product$ = this.productService.getProducts() ...
    }

To make the above more declarative

  In the service, define a property that stores the result of HTTP GET

    products$ = this.http.get<Product[]>(this.productsUrl);


  In the component, assign a local property for the observable property in the service.

    products$ = this.productService.products$;



================================================================================

  RxJS with Angular
  *****************

template access
----------------------------------------------

Async Pipe

  Benefits of using an async pipe:
    - no need to subscribe
    - no need to unsubscribe
    - improve change detection





  can be used to access an observable directly in a template

    "product$ | async"
    
  automatically subscribes to the Observable when component is init'd

  returns each emitted value from the Observable

  when a new item is emitted, component is marked to be checked for changes

  unsubscribes when component is destroyed 


Typical data retrieval pattern:


  products: Product[] = [];

  constructor(private productService: ProductService) {}

  ngOnInit() {
    this.productService.getProducts()
      .subscribe(products => this.products = products);
  }


    <div class="table-responsive">
      <table class="table mb-0"
             *ngIf="products">
        <thead>
          <tr>
            <th>Product</th>
            <th>Code</th>
            <th>Category</th>
            <th>Price</th>
            <th>In Stock</th>
          </tr>
        </thead>
        <tbody *ngFor="let product of products">
          <tr>
            <td>{{ product.productName }}</td>
            <td>{{ product.productCode }}</td>
            <td>{{ product.categoryId }}</td>
            <td>{{ product.price | currency:"USD":"symbol":"1.2-2" }}</td>
            <td>{{ product.quantityInStock }}</td>
          </tr>
        </tbody>
      </table>
    </div>





and here it is exposing observable to the template:

  products$: Observable<Product[]>;

  constructor(private productService: ProductService) {}

  ngOnInit() {
    this.products$ = this.productService.getProducts();
  }

and in the template replace this 


        <table class="table mb-0"
             *ngIf="products">

with

        <table class="table mb-0"
             *ngIf="products$ | async as products">




================================================================================

  Wait for subscribe to finish before returning data
  --------------------------------------------------

asynchronous function in a service returns an Observable - does not subscribe.

  public getUser(): Observable<User> {
      return this.http.get<User>(environment.apiRoot + '/me');
  }

in the outer scope, in your component - you subscribe

  this.userService.getUser().subscribe(user => {
      console.log(user)
  });

Better yet, in your component, create an Observable variable

  this.user$ = this.userService.getUser();

and use async pipe in your template which will subscribe / unsubscribe for you

  <span>Hello, my name is {{user$ | async}}!</span>


================================================================================

  Caching with RxJs Observables in Angular 2
  ******************************************

http://www.syntaxsuccess.com/viewarticle/caching-with-rxjs-observables-in-angular-2.0

http://restlet.com/blog/2016/04/12/interacting-efficiently-with-a-restful-service-with-angular2-and-rxjs-part-2/

http://stackoverflow.com/questions/36271899/what-is-the-correct-way-to-share-the-result-of-an-angular-2-http-network-call-in



================================================================================

  Forms
  *****

Debugging forms with `spy` template reference variable
---------------------------

https://angular.io/guide/forms

Temporarily add a template reference variable named spy to the Name <input> tag and use it to display the input's CSS classes.

  <input type="text" class="form-control" id="name"
    required
    [(ngModel)]="model.name" name="name"
    #spy>
  <br>TODO: remove this: {{spy.className}}


================================================================================

  Dependency Injection (DI)
  *************************

There are several ways we can configure resovling injected dependencies in
Angular:

1. Inject a (singleton) instance of a class
2. Inject a `value`
3. Call any function and inject the return value of that function


1. Using a Class
-------------

@NgModule({
  imports: [
    CommonModule
  ],
  providers: [
    UserService // <-- added right here
  ],
  declarations: []
})

providers: [UserService]

  is a shorthand for 

providers: [{ provide: UserService, useClass: UserService }];


2. Using a Value
--------------

providers: [{ provide: "API_URL", useValue: "http://my.api.com/v1" }];


export class SomeApiConsumerComponent {
  constructor(@Inject("API_URL") apiUrl: string) {
    // works!!
  }
}


3. Configurable Service using Factories
---------------------------------------






================================================================================

  Error Handling
  **************

https://angular.io/api/core/ErrorHandler  

Catching global errors
----------------------

  https://stackoverflow.com/questions/44108285/angular-4-custom-errorhandler-doesnt-recognize-custom-error
  https://dpopescu.me/2016/10/21/catching-global-errors-in-angular-2/


================================================================================

  require
  *******

Typescript ERROR in build-info.ts (3,12): Cannot find name 'require'.

Cannot find name 'require'

Do you need to install type definitions for node? 
Try `npm i @types/node` and then add `node` to the types field in your tsconfig


declare const require: any;  // add this line

export const build = {
  timestamp: new Date().toLocaleString(),
  version: require('../../package.json').version
};


add the following to tsconfig.app.json:

    "types": ["node"],
    "typeRoots": [ "../node_modules/@types" ]


remove from tsconfig.json

  "types": []

or add

  "types": ["node"]


================================================================================

  Add build version to your application
  *************************************

.deploy/build-info.ts
----------------------

import {BuildInfo} from '../src/app/shared/models/build-info.model';

declare const require: any;

export const buildInfo: BuildInfo = {
  timestamp: new Date().toLocaleString(),
  version: require('../package.json').version
};


environments/environment.ts
---------------------------

import { buildInfo } from '../../.deploy/build-info';

export const environment = {
  production: false,
  buildInfo: buildInfo
};


environments/environment.prod.ts
---------------------------

export const environment = {
  production: true,
  buildInfo: undefined
};

shared/models/build-info.model.ts
----------------------------------

export interface BuildInfo {
  timestamp: string;
  version: string;
}



footer.component.ts
-------------------

import { environment } from '../../environments/environment';
import {BuildInfo} from '../shared/models/build-info.model';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent implements OnInit {

  buildInfo: BuildInfo;

  constructor() { }

  ngOnInit() {
    this.buildInfo = environment.buildInfo;
  }
}


footer.component.css
--------------------

/** build-info */
.build-info-container {
  position: relative;
  display: inline-block;
}
.build-info-container .build-info-text {
  visibility: hidden;
  width: 200px;
  line-height: 10px;
  font-size: 10px;
  background-color: #f2f2f2;
  color: #373737;
  text-align: left;
  border: 1px solid #121212;
  border-radius: 6px;
  padding: 2px 5px 2px 5px;
  /* position */
  position: absolute;
  z-index: 1;
  top: 60%;
  left: 50%;
  margin-left: -100px;
}
.build-info-container:hover .build-info-text,
.build-info-container:active .build-info-text {
  visibility: visible;
}
/** end build-info */



footer.component.html
----------------------

<div class="container">
  <div class="app-footer-container">
    <div class="copyright pull-left build-info-container">
      <p>&copy; 2017</p>
      <div *ngIf="buildInfo" class="build-info-text">
        <span>build.timestamp: {{buildInfo.timestamp}}</span><br>
        <span>build.version: {{buildInfo.version}}</span>
      </div>
    </div>
  </div>
</div>



================================================================================

  Centralized Store Pattern
  *************************

  Angular Ngrx Store 

http://blog.angular-university.io/angular-ngrx-store-and-effects-crash-course/  

Other references:
https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/
https://www.bersling.com/2017/06/05/state-management-ngrxstore-vs-angular-services/


NOTE: if NgRx or Redux is overkill - try @angular-extensions/model  library.



origins: facebook counter bug

  unread messages counter was displaying incorrect results.

Every UI app has either implicitly or explicitly two types of data:

  - a Model, or Doman Model
  - a View Model

Model vs View Model

  what we see on the screen is not the Model, it is the View Model.
  sometimes, the View Model has a direct correspondence with the model,
  but most often they are two different models.

  there is also an extra bit of state is purely UI-only - e.g. which 
  element is currently selected.  


Centralized Store design Pattern
--------------------------------

  instead of transforming the Model into the View Model on the server
  as it is usually done, let's instead copy the Model to the client-side,
  keep it in in-memory client database and derive View Models last second
  on the client side instead of doing so upfront on the server.

  1. create a client-side in-memory database for the application data
  2. bring the real domain data, the Model, to the f/e
  3. keep that Model data which is a user-specific slice of the DB
     in that in-memory DB
  4. put the client-side in-mem DB inside a centralized service (Store)
  5. ensure the centralized service owns the data by either ensuring
     its encapsulation or exposing it as immutable
  6. this centralized service will have reactive properties, so we can
     subscribe to it to get notified when the Model data changes.


  View Models are produced 

    - each component that needs to produce a View Model of the data will
      subscribe to get new versions of the in-mem DB data

    - each component will upon reception of the Model data produce 
      its own View Model, last second at the component level.

    - ensure that all View Models are always in sync with the centralized
      Data Model

    - transformation from Model to View Model is done last second on the 
      View Root itself, not on the server

    - transformation from view to view Model is done via a function called
      a Selector - the input of a Selector is the Model, and the output
      is the View Model

  How the Model data in the Store is modified

    - the data can only be modified inside the centralized service by 
      the Store itself

    - if a component wants to trigger modifications of the data, it sends
      a message to the centralized service using an Action object

    - the emitter of the action doesn't know which parts of the application
      will be affected by the action

    - new version of the application Model state is produced by taking
      the previous state and the action and applying Reducer function

    - Reducer function can be split into multiple smaller functions
      each modifying a part of the state

    - when the new state Model is avilable, it get broadcast to all 
      interested components, which will then transform it into their 
      View model

    - the new state model is frozen before getting broadcast so that
      the subscribers cannot modify it

================================================================================

  Content Projection
  ******************

what problem is it solving?
---------------------------

say, we have JokeComponent .. 

    @Component({
      selector: 'joke',
      template: `
    <div class="card card-block">
      <h4 class="card-title">{{ data.setup }}</h4>
      <p class="card-text" [hidden]="data.hide">
        {{ data.punchline }}
      </p>
      <button class="btn btn-primary"
        (click)="data.toggle()">Tell Me</button>
    </div>
      `
    })
    class JokeComponent {
      @Input('joke') data: Joke;
    }

and JokeListComponent

    @Component({
      selector: "joke-list",
      template: `
    <joke-form (jokeCreated)="addJoke($event)"></joke-form>
    <joke *ngFor="let j of jokes" [joke]="j"></joke>
    `
    })
    class JokeListComponent {
      jokes: Joke[];
      .
      .
    }


  let's say someone else wanted to use our <JokeComponent> but instead of 
  displaying it in a <p> tag they wanted to display the punchline
  in a larger <h1> tag.

  right now, the JokeComponent does not allow this type of customization.


  We can design our component with something called "content projection" 
  to enable it to be customised by the component or developer who is using
  it.


ng-content
-----------------

Content Projection

when we add 

  <ng-content></ng-content>

anywhere in our template HTML for our component, the inner content of the tags
that define our component are oftent `projected` into this space.

So if we changed the template of the "JokeComponent" to be:

  <div class="card card-block">
    <h4 class="card-title">{{ data.setup }}</h4>
    <p class="card-text" [hidden]="data.hide">
      <ng-content></ng-content>
    </p>
    <button class="btn btn-primary"
      (click)="data.toggle()">Tell Me</button>
  </div>

and the JokeListComponent template to this

    <joke-form (jokeCreated)="addJoke($event)"></joke-form>
    <joke *ngFor="let j of jokes" [joke]="j">
      <h1>{{ j.punchline }}</h1>
    </joke>


This is called CONTENT PROJECTION -> we project content from 
the PARENT component to the CHILD component.



multi-slot content projection
-----------------------------

https://stackoverflow.com/questions/52638718/multiple-ng-content



A component can have multiple slots. 
Each slot can specify a CSS selector that determines which content goes into that slot. 

you must specify where you want the projected content to appear. 
You accomplish this task by using the select attribute of <ng-content>.

1. create a component
2. in the template of your component, add an `<ng-content>` element where you 
   want the projected content to appear

3. add a "select" attribute to the `<ng-content>` elements.

NOTE: If your component includes an <ng-content> element without a select attribute, 
that instance receives all projected components that do not match any of the other <ng-content> elements.



Examples:

https://angular.io/guide/content-projection#multi-slot-content-projection


@Component({
  selector: 'app-zippy-multislot',
  template: `
    <h2>Multi-slot content projection</h2>

    Default:
    <ng-content></ng-content>

    Question:
    <ng-content select="[question]"></ng-content>
  `
})


app.component.html:
------------------

<app-zippy-multislot>
  <p question>
    Is content projection cool?
  </p>
  <p>Let's learn about content projection!</p>
</app-zippy-multislot>



https://stackoverflow.com/questions/52638718/multiple-ng-content

You could add dummy attributes header and body as opposed to template references (#header, #body).
And transclude using ng-content with select attribute like select="[header]".


app.comp.html

<app-child>
    <div header >This should be rendered in header selection of ng-content</div>
    <div body >This should be rendered in body selection of ng-content</div>
</app-child>


child.comp.html

<div class="header-css-class">
    <ng-content select="[header]"></ng-content>
</div>
<div class="body-css-class">
    <ng-content select="[body]"></ng-content>
</div>


slot="start"
slot="end"




================================================================================

  detecting whether <ng-content> is empty
  ---------------------------------------


using :empty

https://stackoverflow.com/questions/35107211/how-to-check-whether-ng-content-is-empty-in-angular-2-till-now


<div class="wrapper">
    <ng-content select="my-component"></ng-content>
</div>
<div class="default">
    This shows something default.
</div>


CSS

.wrapper:not(:empty) + .default {
    display: none;
}


be aware: 

Be aware of, that having at least one whitespace is considered to not beeing empty. Angular removes whitespace, but just in case if it is not:

<div class="wrapper"><!--
    --><ng-content select="my-component"></ng-content><!--
--></div>

or

<div class="wrapper"><ng-content select="my-component"></ng-content></div>


================================================================================


  ng-template
  ------------


4 ways we can access ng-template


1.  ngIf
---------

<ng-container *ngIf="showPrimary; then primary else secondary">
</ng-container>

<ng-template #primary>
  <div>
    <button class="btn btn-primary">Primary</button>
  </div>
</ng-template>

<ng-template #secondary>
  <div>
    <button class="btn btn-secondary">Secondary</button>
  </div>
</ng-template>



ng-template variables
---------------------

you can define variables on `ng-template` thru  `let-name`

using $implicit in the context object will set its value as default


================================================================================


  ngTemplateOutlet
  ****************


it is a structural directive.
we use it to insert a template (created by ngTemplate)

you can define a few templates to display an item and use them display at several places in the View and also swap that template as per the user’s choice.





Passing data to ngTemplateOutlet
-------------------------------


The following code creates a template. We name it as messageTemplate. 
The let-value creates a local variable with the name value


  <ng-template let-value="value" #messageTemplate>  
      <p>Value Received from the Parent is  {{value}}</p>
  </ng-template>


We can pass any value to the value using the ngTemplateOutletContextproperty


  <ng-container [ngTemplateOutlet]="messageTemplate" 
         [ngTemplateOutletContext] ="{value:'1000'}">
  </ng-container>  


Alternatively you can also use the following syntax.

  <ng-container *ngTemplateOutlet="messageTemplate; context:{value:100}">
  </ng-container> 


Pass more than one value


  <ng-template let-name="nameVar" let-message="messageVar" #template3>  
    <p>Dear {{name}} , {{message}} </p>
  </ng-template>
   
   
  <ng-container [ngTemplateOutlet]="templates" 
            [ngTemplateOutletContext] ="{nameVar:'Guest',messageVar:'Welcome to our site'}">
  </ng-container> 


Using $implicit
-----------------


If you use the key $implicit in the context object will set its value as default for all the local variables.

For Example we have not assigned anything to the let-name so it will take the value from the $implicit, which is Guest.


  <ng-template let-name let-message="message" #template3>  
    <p>Dear {{name}} , {{message}} </p>
  </ng-template>
   
  <ng-container [ngTemplateOutlet]="templates" 
                [ngTemplateOutletContext] ="{$implicit:'Guest',message:'Welcome to our site'}">
  </ng-container> 




================================================================================

3. @ViewChild and ViewContainerRef  
--------------------------------------


https://blog.angular-university.io/angular-viewchild/

The Angular @ViewChild decorator is one of the first decorators that you will run into while learning Angular, 
as it's also one of the most commonly used decorators.



Q: I want to access the DOM of a component using ViewChild. But when I try to access the nativeElement property, it's undefined.

https://stackoverflow.com/questions/45921819/angular-nativeelement-is-undefined-on-viewchild


  <app-alert #alert>
    My alert
  </app-alert>
  <button (click)="showAlert()">Show Alert</button>`


export class AppComponent implements AfterViewInit {
  @ViewChild('alert') alert;

  showAlert() {
    console.log('alert (showalert)', this.alert.nativeElement);
    this.alert.show();
  }

  ngAfterViewInit() {
    console.log('alert (afterviewinit)', this.alert.nativeElement);
  }
}



A:

  If you want to get a reference of an element that hosts a component or directive 
  you need to specify that you want the element instead of the component or directive

  In Angular, there's a DOM element that hosts the component, and then there's the component itself.


  export class AppComponent implements AfterViewInit {
    @ViewChild('alert') alert;
    @ViewChild('alert', {read: ElementRef}) alertElement:ElementRef;

    showAlert() {
      console.log('alert (showalert)', this.alertElement.nativeElement);
      this.alert.show();
    }
    
    ngAfterViewInit() {
      console.log('alert (afterviewinit)', this.alertElement.nativeElement);
    }
  }



The AfterViewInit Lifecycle Hook
--------------------------------

The value of this injected member variable is not immediately available at component construction time!

If we want to write component initialization code that uses the references injected by @ViewChild, we need to do it inside the AfterViewInit lifecycle hook.



  @ViewChild(ColorSampleComponent)
  primarySampleComponent: ColorSampleComponent;

  ngAfterViewInit() {
    console.log('Values on ngAfterViewInit():');
    console.log("primaryColorSample:", this.primarySampleComponent);
  }  



What is the scope of @ViewChild template queries?
using @ViewChild to inject a component
how to use @ViewChild to inject a plain HTML element
using @ViewChild to inject the plain HTML element of a component
how to use @ViewChild to inject one of the multiple directives applied to a single element or component



<ng-container #placeholder>

</ng-container>

  @ViewChild('placeholder', { read: ViewContainerRef, static: true }, )
  public container!: ViewContainerRef;
  @ViewChild('primary', { static: true })
  public primary!: TemplateRef<any>;

  ngAfterViewInit(): void {
    this.container.createEmbeddedView(
      this.primary,
      {
        text: 'Primary',
        them1: 'btn-primary'
      },);
  }


  ERROR: Expression Changed After It Has Been Checked

  this is because the context (text and theme) are being set AFTER view initialization.

  add "static" option so ViewChild is available during ngOnInit()

  and move createEmbeddedView to ngOnInit



When should I use static:true vs static:false?
------------------------------------------------

https://stackoverflow.com/questions/56359504/how-should-i-use-the-new-static-option-for-viewchild-in-angular-8



So as a rule of thumb you can go for the following:

{ static: true } needs to be set when you want to access the ViewChild in ngOnInit.

{ static: false } can only be accessed in ngAfterViewInit. This is also what you want to go for when you have a structural directive (i.e. *ngIf) on your element in your template.



static property informs angular about the availability of our child

For example: if static is set to true, we are informing angular our child is available on the page from the beginning ( meaning it is not dependent of *ngIf,page bindings,API calls etc) so angular looks for it at the earliest lifecycle hook ( ngOnInit) and never looks for it again

In case we set static to false we are informing angular that our child is dependent on some conditional directives, so angular tries to look for our child after every change detection cycle and if it is available we can access it in ngAfterViewInit() life cycle hook



Dealing with ExpressionChangedAfterItHasCheckedError
****************************************************

https://stackoverflow.com/questions/71978152/how-can-i-fix-this-specific-ng0100-expressionchangedafterithasbeencheckederror

Option 1: next macrotask (setTimeout)
Option 2: ChangeDetectorRef.detectChanges()
Option 3: fetching data in OnInit + data binding


https://blog.angular-university.io/angular-debugging/

https://blog.angular-university.io/angular-viewchild/





Option 2: ChangeDetectorRef.detectChanges()
--------------------------------------------

Inform angular to run another detection cycle after you modified the data that is displayed.

in either ngAfterViewInit() or ngAfterContentChecked()


  constructor(private changeDetectorRef: ChangeDetectorRef) {}


  ngAfterViewInit() {
    this.getData().subscribe((data) => {
      this.childSelector.loadRecipeRoadmap(data.name);
    });
    this.changeDetectorRef.detectChanges();
  }




================================================================================

  Angular libraries with schematics
  *********************************

https://github.com/caroso1222/ng-lib-schematics

================================================================================

  Angular Component Communication
  *******************************


================================================================================

Communication between hierarchical components
=============================================

across many layers of components in between without direct parent/child relationship


Mastering the Subject: Communication Options in RxJS | Dan Wahlin
https://www.youtube.com/watch?v=_q-HL9YX_pk

How pass a event from deep nested child to parent in Angular
https://stackoverflow.com/questions/56290722/how-pass-a-event-from-deep-nested-child-to-parent-in-angular-2


Event model
-----------

nav-events.model.ts
--------------------

export enum PrismNavEvents {
  logout = 'logout'
}

export interface PrismNavEvent {
  name: PrismNavEvents;
  value?: any;
}


nav-event.service.ts
-----------------------



import { Injectable } from '@angular/core';
import { Subject, Subscription } from 'rxjs';
import { PrismNavEvent, PrismNavEvents } from '../models';
import { filter, map } from 'rxjs/operators';

/**
 * PrismNavEventService provides a communication mechanism across multiple
 * layers of the nav system.
 *
 * Components emitting events use emit() method:
 *   this.navEventService.emit({
 *     name: 'logout'
 *   });
 *
 * Events are defined in PrismNavEvents enum.  This allows subscribers to
 * filter events and apply different actions based on events received.
 *
 * New event types should be added to PrismNavEvents enum.
 *
 *  Components wanting to be notified will use the on() method:
 *   this.logoutEventSubscription = this.navEventService.on(PrismNavEvents.logout, () => {
 *     this.logoutRequestEvent.emit();
 *   });
 */
@Injectable()
export class PrismNavEventService {
  private subject$ = new Subject();

  /**
   * Use this method to emit an event.
   * @param event of type PrismNavEvent (also see PrismNavEvents enum)
   */
  emit(event: PrismNavEvent) {
    this.subject$.next(event);
  }

  /**
   * Use this method to be notified of events.
   * @param event of type PrismNavEvent (also see PrismNavEvents enum)
   * @param action the function to be executed when the event is received.
   * Typically, it's an anonymous function like so
   *   () => console.log('I'm a helpful little fn.')
   */
  on(event: PrismNavEvents, action: any): Subscription {
    return this.subject$
      .pipe(
        filter((e: PrismNavEvent) => e.name === event),
        map((e: PrismNavEvent) => e.value)
      )
      .subscribe(action);
  }
}


You want to emit an event from Child 3
---------------------------------------


export class Child3Component implements OnInit {

  constructor(public eventservice : EventService ) {}

  private emitLogoutEvent(): void {
    this.navEventService.emit({
      name: PrismNavEvents.logout
    });
  }

}



now, your parent compnent can call this method to get the event


 export class ParentComponent implements OnInit {

    constructor(public eventservice : EventService ) {}
 
    ngOnInit(): void {
      this.logoutEventSubscription = this.navEventService.on(PrismNavEvents.logout, () => {
        this.logoutRequestEvent.emit();
      });
    }
 
 }




================================================================================

Communicating with a Template
------------------------------

to notify component of changes in the template


  Two-way binding - the long way:
  -------------------------------

  <input type='text'
         [ngModel]='listFilter' // ngModel binding directive binds ngModel to 
                                // to component' `listFilter` property
          (ngModelChange) = 'onFilterChange($event)'/>
                                // ngModelChange event is then bound to
                                // a function


  communicating with getters/setters
  ----------------------------------

    component: 

    private _listFilter: string;


    get listFilter(): string {
      return this._listFilter;
    }

    set listFilter(value: string) {
      this._listFilter = value;
      this.performFilter(this._listFilter);
    }

    template:

    <input type='text'
      [(ngModel)]='listFilter' />

  angular two-way binding communicates with the component using the exposed
  getter/setter by convention.



  ViewChild
  ------------------------------

  DOM
    let divElement = document.getElementById('divElement');

  Angular Decorator
    @ViewChild('divElementVar') divElementRef: ElementRef;

          <div #divElementVar>{{pageTitle}}</div>


    The selector could also be 

      - angular diretive like `ngModel`

      @ViewChild(NgModel) filterInput: NgModel;

        the ViewChild decorator then looks in the template for the specified 
        directive:

          <input type='text' [(ngModel)]='listFilter' />

      - a child component or a custom directive

      @ViewChild(StarComponent) star: StarComponent;

        the ViewChild decorator then looks in the template for the custom 
        directive or child component of the defined type:

          <pm-star [rating] = 'product.starRating'></pm-star>

      - template reference variable

      @ViewChild('divElementVar') divElementRef: ElementRef;

          <div #divElementVar>{{pageTitle}}</div>


  ViewChildren
  ----------------------------


      - angular directive
        @ViewChildren(NgModel) inputs: QueryList<NgModel>;

      - custom directive or child component
        @ViewChildren(StarComponent) stars: QueryList<StarComponent>;

      - template reference variable(s)
        @ViewChildren('divElementVar') divElementRefs: QueryList<ElementRef>;



  communicating with @ViewChild
  ------------------------------


  component

    using template reference variable: #filterElement:

    @ViewChild('filterElement') filterElementRef: ElementRef;

    /* setting focus on this DOM element */
    ngAfterViewInit(): void {
      this.filterElementRef.nativeElement.focus();
    }


  template

    <input type='text' #filterElement
          [(ngModel)] = 'listFilter' />



          Component lifecycle:  
            Component Constructed -> Initialized
            Component's View Initialized -> Rendered

            when in the Component's constructor, the View is not yet rendered


            ngAfterViewInit() 
              executes after component's view is initialized and rendered
              this is where we can reliable use a property 
              with ChildView decorator.


  Note: when using ViewChild to access nativeElement:

    - you're directly accessing the DOM!
    - tightly coupled to the browser
    - may not be able to use server-side rendering
    - can pose a security threat if accessing innerHtml




    Parent/Child relationship between component
------------------------------------------------

For components to have parent/child relationship, 
the parent component's template must CONTAIN the child component.

Components related via routing do NOT have parent/child relationship even if
they have child routes - i.e. if a commponent is displayed in another component
using a <router-outlet>.



Getter to communicate view state changes across components
*****************************************

  get product(): IProduct | null {
    return this.productService.currentProduct;
  }


To keep bound data in sync:

  - define a property in a service
  - bind that property in a template
  - use a getter in the component class
  - angular change detection does the rest

however, this only works for "bound" data.


Communicating thru a Service
*********************************


Managing State techniques:

  1. Property Bag

    you define a service that has simple properties that components need:

      @Injectable()
      export class ParamService {
        showImage: boolean;
        filterBy: string;
      }

2. Basic State Management

    a service that retrieves, manipulates, inserts, deletes .. app state

      @Injectable() 
      export class ProductService {

        private products: IProduct[];

        getProducts() {}
        getProduct(id: number) {}
        createProduct(product: IProduct) {}
        . . .

      }

3. State Management With Notifications

    with notifications using Subject, BehaviorSubject or similar

      @Injectable()
      export class ProductService {
        private selectedProduct: IProduct;

        private selectedProductSource = new BehaviorSubject<IProduct>();

        selectedProductChanges$ = this.selectedProductSource.asObservable();
      
        . . .
      }


4. ngrx / Redux


    ngrx is based on 4 core tenets:

      4.1 state: immutable
      4.2 actions: state changes
      4.3 reducers: state + action = new state
      4.4 store: 
              Observable of state
              Observable of actions



Using Property Bag service
---------------------------

When user makes selections, those values are stored in the component.
When user navigates away from the component, it is destroyed.
When user returns to it, it is re-initialized with default values and it has
no memory of user selections.

If a service is introduced, user selections would be stored in the service, 
which is now used to maintain the state of user selections.

  @Injectable()
  export class ProductParameterService {

    showImage: boolean;
    filterBy: string;

    constructor() { }

  }


component:

    constructor(
      private productParameterService: ProductParameterService) {
    }

    get showImage(): boolean {
        return this.productParameterService.showImage;
    }

    set showImage(value: boolean) {
        this.productParameterService.showImage = value;
    } 

In the component, class property `showImage` is replaced with getter/setter
which in turn delegate to the service to read/update the property.

Property bag retains the values when the component is destroyed.

However, 

  property bag service can communicate changes to components ONLY if they 
  use template property binding.


Service scope and lifetime
---------------------------

  Service can be registered in the  `providers` array of a component or a module.

  where we register, defines the service' scope and lifespan.

    component: 

      @Component({
        . . .
        providers: [
          ProductService
        ]
      })

    the service is available to the component and all of its children.

- if you register the service in the Root App Component, the service will be
  retained for the life of the application.

- if you register a service in a non-root component, it will be available to
  it all of its children, and it will be retained ONLY while that component is
  loaded.

- if you register a service in two different components, you will get two 
  different instances of the service.

  To monitor the scope and lifecycle of a service:

    @Injectable()
    export class SomeService implements OnDestroy {

      constructor() {
        console.log('Service created');
      }

      ngOnDestroy() {
        console.log('Service destroyed');
      }
    }

- if you register a service in a module, the service is registered in the app's
  root, so it is available to all components in the application 
  for the lifetime of the application.

  however, if the module is lazy-loaded, the service will be available only 
  to the components in that module.  once the module is loaded, it is availble
  for the lifetime of the application.


Data Access Service
-----------------------

data access service could be a pass-thru for components to a backend server,
however in many cases, it is a state management service sharing entity state
across components and services.

service properties become a data cache.

purpose of State Management Service:

- provide state values
- maintain and update state
- observe state changes

to do that

- add a property to retain data
- optionally, add code to expire data when stale


Property Bag vs State Management Service
-----------------------------------------

 property bag to:               state mgmt service to:

  retain view Setting           retrieve, manage, store state
  pass data between component   share state between components

                                methods to encapsulate retrieve operations
                                retains and shares state values
                                provides change notifications for BOUND values with getter

                                cons:

                                  stale data
                                  need to expire
                                  consider getting fresh data before updating/deleting
                                  state is not immutable




================================================================================

  Broadcast Service Notifications
  *******************************

Push notifications

template

  user clicked on item
  <button ... (click) = 'onSelected(product)'>

component

  onSelected(product: IProduct) {
    this.productService.changeSelectedProduct(product);
  }

Service

  changeSelectedProduct(selectedProduct: IProduct) {
    // broadcast the notification -> selected product changed!!
  }

another component or service

  // listen and respond to that notification


eventEmitter?? - NO!
--------------
only supports communication between child and parent components

  @Output() valueChange: EventEmitter<string> = new EventEmitter<string>();

best practice discourages use of event emitter otherwise.



Subject or BehaviorSubject
==========================

Needed when Angular change detection for bound properties is not available.

is a special type of observable that can multicast a value or event to 
multiple subscribers.

Subject can be used to send out notifications
often encapsulated in a service

any component or service that subscribes to subject will receive notifications.

Subject is ALSO and Observer - allows us to push new data into Observable sequence.
Any component or service can feed new values into Subject using its next() method:

  this.mySubject.next(item);

the new value is then multicast to all subscribers.


Example
-----------

  template

    // button click event is captured
    <button ... (click) = 'onSelect(product)' >

  list component

    // in the service call a method, rather than setting a property on the service
    onSelect(product: IProduct) {
      this.productService.changeSelectedProduct(product);
    }

  service

    // subject is declared as private - no other code can access it directly
    private selectedProductSource = new Subject<IProduct>();

    // public Observable to expose `selectedProductSource` property as Observable
    // any other component or service can subscribe to this Observable.. 
    selectedProductChanges$ = this.selectedProductSource.asObservable();


    changeSelectedProduct(selectedProduct: IProduct) {
      this.selectedProductSource.next(selectedProduct);
    }

  subscribing component

    this.productService.selectedProductChanges$.subscribe(
      selectedProduct => this.product = selectedProduct
    )


BehaviorSubject
---------------

  works like a Subject except for two key features:

  - requires an initial value
  - provides a current value on any new subscription

  example:

      /* currently selected product */
      // Subject containing the source of selected product data
      private selectedProductSource: BehaviorSubject<IProduct>
        = new BehaviorSubject<IProduct | null>(null);
      selectedProductChanges$ = this.selectedProductSource.asObservable();

      constructor(private http: HttpClient) {
      }

      changeSelectedProduct(selectedProduct: IProduct | null): void {
        this.selectedProductSource.next(selectedProduct);
      }

      /**
       * Creates a new product item.
       * Uses `changeSelectedProduct()` to update the BehaviorSubject which 
       * will push out a notification to subscribers.
       *   
       * @param product
       * @param headers
       */
      private createProduct(product: IProduct, headers: HttpHeaders): Observable<IProduct> {
        product.id = null; // this b/c an in-mem backend is used
        return this.http.post<IProduct>(this.productsUrl, product, {headers: headers})
          .pipe(
            tap(data => {
              console.log('createProduct: ' + JSON.stringify(data));
              this.products.push(data);
              // set currently selected product to the inserted item
              this.changeSelectedProduct(data);
            }),
            catchError(this.handleError)
          );
      }

Subscribers subscribe to the BehaviorSubject


  constructor(private productService: ProductService) { }

  ngOnInit(): void {

    // subscribe to BehaviorSubject observable to get the latest data
    this.productService.selectedProductChanges$.subscribe(selectedProduct => {
        this.selectedProduct = selectedProduct;
    });

    this.productService.getProducts().subscribe(
      (products: IProduct[]) => {
        this.products = products;
      },
      (error: any) => this.errorMessage = <any>error
    );
  }

  // use the service method `changeSelectedProduct()` to update the BS Objservable
  onSelected(product: IProduct) {
    this.productService.changeSelectedProduct(product);
  }


  Preventing memory leaks with Subject subscriptions
  **************************************************

It is a good idea for subscribing components to unsubscribe from 
BehaviorSubject Observables onDestroy:

  // class variable to hold subscription
  private selectedProductSubscription: Subscription;

  ngOnInit(): void {
    // store subscription
    this.selectedProductSubscription = this.productService.selectedProductChanges$.subscribe(selectedProduct => {
        this.selectedProduct = selectedProduct;
    });

  }

  // unsubscribe onDestroy
  ngOnDestroy(): void {
    this.selectedProductSubscription.unsubscribe();
  }  


================================================================================

  Template Syntax
  ***************


# - variable declaration

() - event binding

[] - property binding

[()] - two-way property binding

{{ }} - interpolation

* - structural directives



Template Variables
-------------------

help you use data from one part of a template in another part of the template.

With template variables, you can perform tasks like respond to user input
or fine tune your application's forms.

A template variable can refer to 

- a DOM element within a template
- a directive
- an element
- TemplateRef
- web commponent


Syntax:

  <input #phone placeholder="phone number" />

here #phone declares a `phone` variable on an `<input>` element.
you can now refer to a template variable anywhere in the component's template.
Here, a `<button>` further down the template refers to the `phone` var

<button (click)="callPhone(phone.value)">Call</button>




================================================================================

File Upload
***********

https://blog.angular-university.io/angular-file-upload/

https://dzone.com/articles/how-to-implement-file-upload-in-angular

https://nils-mehlhorn.de/posts/angular-file-upload-progress

https://blog.jscrambler.com/implementing-file-upload-using-node-and-angular/

https://stackoverflow.com/questions/49798649/angular-2-9-mobile-camera-capture

https://medium.com/@tarekabdelkhalek/how-to-create-a-drag-and-drop-file-uploading-in-angular-78d9eba0b854

https://www.npmjs.com/package/ngx-file-drop



================================================================================

HttpClient
***********

Before you can use HttpClient, you need to import the Angular HttpClientModule. 
Most apps do so in the root AppModule.


  @NgModule({
    imports: [
      BrowserModule,
      // import HttpClientModule after BrowserModule.
      HttpClientModule,
    ],
    declarations: [
      AppComponent,
    ],
    bootstrap: [ AppComponent ]
  })
  export class AppModule {}


You can then inject the HttpClient service as a dependency of an application class, as shown in the following ConfigService example.


    @Injectable()
    export class ConfigService {
      constructor(private http: HttpClient) { }
    }



Always subscribe!
*****************

An HttpClient method does not begin its HTTP request until you call subscribe() on the observable returned by that method. This is true for all HttpClient methods.

The AsyncPipe subscribes (and unsubscribes) for you automatically.


In fact, each subscribe() initiates a separate, independent execution of the observable. Subscribing twice results in two HTTP requests.

  const req = http.get<Heroes>('/api/heroes');
  // 0 requests made - .subscribe() not called.
  req.subscribe();
  // 1 request made.
  req.subscribe();
  // 2 requests made.


Requesting a typed response
---------------------------

getConfig() {
  // now returns an Observable of Config
  return this.http.get<Config>(this.configUrl);
}



Making  a POST request
------------------------

/** POST: add a new hero to the database */
addHero(hero: Hero): Observable<Hero> {
  return this.http.post<Hero>(this.heroesUrl, hero, httpOptions)
    .pipe(
      catchError(this.handleError('addHero', hero))
    );
}


Tracking and showing request progress
*************************************

SOURCE: https://angular.io/guide/http#listening-to-progress-events


Sometimes applications transfer large amounts of data and those transfers can take a long time. File uploads are a typical example. You can give the users a better experience by providing feedback on the progress of such transfers.




Listening to progress events
=============================





When using HttpClient.request() with an HTTP method, configure the method with observe: 'events' to see all events, including the progress of transfers.


  NOTE: Tip: Every progress event triggers change detection, so only turn them on if you need to report progress in the UI.


To make a request with progress events enabled:
-----------------------------------------------

1. create an Instance of HttpRequest with the `reportProgress` option set `true` 
to enable tracking of progress events


  const req = new HttpRequest('POST', '/upload/file', file, {
    reportProgress: true
  });

2. Pass this request object to the HttpClient.request() method which returns
   an Observable of `HttpEvents`  


  // The `HttpClient.request` API produces a raw event stream
  // which includes start (sent), progress, and response events.

  return this.http
  .request(req)
  .pipe(
    map(event => this.getEventMessage(event, file)),
    tap(message => this.showProgress(message)),
    last(), // return last (completed) message to caller
    catchError(this.handleError(file))
  );


HttpClient  HttpEventType


  enum HttpEventType {
    Sent                  // request was SENT over the wire  
    UploadProgress        // an upload progress even was received
    ResponseHeader        
    DownloadProgress      // a download progress event was received
    Response              // full response header received - file uplaoded
    User                  // a custom event from interceptor or backend.
  }


  getEventMessage method
  ----------------------


  /** Return distinct message for sent, upload progress, & response events */

  private getEventMessage(event: HttpEvent<any>, file: File) {
    switch (event.type) {

      case HttpEventType.Sent:
        return `Uploading file "${file.name}" of size ${file.size}.`;

      case HttpEventType.UploadProgress:
        // Compute and show the % done:
        const percentDone = Math.round(100 * event.loaded / event.total);
        return `File "${file.name}" is ${percentDone}% uploaded.`;

      case HttpEventType.Response:
        return `File "${file.name}" was completely uploaded!`;

      default:
        return `File "${file.name}" surprising upload event: ${event.type}.`;
    }
}




================================================================================


  Custom Property Binding using @Input Decorator
  **********************************************


https://www.netjstech.com/2020/04/angular-custom-property-binding-using-input-decorator.html




================================================================================

::ng-deep

  DEPRECATED but no replacement announced.
    https://stackoverflow.com/questions/49859784/ng-deep-going-to-be-deprecated-any-alternatives

  this is a shadow-piercing descendant combinator
  to force a style down thru the child environment tree into all
  the child component views.

  works to any depth of nested components, and it applies to both the view
  children and content children of the component.

e.g.

  Parent Content

    <app-child></app-child>


  parent.component.css

    ::ng-deep h3 {
      font-style: italic;
    }




  and it's aliases 

    /deep/
    >>>

  use it with emulated view encapsulation.

  Emulated is the default and most commonly used View Encapsulation.


  Alternatives

    One alternative that can work is to include the css styles in your 
    global styles.scss file 

    e.g. say you want to add a style to the 

      <div class="mat-form-field-flex"> 

    element that gets generated under a <mat-form-field>, 

    you could use ::ng-deep likewise:

    your.component.scss

      ::ng-deep mat-form-field.mat-form-field div.mat-form-field-flex {
        padding: 0 0 0 .75em;
      }

    so, instead, you can change 

    styles.scss

    mat-form-field.mat-form-field  div.mat-form-field-flex {
      padding: 0 0 0 .75em;
    }


================================================================================


PDF Viewing 
************

PSPDFKit for Web.
https://pspdfkit.com/blog/2018/open-pdf-in-your-web-app/


Displaying PDF files in your angular app
ngx-extended-pdf-viewer
https://www.beyondjava.net/ngx-extended-pdf-viewer




================================================================================

  ExpressionChangedAfterItHasBeenCheckedError
  --------------------------------------------

  Expression has changed after it was checked

https://blog.angular-university.io/angular-debugging/

most likely happen in lines containing BehaviorSubject and  async


     <div class="px-5" *ngIf="(fileUpload.status$ | async) as status">


This is because the value of status$ changes while the view is being constructed.

The solution is to allow Angular build the viewer BEFORE updating the model.

Possible solutions:

1. move all intialization into  `ngOnInit()`  method

2. introduce  delay(0) which will push the update into the next JavaScrtip VM cycle.


  private uploadFile(): void {
    this.uploadStatus$ = this.fileUploadService.upload(
      this.file,
      this.uploadEndpointUrl,
      this.referenceId
    )
    .pipe(
      delay(0), // addresses ExpressionChangedAfterItHasBeenCheckedError <======
      tap(status => {
        this.statusSubject.next(status);
        this.statusChange.next(status);
      })  // Update the status output
    );
  }






================================================================================

  HttpClient
  **********

getAllBooks(): Observable<Book[]> {
  return this.http.get<Book[]>('/api/books');
}

this.dataService.getAllBooks()
  .subscribe(
    (data: Book[]) => this.allBooks = data,
    (err: any) => console.log(err),
    () => console.log('All done getting books')
  );



================================================================================

  HTTP Interceptors
  *****************

http://jpapa.me/ng-http-int
http://jpapa.me/code-int


@Injectable()
export class AuthInterceptor implements jhttpInterceptor {
  
  intercept(req: JHttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {

    const modifiedRequest = req.clone();
    // change modifiedRequest
    return next.handle(modifiedRequest)
      .pipe(
        .tap(event => {
          if (event instanceof HttpResponse) {
            // modify the HttpResponse here
          }
        })
      );
  }
}

NOTE: we do NOT provide interceptors in the ROOT.

we provide in the same NG Module where the HTTP client is imported.

we modify the clone of the original request - it is immutable - we create a clone of it.


ORDER is important with Interceptors
------------------------------------

1. Interceptors are optional dependencies of HttpClient
2. you must provide them in the same injector that provides HttpClient
3. Barrels (index.ts) are helpful to export and organize interceptors
4. Interceptors fire one at a time, in the order they are provided


interceptors/index.ts
----------------------

export const httpInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: CSRFInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: BusyInterceptor, multi: true },

];


app.module.ts
-------------

@NgModule({
  // ... 
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [
    httpInterceptorProviders
  ]
})
export class AppModule {}




Interceptor to check responses
-------------------------------

@Injectable
export class LogHttpInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {

    const started = Date.now();
    this.logRequest(req);
    return next.handle(req).pipe(
      tap(event) => this.logResponse(event, req, started));
    );
  }
}



HttpContext and HttpContextToken
----------------------------------

context object being passed to the interceptor allowing you to more precisely 
configure the interceptor behavior.

It is not passed along with the actuall HTTP request.

Usage:

// in interceptor
export const OPTION_1 = new HttpContextToken<number>(() => 42); // default token value

// in the service
let my_context: HttpContext = new HttpContext();
my_context.set(OPTION_1, 13);

this.http.get('/api/books', {
  context: my_context
});  // <-- passing the context object


// in interceptor

let first_option: number = req.context.get<number>(OPTION_1);





================================================================================

  Adding Access Token with the Authentication Interceptor
  *******************************************************

https://code-maze.com/secure-angular-calls-to-webapi-using-access-token/


================================================================================

Packaging fonts and avoiding duplicate fonts
---------------------------------------------

https://github.com/angular/angular-cli/issues/6599


================================================================================

  Copy to clipboard
  *****************


https://zeroesandones.medium.com/how-to-copy-text-to-clipboard-in-angular-e99c0feda501


================================================================================

  @Input with a finite list of items
  -----------------------------------

@Input() tooltipMode: 'base' | 'brand' | 'good' | 'warning' | 'bad';


================================================================================


validating  making @Input() directive required
----------------------------------------------

https://stackoverflow.com/questions/35528395/make-directive-input-required


in ngOnInit()
--------------

export class MyComponent implements OnInit, OnChanges {
    @Input() a:number; // Make this a required attribute. Throw an exception if it doesnt exist
    @Input() b:number;

    constructor(){
    }

    ngOnInit() {
       this.checkRequiredFields(this.a);
    }

    ngOnChanges(changes) {
       this.checkRequiredFields(this.a);
    }

    checkRequiredFields(input) {
       if(input === null) {
          throw new Error("Attribute 'a' is required");
       }
    }
}


angular selector 
----------------

Component({
  selector: 'my-dir[a]', // <-- use attribute selector along with tag to ensure both tag name and attribute are used to "select" element by Angular in DOM
});
export class MyComponent {
  @Input() a: number;
}

The bummer is that the error message the developer will receive is "my-dir is not a known element", which isn't super clear.



decorator
------------




  export function RequiredProperty(message?: string) {
    return function (target: Object, propertyKey: PropertyKey) {
      Object.defineProperty(target, propertyKey, {
        get() {
          throw new Error(message || `Attribute ${String(propertyKey)} is required`);
        },
        set(value) {
          Object.defineProperty(this, propertyKey, {
            value,
            writable: true
          });
        }
      });
    };
  }


and putting it to use


  @Input()
  @RequiredProperty('Please provide [officeName]="<value>" in the template.')
  officeName: string;

  @Input()
  @RequiredProperty()
  address: OfficeAddress;





================================================================================

  Truncate string in Angular
  --------------------------

https://stackoverflow.com/questions/44669340/how-to-truncate-text-in-angular2

  {{str | slice:0:6}}


Custom pipe


import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
 name: 'truncate'
})

export class TruncatePipe implements PipeTransform {

transform(value: string, args: any[]): string {
    const limit = args.length > 0 ? parseInt(args[0], 10) : 20;
    const trail = args.length > 1 ? args[1] : '...';
    return value.length > limit ? value.substring(0, limit) + trail : value;
   }
}

{{ str | truncate:[20] }} // or 
{{ str | truncate:[20, '...'] }} // or


@NgModule({
  declarations: [
    TruncatePipe
  ]
})
export class AppModule {}


================================================================================


viewProviders
-------------

https://www.tektutorialshub.com/angular/viewproviders-in-angular/

https://debugmode.net/2020/06/24/when-to-use-viewproviders-in-angular-simplified/

Great for developing library components


The viewProviders property allows us to make providers available only for the component’s view.

When we want to use a class in our component that is defined outside the @Component () decorator function, then, first of all, we need to inject this class into our component, and we can achieve this with the help of the "viewProvider" property of a component.

Use the following code in app.component.ts file.



import { Component, Injectable } from '@angular/core';

class MyProvider {
  constructor() {
    console.log("provider property");
  }
  VarMyProvider = "VarMyProvider";
}

class MyProvider1 {
  VarMyProvider1 = "VarMyProvider1";
  constructor() {
  }
  getString(name) {
    console.log("provider property1" + name);
  }
}

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  viewProviders: [MyProvider, MyProvider1]
})
export class AppComponent {
  constructor(public obj: MyProvider, public obj1: MyProvider1) {
    obj1.getString(" SahosoftTutorials.com");
    console.log(obj.VarMyProvider);
    console.log(obj1.VarMyProvider1);
  }

  title = 'app';
}

In this, we have created two classes, like : "MyProvider" and "MyProvider1". If we want to use these classes in our component, first inject the name of your class in the Provider.

viewProviders:[MyProvider, MyProvider1]  

Then, create an object into the constructor.

constructor(public obj:MyProvider, public obj1:MyProvider1)


================================================================================

  Pass Component to a Component
  *****************************

https://stackoverflow.com/questions/43933783/pass-component-to-a-component-in-angular






================================================================================

  ContentChild and ContentChildren
  ----------------------------------

https://www.tektutorialshub.com/angular/contentchild-and-contentchildren-in-angular/

Code Craft TV
https://codecraft.tv/courses/angular/components/viewchildren-and-contentchildren/


they are decorators that we use to query and get a reference to the Projected Content 
in the DOM.  

Projected content is the content that this component receives from a parent component.

ContentChild and ContentChildren are very similar to ViewChild and ViewChildren.


  ViewChild and ViewChildren
  . . . . . . . . . . . . . .

The view children of a given component are the elements used WITHIN its template - its VIEW.


We use ViewChild and ViewChildren to query and get a reference to any DOM element in the component.
It can be an HTML element, Child Component or directive, etc.   

But we cannot use the ViewChild or ViewChildren to get the reference to the template inserted
using the Content projection.


  Content Projection Recap
  . . . . . . . . . . . . . .

Content projection is a way to pass the HTML content from the parent to the child
component.



For example


  @Component({
    selector: 'card',
    template: `
   
      <div class="card">
        <ng-content select="header"></ng-content>
        <ng-content select="content"></ng-content>
        <ng-content select="footer"></ng-content>
      </div> 
     
    `,
    styles: [
      ` .card { min- width: 280px;  margin: 5px;  float:left  } 
      `
    ]
  })
  export class CardComponent {
   
  }

The component defines 3 ng-content slots.

And the CardListComponent can project content into those slots:


      <card>
        <header><h1 #header>Angular</h1></header>
        <content>One framework. Mobile & desktop.</content>
        <footer><b>Super-powered by Google </b></footer>
      </card>


Now, we can use @ContentChild to query the "header" from the projected content
in the CardComponent:

<ng-content select="header"></ng-content>


  @ContentChild("header") cardContentHeader: ElementRef;


cardContentHeader is the variable. 
We apply the @ContentChild decorator on that variable. 
The header is the template variable, that we want to read. 


  <header><h1 #header>Angular</h1></header>


Since it is applied on h1 tag, it is going to return the ElementRef.

the cardContentHeader will not be available to use immediately.
------------------------------

The angular initializes the component first. 
It then raises the 

  ngOnChanges, 
  ngOnInit & 
  ngDoCheck

The projected components are initialized next. 
then Angular raises the 

  AfterContentInit & 
  AfterContentChecked hooks. 


Injected content is available after   AfterContentInit() hook
-------------------------------------------------


Hence the cardContentHeader is available to use only after the AfterContentInit hook.

Once, we have reference to the DOM Element, we can use the renderor2 to manipulate its styles etc.



  ngAfterContentInit() {
     
      this.renderor.setStyle(this.cardContentHeader.nativeElement,"font-size","20px")
   
  }



ContentChild(selector: string | Function | Type<any>, opts: { read?: any; static: boolean; }): any


//Using a Template Reference Variable
@ContentChild("header") cardContentHeader: ElementRef;


static 


  True to resolve query results before change detection runs, false to resolve after change detection. Defaults to false.


  #What is the difference between static and dynamic queries? 

    The static option for @ViewChild() and @ContentChild() queries determines when the query results become available.


    With dynamic queries (static: false), the query resolves after either ngAfterViewInit() or ngAfterContentInit() for @ViewChild() and @ContentChild() respectively. The result will be updated for changes to your view, such as changes to ngIf and ngFor blocks.


    With static queries (static: true), the query resolves once the view has been created, but before change detection runs. The result, though, will never be updated to reflect changes to your view, such as changes to ngIf and ngFor blocks.


ContentChildren
===============

Use the ContentChildren decorator to get the list of element references from the projected content.

ContentChildren is different from the ContentChild. ContentChild always returns the reference to a single element. 

If there are multiple elements the ContentChild returns the first matching element,


ContentChildren always returns all the matching elements as a QueryList. 
You can iterate through the list and access each element.






================================================================================

Angular decorators
------------------------------


Decorators in Angular
https://medium.com/@bilkiss.dulloo/decorators-in-angular-16e20efcd17c


Building custom typescript decorators for angular
https://levelup.gitconnected.com/building-custom-typescript-decorators-for-angular-4595816e7b87



https://medium.com/angular-in-depth/implementing-custom-component-decorator-in-angular-4d037d5a3f0d


https://angular-training-guide.rangle.io/features/typescript/decorators


Decorators
**********


Decorators are proposed for a future version of JavaScript, but the Angular team really wanted to use them, and they have been included in TypeScript.

Decorators are functions that are invoked with a prefixed @ symbol, and immediately followed by a class, parameter, method or property. The decorator function is supplied information about the class, parameter or method, and the decorator function returns something in its place, or manipulates its target in some way. Typically the "something" a decorator returns is the same thing that was passed in, but it has been augmented in some way.


Decorators are functions, and there are four things (class, parameter, method and property) that can be decorated; consequently there are four different function signatures for decorators:


class: 

  declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;

property: 

  declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;

method: 

  declare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;


parameter: 

  declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;



Class decorators
----------------

https://angular-training-guide.rangle.io/features/typescript/class_decorators




Method decorators
-----------------
https://medium.com/@bilkiss.dulloo/decorators-in-angular-16e20efcd17c


decorators are simple TS functions



function confirmable(target: Object, propertyKey: string, descriptor: PropertyDescriptor)


  target 
    represents the class containing the method we're decorating

  propertyKey
    represents the method name


  descriptor 
    contains the method implementation



Reference:

  https://angular-training-guide.rangle.io/features/typescript/decorators



Property Decorators
-------------------

https://angular-training-guide.rangle.io/features/typescript/property_decorators


Using Property Decorators in Typescript with a real example
https://dev.to/danywalls/using-property-decorators-in-typescript-with-a-real-example-44e



function ReadOnly(target: any, key: string) {
  Object.defineProperty(target, key, { writable: false });
}

class Test {
  @ReadOnly             // notice there are no `()`
  name: string;
}

const t = new Test();
t.name = 'jan';         
console.log(t.name); // 'undefined'


Example

  declare Min function as decorator


    /**
     * Min funtion expects the limit number and 
     * returns another function - that expects the Object and the property key
     */
    function Min(limit: number) {

      return function(target: Object, propertyKey: string) { 
        let value : string;
        const getter = function() {
          return value;
        };
        const setter = function(newVal: string) {
           if(newVal.length < limit) {
            Object.defineProperty(target, 'errors', {
              value: `Your password should be bigger than ${limit}`
            });
          }
          else {
            value = newVal;
          }      
        }; 
        Object.defineProperty(target, propertyKey, {
          get: getter,
          set: setter
        }); 
      }

    }  


    class User {
      username: string;

      @Min(8)
      password: string;

      constructor(username: string, password: string) {
        this.username = username;
        this.password = password;
      }
    }



Example 

https://stackoverflow.com/questions/35528395/make-directive-input-required

      export function RequiredInput(message?: string) {
        console.log('im a required input');

        return function (target: Object, propertyKey: PropertyKey) {
          Object.defineProperty(target, propertyKey, {
            get() {
              throw new Error(message || `Attribute ${String(propertyKey)} is required`);
            },
            set(value) {
              Object.defineProperty(this, propertyKey, {
                value,
                writable: true
              });
            }
          });
        };
      }




Parameter Decorators
--------------------

https://angular-training-guide.rangle.io/features/typescript/parameter_decorators


================================================================================


Four ways of listening to DOM events in Angular
***********************************************

https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-2-hostlistener-1b66d45b3e3d
https://medium.com/claritydesignsystem/four-ways-of-listening-to-dom-events-in-angular-part-3-renderer2-listen-14c6fe052b59


Event Binding: One-way data binding, in which information is sent from a component’s template to the component’s class

@HostListener: Angular decorator that handles events on the host element

Renderer2: Using Renderer2 .listen() method for a target event and element

RxJS: Using RxJS .fromEvent() operator that turns events into observable sequences




Part 3: Renderer2.listen


================================================================================

  Angular Pseudo-Events
  ----------------------

https://medium.com/claritydesignsystem/angular-pseudo-events-d4e7f89247ee


Through pseudo-events, Angular allows you to directly bind to a specific keystroke or keystroke combination. 
That means a keyboard event will be only fired on that specific key or key combination instead of on all key events.




================================================================================

  How to pass a function to a child component in Angular
  -------------------------------------------------------

https://medium.com/@7hwyl/how-to-pass-a-function-to-a-child-component-in-angular-719fc3d1ee90

Sometimes your child components need to notify a parent when something happens. There are a number of ways to accomplish this, but one of the easiest is by passing a function to the child component that it can then call back when needed.

Step 1 — Define your parent callback function in your parent component

In your parent component, create a new arrow function:

  myCallbackFunction = (args: any): void => {
    //callback code here
  }


Step 2 — Pass the function to the child component
In your parent component’s html, pass the callback function as a bound attribute to the child component:

  <app-child-component [callbackFunction]=”myCallbackFunction”></app-child-component>


Step 3 — Set up an input variable in child component
In your child component, add an @Input variable to bind the parent component’s passed function:

  @Input() callbackFunction: (args: any) => void;

Make sure that the signature definition of your @Input() function matches the myCallbackFunction that you defined in the parent component.

Step 4 — Call the callback function

When needed, you can invoke the callback function just like any other:

  this.callbackFunction(someArgs);

Conclusion

This gives you a very simple approach for notifying a parent component of events that happen within a child.




================================================================================


  Observable Service
  ******************

@Injectable
export class InventoryService {
  
  latestProduct: Product;

  private inventorySubject$ = new BehaviorSubject<Product>(this.latestProduct);

  inventoryChanges$ = this.inventorySubject$.asObservable();

  addToInventory(product: Product) {

    this.latestProduct = product;
    this.inventorySubject$.next(product);

  }


}


export class InventoryComponent implments OnInit, OnDestroy {
  
  @Input() products: Products[] = [];

  constructor(private inventoryService: InventoryService) {}

  ngOnInit() {
    this.subsink.sink = 
      this.inventoryService.inventoryChanges$.subscribe(
        prod => this.products.push(prod)
      );
  }

  ngOnDestroy() {
    this.subsink.unsubscribe();
  }

}



================================================================================

  Stopping Angular Click Events from Propagating

  https://fireflysemantics.medium.com/stopping-angular-click-events-from-propagating-105bfba75a51







================================================================================

  Understanding @Output and EventEmitter in Angular
  --------------------------------------------------

  https://dzone.com/articles/understanding-output-and-eventemitter-in-angular



================================================================================


Pass function as Input
-----------------------

https://medium.com/@7hwyl/how-to-pass-a-function-to-a-child-component-in-angular-719fc3d1ee90

https://stackoverflow.com/questions/65720447/angular-pass-function-as-input   2021

https://stackoverflow.com/questions/35328652/angular-pass-callback-function-to-child-component-as-input-similar-to-angularjs


https://stackblitz.com/edit/angular-ivy-bkzeg7?file=src%2Fapp%2Fapp.component.html

  child-with-button.ts
  ---------------------

  @Input()
  callbackFunction!: (args: any) => void;


  callCallbackFunction(): void {
    this.callbackFunction('Test');
  }

  child-with-button.html
  ----------------------

  <button (click)="callCallbackFunction()">Call the Callback FN</button>


  parent.ts
  -----------

  myCallbackFn = (args: string): void => {
    console.log(`myCallbackFn args: `, args);
  }


  parent.html
  ------------

  <app-child-with-button
    [callbackFunction]="myCallbackFn"
  ></app-child-with-button>




Output + EventEmitter solution
------------------------------

//////parent.component.html

<child-selector
  ($buttonClicked)=clickAction($event)>
</child-selector>

//////parent.component.ts
...
export class ParentComponent {
  public clickAction(value: string): void {
    console.log(value);//will log 'something1234 when child button is clicked
  }
}



//////child.component.ts
...
import { Output, Component, EventEmitter } from '@angular/core';
...
export class ChildComponent {
  @Output() $buttonClicked = new EventEmitter<string>();

  public click(): void {
    this.$buttonClicked.emit('something1234');
  }
}

//////child.component.html
<button (click)="click()">


Subject
---------------

Interface responses using your modalService+subject+observables





================================================================================


  :host

  :host-context

  ::ng-deep


    ::ng-deep, /deep/ and >>> deprecation
    .....................................


    The ::ng-deep pseudo-class selector also has a couple of aliases: >>> and /deep/, and all three are soon to be removed.

    The main reason for that is that this mechanism for piercing the style isolation sandbox around a component can potentially encourage bad styling practices.

    The situation is still evolving, but right now, ::ng-deep can be used if needed for certain use cases.




  Angular View Encapsulation
  --------------------------

https://blog.angular-university.io/angular-host-context/

https://blog.angular-university.io/angular-ngclass-ngstyle


:host

  Sometimes we want to style the component custom HTML element itself.
  Styles inside the component stylesheet are scoped to elements in the template, 
  not the outer component element itself

  If we want to style the host element of the component itself, we need the special
  :host pseudo-class selector.

  Combining the :host selector with other selectors

  :host h2    <-- would only apply to h2 inside the template


==>  NOTE <===   
:host will not take effect if you have encapsulation: ViewEncapsulation.None in the component's definition as shown below.


Use the component selector in the stylesheet when ViewEncapsulation.None:


  // A method to style the :host element when ViewEncapsulation.None
  drag-and-drop-file-upload {
    min-height: $file-upload-min-height;
  }


::ng-deep

  if we want our component styles to cascade to all child elements of a component
  but not to any other element on the page, we can do this by combining 


  :host ::ng-deep h2 {}  <-- would apply to h2 in all children of this component



:host-context


  Using CSS Host-Context To Theme Components In Angular 6.1.3
  https://www.youtube.com/watch?v=NxUXcoYQg30


  Sometimes, we also want to have a component apply a style to some element outside of it.

  One possible common use case - for theme enabling classes.

  E.g. say we want to ship a component with multiple alternative themes.
  Each theme can be enabled via adding CSS class to a parent element of the component.


      template: `
            <button class="btn btn-theme">Themeable Button</button>
      `,
      styles: [`
          :host-context(.red-theme) .btn-theme {
            background: red;
          }
          :host-context(.blue-theme) .btn-theme {
              background: blue;
          }
      `]

  The above themed styles are deactivated by default.
  In order to activate one theme, we need to add to any parent element of this 
  component on of the theme-activating classes.



      <div class="blue-theme">
          <themeable-button></themeable-button>
      </div>




:host vs :host-context
-----------------------

https://stackoverflow.com/questions/42583629/cannot-understand-the-use-of-host-in-components-in-angular2/42583926#42583926

:host selector comes from shadow DOM spec

  ...This scoped subtree is called a shadow tree. The element it's attached to is its shadow host.

  In angular world, a component's template is a shadow tree. 
  The component's element is a shadow host. 
  So when you're defining styles for :host selector, the styles are applied to the component's element.



:host-context

  Now, :host-context is also applied to the host element, but the function (parenthesis) takes a selector that is checked not against the host element itself, but against all ancestors up to document root. If such element is found, the styles are applied.



================================================================================

Cannot invoke an object which is possibly 'undefined'
------------------------------------------------------

occurs when we try to invoke a function property that could be undefined, e.g. is marked as optional. To solve the error, use the optional chaining operator (?.), e.g. employee.doWork?.().


type Employee = {
  doWork?: () => void;
};

const employee: Employee = {};

// ✅ Works now
employee.doWork?.();


The optional chaining (?.) operator short-circuits instead of throwing an error if the reference is undefined or null.



================================================================================

angular library component or directive matching '.. 'is outside the scope of the current template


A:  is it exported in your library module?


================================================================================

Angular Theme Branding
---------------------


https://blog.kalvad.com/branding-angular-app/


================================================================================

  angular.json  styles and stylesPreprocessorOptions
  --------------------------------------------------

https://dev.to/danywalls/how-to-simplify-and-clean-your-sass-import-with-angular-json-57pg


When we work with Sass and Angular, import files is a very common task, and if you have more than 10 files and want to change the path of your sass structure


@import 'shared/styles/colors';
@import 'shared/forms/input';
@import 'shared/forms/select';
@import 'shared/mixis/grid';


All files need to be updated and are not nice, let angular help with it.


Go to angular.json file, under styles add stylePreprocessorOptions object 
with includePaths option and define all paths available in an array with your file paths, 

it should be relative to the angular.json.


"styles": [
   "src/styles.scss"
   ],
"stylePreprocessorOptions": {
   "includePaths": [
        "src/share/forms",
        "src/share/styles",
        "src/share/mixins"
        ]
}...


Angular will compile using these paths, and 
you can remove them from your files, and the compiler found these files.


@import 'colors';
@import 'input';
@import 'select';
@import 'grid';



================================================================================

Detect Responsive Screen Sizes in Angular
------------------------------------------

https://www.digitalocean.com/community/tutorials/detect-responsive-screen-sizes-in-angular


Angular BreakpointObserver
--------------------------

How to Manage Breakpoints using BreakpointObserver in Angular
https://www.thisdot.co/blog/how-to-manage-breakpoints-using-breakpointobserver-in-angular


================================================================================





