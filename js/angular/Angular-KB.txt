  
	@@@@@@@@@@@

		Angular

	@@@@@@@@@@@



  Architecture
  *************

Angular applications are composed of:
  1. HTML templates with angularized markup,
  2. component classes to manage those templates
  3. services with application logic
  4. modules combing components and services

You launch the app by bootstrapping the root module


8 main building blocks of an Angular app:

1. Modules
2. Components
3. Templates
4. Metadata
5. Data binding
6. Directives
7. Services
8. DI

================================================================================

Routing
-------

  Routing is another name for navigation.
  The router is the mechanism for navigating from view to view.
  Routes tell the router which views to display when a user clicks a link
  or pastes a URL into the browsers' address bar.


  Module Import Order Matters

    When you start using modules with their own routing modules, 
    and the routes are no longer defined in one file - import order
    becomes important.

    Each routing module augments the route configuration IN THE ORDER OF
    IMPORT.  

    If you list AppRoutingModule first, the WILDCARD route
    will be registered BEFORE the hero routes.

    app.module.ts
    -------------

      @NgModule({
        imports: [
          BrowserModule,
          FormsModule,
          HttpModule,
          AppRoutingModule,  <-- uh-oh
          DashboardModule,
          HeroModule,        <-- wildcard kicks in before hero module routes
          CrisisCenterModule     

      export class AppModule {
        // diagnostic only
        constructor(router: Router) {
          console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
        }
      }      


      The wildcard route - which matches every URL -- will intercept
      the attempt to navigate to a hero route.


        Routes:  [
          {
            "path": "heroes",
            "loadChildren": "app/hero/hero.module#HeroModule"
          },
          {
            "path": "crisis-center",
            "loadChildren": "app/crisis-center/crisis-center.module#CrisisCenterModule"
          },
          {
            "path": "dashboard",
            "loadChildren": "app/dashboard/dashboard.module#DashboardModule"
          },
          {
            "path": "",
            "redirectTo": "/dashboard",
            "pathMatch": "full"
          },
          {
            "path": "**"
          },
          {
            "path": ""
          },
          {
            "path": ""
          },
          {
            "path": ":id"
          },
          {
            "path": ""
          }
        ]


  Router 
  ----------------

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

  When the router navigates to a new component view, it updates the browser's 
  location and history with a URL for that view.  This is a strictly local URL.
  The browser should not send this URL to the server and should NOT reload the
  page.

  The Angular Router supports two techniques for achieving that with the help
  of two LocationStrategy providers:

  1. PathLocationStrategy - the default "HTML 5 pushState" style
  2. HashLocationStrategy - the "hash URL" style

  The first one relies on the modern HTML 5 browsers' support for history.pushState
  technique.

  Older browsers send page requests to the server when the location URL changes.. 
  unless the change occurs after a "#" hash.  Routers take advantage of this
  exception by composing in-application route URLs with hashes. e.g.:

    localhost:3002/src/#/crisis-center/



   <head>
    <base href="/">

    base href is important to make history.pushState work
    add the base href just under the <head> tag.

    if the "app" folder is the application root, set the href value to "/".

    The Router uses the browser's pushState for navigation.
    Thanks to pushState, we can make our in-app URL paths look the way 
    we want them to look.

    Our in-app URLs can be indistinguishable from server URLs.

    The browser also needs the base <href> value to prefix relative URLs.



Define Routes
-------------

  a router must be configured with a list of route definitions.



FIRST MATCH WINS

    The router selects the route with a 'first match wins' strtegy.
    Wildcard routes are the least specific routes in the route configuration.
    Be sure it is the last route in the configuration.


wildcard route

  add a wildcard route to intercept invalid URLs and handle them gracefully.
  a "wildcard" route has a path consisting of "**" - it matches every URL.

    { path: "**", component: PageNotFoundComponent }

DEFAULT route
redirect route

  when the application launches, the initial URL in the browser bar is something
  like 

    localhost:3000

  that doesn't match any of the concrete configured routes, which would mean 
  the router falls all the way through to the wildcard route and displays the
  PageNotFoundComponent.  

  The application needs a DEFAULT route to a valid page.
  The solution is to use a 'redirect' route that translates the initial
  relative URL ('') to the desired default path, /heroes for example.


      const appRoutes: Routes = [
        { path: 'crisis-center', component: CrisisListComponent },
        { path: 'heroes',        component: HeroListComponent },
        { path: '',   redirectTo: '/heroes', pathMatch: 'full' },
        { path: '**', component: PageNotFoundComponent }
      ];

  a redirect route requires 'pathMatch' property to tell the router how to 
  match a URL 

    pathMatch: 'full' 

  the other possible pathMatch value is 'prefix'

  Root routing module
  ...................

    const routes: Routes = [
      { path: '', redirectTo: 'dashboard', pathMatch: 'full' },
      { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' },
      { path: 'crisis-center', loadChildren: 'app/crisis-center/crisis-center.module#CrisisCenterModule' }
    ];

    @NgModule({
      imports: [
        RouterModule.forRoot(
          routes,
          // { enableTracing: true }
        )
      ],
      exports: [RouterModule]
    })
    export class AppRoutingModule { }  



  Module/Child routing module
  ............................

    const crisisCenterRoutes: Routes = [
      { path: '', component: CrisisCenterComponent }
    ];

    @NgModule({
      imports: [RouterModule.forChild(crisisCenterRoutes)],
      exports: [RouterModule]
    })
    export class CrisisCenterRoutingModule { }



Inspect Router's Configuration
------------------------------

  You can inspect the router's current cconfiguration by examining its
  'config' property.

      app.module.ts
      -------------

      export class AppModule {
        // diagnostic only: inspect router configuration
        constructor(router: Router) {
          console.log('Routes: ', JSON.stringify(router.config, undefined, 2));
        }
      }

  Are routes listed in the order you expect them to?


    Routes:  [
      {
        "path": "heroes",
        "loadChildren": "app/hero/hero.module#HeroModule"
      },
      {
        "path": "crisis-center",
        "loadChildren": "app/crisis-center/crisis-center.module#CrisisCenterModule"
      },
      {
        "path": "dashboard",
        "loadChildren": "app/dashboard/dashboard.module#DashboardModule"
      },
      {
        "path": "",
        "redirectTo": "/dashboard",
        "pathMatch": "full"
      },
      {
        "path": "**"    <--- uh-oh 
      },
      {
        "path": ""
      },
      {
        "path": ""
      },
      {
        "path": ":id"    <--- will this one ever match?!
      },
      {
        "path": ""
      }
    ]  



RouterOutlet
------------

<router-outlet></router-outlet>

  directive from the router library that marks the spot in the template where
  the router should display the views for that outlet.

    The router adds the <router-outlet> element to the DOM and subsequently
    inserts the navigated view element immediately after the <router-outlet>

RouterLink binding
------------------

  <nav>
    <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
    <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
  </nav>

  routerLink=" path to a preconfigured route "


RouterLinkActive binding
------------------------

  on each <a> anchor tag, there is RouterLinkActive directive.

  toggles CSS classes for active RouterLinks based on the current RouterState.
  e.g.:

    nav a.active {
      color: #03d465;
    }

  will apply this style to <a> anchor tag defined inside <nav> element:

    <nav>
      <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
      <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
    </nav>  


  the template expression on the right of the (=) contains a space-delimited
  string of CSS classes that the Router will add when this link is active 
  (and remove when inactive).

  cascades down through each level of the route tree, so parent and child router
  links can be active at the same time.

  Can also set the directive to a string of classes:

    [routerLinkActive]="'active fluffy'"

  or bind it to a component property that returns such a string.






    ActivatedRoute
    **************

ActivatedRoute is a service provided to each route component that contains 
route specific information such as:

  - route parameters
  - static data
  - resolve data
  - global query params
  - the global fragment

The route path and parameters are available through an injected router service
called ActivatedRoute:

  url
    an Observable of the route path(s) represented as an array of strings 
    for each part of the route path

  data

  paramMap
    an Observable that contains a map of the required and optional parameters

  queryMapParam
    an Observable that contains a amp of the query parameters available to 
    all routes.

  fragement
  outlet
  routeConfig
  parent
  firstChild
  children


  Reading path parameters
  -----------------------


  use ngOnInit() {.. }


  /heroes/hero-detail;code=ADADA

  paramMap

    constructor(private route: ActivatedRoute) {
      console.log('HeroDetailComponent: call me "/heroes/hero-detail"');
      this.route.paramMap.subscribe(
        params => {
          console.log('constructor code=', params.get('code'));
        }
      );
    }


  Query parameters
  ----------------

  /heroes/hero-detail?code=ADADA


  Use ngOnInit() - angular guide shows that

  constructor(private route: ActivatedRoute) {
    console.log('HeroDetailComponent: call me "/heroes/hero-detail"');
    this.route.queryParamMap.subscribe(
      params => {
        console.log('constructor code=', params.get('code'));
      }
    );
  }


  ngOnInit() {
    this.route.queryParamMap
      .subscribe( (queryParams: ParamMap) => {
        console.log('ngOnInit: code=', queryParams.get('code'));
    });
  }


  Passing Static Data
  --------------------

    const appRoutes: Routes = [
      { path: 'crisis-center', component: CrisisListComponent },
      { path: 'hero/:id',      component: HeroDetailComponent },
      {
        path: 'heroes',        component: HeroListComponent,
                               data: { title: 'Heroes List' }
      },
      { path: '',              redirectTo: '/heroes', pathMatch: 'full' },
      { path: '**',           component: PageNotFoundComponent }
    ];  


    The 'data' property in the third route is a place to store arbitrary
    data associated with this specific route.  
    This property is accessible with each activated route.
    You can use 'data' property to store such items as 
      page titles
      breadcrumb text
      and other STATIC data

  Passing Dynamica Data
  ----------------------




================================================================================



1. Modules
-----------
  
every app has at least one module - root - named "AppModule"

other modules are "feature" modules

each module is a cohesive block of code dedicated to an app domain, a workflow, 
or a closely related set of capabilities.

any module, root or feature, is a class with @NgModule decorator


NgModule
--------

  NgModule is a decorator function that takes a single metadata object whose
  properties describe a module.

    - declarations

      = view classes that belong to this module. 3 types of view classes:
        1. components
        2. directives
        3. pipes
    
    - exports
      = subset of the declarations that should be visible and usable 
      in the component templates of OTHER modules
    
    - imports
      = other modules whose exported classes are needed by component
      templates declared in this module
    
    - providers
      = creators of services that this module contributes 
      to the global collection of services
      they become accessible in all parts of the app
    
    - bootstrap [ROOT only]
      = the main application view, called 'root component'
      only ROOT module should set this "bootstrap" property

example of root module

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  @NgModule({
    imports:      [ BrowserModule ],
    providers:    [ Logger ],
    declarations: [ AppComponent ],
    exports:      [ AppComponent ], // just for demo - no one needs root module
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

bootstrap root in main.ts

app/main.ts:

  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
  import { AppModule } from './app.module';

  platformBrowserDynamic().bootstrapModule(AppModule);

Angular modules and JavaScript modules

  be aware that you're using the two systems side by side:

    import { Component } from '@angular/core';
    .
    .
    .
    @NgModule({
      imports:  [ BrowserModule ],
      ...
    })

2. Components
----------------------------------------

   a component controls a patch of screen called a 'view'
   e.g., the following views are controlled by components:
    - app root with navigation links
    - list of heros
    - hero editor

  you define a component's logic - what it does to support the view - inside
  a class.  The class interacts with the view thru an API of properties and
  methods.

    e.g. this HeroListcomponent has a 'heroes' property that returns an array
    of heroes that is acquires from a service.
    it also has a selectHero() method that sets a selectedHero property when
    a user clicks to choose a hero from that list.


3. Templates
----------------------------------------

  you define a component's view with its companion template.
  a template is a form of HTML that tells Angular how to render the component.
  In addition to HTML, templates use Angular's template syntax.


  Template syntax
  ***************

  Templates display data and consume user events with the help of data binding.

    MVC or MVVM (mode-view-viewmodel)

  In Angular, the component plays the part of the Controller/Viewmodel, and
  the template represents the view.

    Basic Elements of Template syntax

  HTML
  Interpolcation
  Template expressions
  Template statements
  Binding syntax
  Property binding
  Attribute, class and style bindings
  Event binding
  Two-way data binding
  Built-in directives (NgClass, NgStyle, NgIf, NgFor, etc.)

  HTML
    almost all HTML syntax is valid template syntax.
    <script> element is notable exception - forbidden due to injection risk

  interpolation
    we use interpolation to weave calculated strings into the text between HTML element
    tags and within attribute assignments

        <h3>
          {{title}}
          <img src="{{heroImg}}" ... >
        </h3>

  template expressions
    produce a value
    angular executes the expression and assigns it to a property of a binding target

      [property]="expression"

      [disabled]="isUnchanged"

    template expressions cannot refer to anything in the global namespace.
    can't refer to window or document, can't call console.log or Math.max

    the expression context is typically the component instance which is the source
    of binding values.

    Guidelines:

      - a template expression should not change any application state other than
        the value of the target property

      - quick execution
        template expressions execute frequently - can be called every key press or
        mouse move        

      - simplicity: a property or method call should be the norm. ! is OK occasionally

      - idempotence: should be free from side effects

        Binding syntax

          from data source to view target:

        {{expression}}
        [target-property] = "expression"

          from view target to data source:

        (target) = "statement"
        on-target = "statement"


          two-way

        [(target)] = "expression"
        bindon-target = "expression"

    <button disabled>Save</button>

  with data binding

    <button [disabled]="isUnchanged">Save</button>                  


    Binding Targets

      the target of data binding is something in DOM.
      it could be a element | component | diretive property
      an event (element | component | directive) 

      binding type: property

        target:

          element property:

                <img [src] = "heroImgUrl">

              component property

                <hero-detail [hero]="currentHero"></hero-detail>

              directive property:

                <div [ngClass] = "{selected: isSelected}"></div>

      binding type: event                  

        target: 

          element event

              <button (click) = "onSave()">Save</button>


              <button (click)="show = !show"> {{show ? 'hide' : 'show'}} </button>

              presuming the component owning this template has something like:

                show: boolean = false;

              the button is bound to DOM event (click) which will trigger 
              the action indicated by the text in quotes.  Here, variable
              `show` will assigned the opposite value of self.
              The button text is bound to that variable `show`, so clicking
              the button will toggle the button text.



          component event

              <hero-detail (deleteRequest)="deleteHero()"></hero-detail>

          directive event

              <div (myClick)="clicked=$event">click me</div>



      binding type: two-way              

        target

          event and property

              <input [(ngModel)]="heroName">


      attribute

        <button [attr.aria-label]="help">help</button>

      class

        <div [class.special]j="isSpecial">Special</div>

      style

        <button [style.color] = "isSpecial ? 'red' : 'green'">


      How the parent and child components can communicate with each other:
      ---------------------------------------------------------------------

        <hero-detail [hero]="currentHero"></hero-detail>
      


4. Metadata
----------------------------------------



5. Data binding
----------------------------------------

  you display data by binding controls in an HTML template to properties
  of an Angular component.


    Template binding works with DOM PROPERTIES, not HTML attributes.



  one-way from data source to view target
  ---------------------------------------

      1. property style

       {{expression}} expression interpolation

          <ul>
            <li *ngFor="let hero of heroes"> {{hero}} </li>
          </ul>

      2. attribute style

        [target]="expression"

          e.g. bind 'isUnchanged' property to button disabled state

            <button [disabled]="isUnchanged">Save</button>

              you're binding the button's 'disabled' attribute and setting
              it to the current value of the component's 'isUnchanged' property.. 
              right?  WRONG

              These are not HTML attributes - these are properties fo DOM
              elements, components and directives.


      3. class style

        bind-target="expression"



  one-way from view target to data source
  ---------------------------------------

      Event 

        (view-target)="statement"
        
        on-target="statement"


  two-way 
  --------


      [(target)]="expression"

      bindon-target="expression"


      /**********************************
       *                                *
       * HTML attribute vs DOM property *
       *                                *
       **********************************/


  Attributes are defined by HTML.
  Properties are defined by the DOM.

  * a few HTML attributes have 1:1 mapping to properties.
    'id' is one example

  * some HTML attributes have no corresponding properties - e.g. colspan

  * some DOM props don't have corresponding attributes - textContent, e.g.

  * many HTML attrs seem to map to properties, but not the way you think!

  Attributes initialize DOM properties and then they are DONE.
  Property values can change; attributes do not.

  e.g. when the browser renders 

    <input type="text" value="Bob">

  it creates a corresponding DOM node with a 'value' property initialed to "Bob".
  when the user enters "Sally" into the input box, the DOM element 'value' 
  property becomes "Sally".  But the HTML 'value' attribute REMAINS 
  unchanged as you can confirm by asking:

    input.getAttribute('value');  // returns "Bob"

  the HTML attribute value specifies the INITIAL value; the DOM value property
  is the CURRENT value.

  The 'disabled' attribute is another peculiar example.
  A button's 'disable' PROPERTY is "false" by default so it is enabled.
  when you add the 'disabled' attribute, its presence alone initializes the 
  button's 'disabled' property to "true" to the button is disabled.

  Setting the button's 'disabled' property disables|enables the button - 
  the value of the PROPERTY matters (attribute does not).


Type

  Property

    element:  <img [src]="heroImageUrl">

    component:  <hero-detail [hero]="currentHero"</hero-detail>

    directive:  <div [ngClass]="{'special': isSpecial}">

                </div>

  Event

    element:   <button (click)="onSave()">Save</botton>

    component: <hero-detail (deleteRequest)="deletedHero()"></hero-detail>
     
    directive:  <div (myClick)="clicked=$event" clickable>click me</div>


  Attribute

    attribute:  <button [attr.aria-label]="help">help</button>

  Class

    property:   <div [class.special]="isSpecial">Special</div>


  Style

    property:   <button [style.color]="isSpecial ? 'red' : 'green'">



  Two-way

    event and property:   <input [(ngModel)]="name">


6. Directives
----------------------------------------

  A directive is a class with directive metadata.
  In TS, apply the @Directive decorator to attach metadata to the class.

  A component is a "directive-with-a-template".
  @Component decorator is actually a @Directive extended with template-oriented
  features.

  two other kinds of directives exist:

  1. structural
  2. attribute

  structural directives
  ...................................

    alter layout by adding, removing, and replacing elements in DOM.
    the example template uses two built-in structural directives

      <li *ngFor="let hero of heroes"></li>
      <hero-detail *ngIf="selectedHero"></hero-detail>

    *ngFor tells Angular to stamp out one <li> per hero in the 'heroes' list

    *ngIf includes the HeroDetail component only if a selected hero exists.



    <ng-container>

      grouping element
      ----------------

        is a grouping element that doesn't interfere with styles or layout
        because Angular doesn't put it in the DOM.

        In order to avoid having to create an extra div, we can instead use 
        <ng-container> directive.
        
        E.g.:

          <p>
            I turned the corner
            <ng-container *ngIf="hero">
              and I saw {{hero.name}}. I waved
            </ng-container>
            and continued on my way.
          </p>


        <ng-container> is a syntax recognized by the Angular parser.
        It's more like the curly braces in a JavaScript 'if' block


          if (somecondition) {
            ..
            ..
            ..
          }


        Without those braces, JS would only execute the first statement
        when you intend to conditionally execute all of them as a single 
        block.

        <ng-container> satisfies a similar need.


      placeholder for injecting a template dynamically into the page
      ------------------------------------------------

      We can take the template itself and instantiate it anywhere on the page,
      using the 'ngTemplateOutlet' directive:

        <ng-container *ngTempalteOutlet="loading"></ng-container>

      we are using <ng-container> instantiate on the page the 'loading'
      template.




  attribute directives
  ...................................    

    alter the appearance or behaviour of an existing element.
    In templates, they look like regular HTML attributes, hence the name.

    ngModel directive implements two-way binding and is an example of an
    attribute directive.

    it modifies the behaviour of an existing element (typically <input>) by 
    setting its display value property and responding to change events:

      <input [(ngModel)]="hero.name">

  custom attribute directive
  .....................................

  $ ng g d highlight

    import { Directive, ElementRef, Renderer } from '@angular/core';

    @Directive({
      selector: '[highlight]'
    )}
    export class HighlightDirective {

      // this is a short cut for creating a private field at the class level
      // and assigning to it in the constructor/method call
      constructor(private elementRef: ElementRef, private renderer: Renderer) {
        this.renderer.setElementStyle(
          this.elementRef.nativeElement, 
          'background-color', 
          'green');
      }

    }

  Creating Custom Directives
  ......................................

  great example: 
    https://github.com/anein/angular2-trim-directive

    also a good example of creating a angular-friendly npm module


    Decorators

      @HostListener
        function decorator
        provides a way to detect if the user is hovering over the host element

        @HostListener({ 
          eventName?: string
          args?: string[]
        })

        accepts
          - (optional) eventName
          - (optional) args string[]
        e.g.
        @HostListener('mouseover') onHover() {
          // window.alert("Hover");
        }

      @HostBinding

        allows us to bind to `input properties` in the host element
        this directive can change the properties of the host element, such as
        list of classes taht are set on the host element as well as a number
        of other properties.

    selector?: string

      The CSS selector that trigger the instantiation of a directive.
      Angular only allows directives to trigger on CSS selectors that 
      do not cross element boundaries.

      selector may be declared as one of the following:

        - element-name: select by element name
        - .class: select by class name
        - [attribute] select by attribute name
        - [attribute=value] selecte by attribute name and value
        - :not(sub_selector): select only if the element does NOT match the sub_s
        - selector1, selector2 : select if either selector1 or selector2 matches
          
        Example:

          selector: 'input[type=text]'

          <form>
            <input type="text">
            <input type="radio">
          </form>

        The directive would only be instantiated on the <input type="text"> element.

      providers?: Provider[]

        defines the set of injectable objects that are visible to a Directive
        and its light DOM children

    example of custom directive:

      @Directive({
        selector: 'input[lgnInputTextTrim]',
        providers: [
          { provide: NG_VALUE_ACCESSOR, useExisting: InputTextTrimDirective, multi: true }
        ]
      })
      export class InputTextTrimDirective extends DefaultValueAccessor {

        // set a new value to the field and model.
        private set value( val: any ) {
          // update element
          this.writeValue( val );
          // update model
          this.onChange( val );
        }

        /**
         * Updates the value on 'blur' event.
         * @param {string} event  event.type that triggered
         * @param {string} value  event.target.value
         */
        @HostListener('blur', ['$event.type', '$event.target.value'])
        onInput(event: string, value: string): void {
          // if defined - trim, otherwise don't
          this.value = (value) ? value.trim() : value;
        }
      }    




7. Services
----------------------------------------

  Service is a broad category encompassing any value, function, or feture that
  your application needs.

  Almost anything can be a service.
  Typically is a class with a narrow, well-defined purpose.
  Examples:
  - logging service
  - data service
  - message bus
  - tax calculator
  - application configuration

Angular has no definition of services.
There is no service base class, and no place to register a service.
Yet services are fundamental - components are big consumers of services.

example of a service class that logs to browser console:
app/logger.service.ts:

  export class Logger {
    log(msg: any) { console.log(msg); }
    error(msg: any) { console.error(msg); }
    warn(msg: any) { console.warn(msg); }
  }

example of HeroService that fetches heroes and returns them in a resolved
Promise.  This services also depends on the Logger service and another 
BackendService that handles the server comm grunt work:

app/hero.service.ts

  export class HeroService {
    private heroes: Hero[] = [];

    constructor(
      private backend: BackendService,
      private logger: Logger
    ) {}

    getHeroes() {
      this.backend.getAll(Hero).then(
        (heroes: Hero[]) => {
          // ... 
        });
      );
    }
  }

Component classes should be lean - they don't fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.

A component's job is to enable the user experience - nothing more. 
It mediates between the view (rendered by the template) and the application
logic (which often includes some notion of a model).

A good component presents properties and methods for data binding.
It delegates everything non-trivial to services.



  Async Services and Promises
  ...........................

if a service calls a remote server like

  this.heroes = this.heroService.getHeroes();

the method call sig is synchronous - and we will have to wait for the server to
respond and we won't be able to block the UI while we wait.

  Promises
  --------

A Promise is a promise to call us back later when the results are ready - 
we ask an async service to do some work and give it a callback function.



8. DI
----------------------------------------

Main points:

  injector - main DI mechanism

    maintains a container of service instances that it created

    can create a new service instance from a provider

  provider is a recipe for creating a service

  you register providers with injector
  
      
      
  Services and DI
  ---------------

Most dependencies are services - Angular uses DI to provide new components with the 
services they need.
Angular can tell which services a component needs by looking at the types of 
its constructor parameters.

E.g. constuctor of the HeroListcomponent:

  constructor(private service: HeroService) {}

When Angular creates the component, it asks an INJECTOR for the services that 
the component requires.

An injector maintains a container of service instances that it has previously
created.  If a requested service instance is not in the container, the 
injector makes one and adds it to the container before returning the service 
to Angular.

    How does the injector know how to make one?

You must have previously registered a PROVIDER of the HeroService with the 
injector.  A provider is something that can create or return a service, 
typically a service class itself.  You can register providers in modules or
in components.

In general, add providers to the root module so that the same instance of a
service is available everywhere.

    root module
    app/app.module.ts

      providers: [
        BackendService,
        HeroService,
        Logger
      ],

alternatively, register at a component level in the providers property of 
the @Component metadata:

  app/hero-list.component.ts

    @Component({
      moduleId: module.id,
      selector: 'hero-list',
      templateUrl: 'hero-list.component.html',
      providers: [ HeroService ]
    })

registering at a component level means you get a NEW instance of the service
with each NEW instance of that component.



Pipes
------------------------------------------

Pipes are a good way to format strings, currency amounts, dates and other
display data.

Angular ships with several pipes and we can write out own.


  Async Pipe
  ----------

Usage:

  <div>{{ observableTime | async }}</div>

Purpose:

  unwrap a value from an asynchronous primitive.
  if we have an Observable or Promise instance, then we can use it directly
  with AsyncPipe using diretives like 'ngFor', 'ngIf' and 'NgSwitch'.

  subscribes to Observable or Promise and returns latest data.

  marks the component to check for data changes.

    NgFor Example
    .............

      @Injectable() service to fetch book data

      component to display that data

        <ul>
          <li *ngFor="let book of observableBooks | async" >

            Id: {{book.id}}, Name: {{book.name}}

          </li>
        </ul>

      in component:

        ngOnInit(): void {
          this.observableBooks = this.bookService.getBooks();
        }

    NgIf and NgSwitch Example
    .........................

      <div *ngIf="promiseBook | async as book; else loading">
        Id: {{book.id}}, Name: {{book.name}}
      </div>
      <ng-template #loading>Loading Data .. </ng-template>

      <h3>AsyncPipe with NgSwitch</h3>

      <div [ngSwitch]="(promiseBook | async)?.id">

        <div *ngSwitchCase="100">Find Actual Data</div>
        <div *ngSwitchDefault>Showing Default Data</div>

      </div>


Providers
------------------------------------------

  useExisting 

    example

      providers: [
          A, 
          {provide: B, useClass: A}, 
          {provide: C, useExisting: A}]    

      if you have 

        constructor(private a: A)

      an instance for the first provider will be created

        constructor(private b: B)

      an instance for the 2nd provider will be created

        constructor(private c: C)

      an instance of the first provider will be injected

      but if you had started fresh with 

        constructor(private c: C)

      an instance of the first provider is created and injected



==============================================================================

  template syntax
  ***************

https://angular.io/docs/ts/latest/guide/template-syntax.html

interpolation  
----------------------------------------

  {{title}}
  {{ 1 + 1 + getVal() }}


template expressions
----------------------------------------
  produces a value
  angular executes the expression, assigns it to a property of a binding
  target - a HTML element, a component, or a directive

    [property] = "expression"



template statements
----------------------------------------

  (event) = "statement"

  a template statement responds to an event raised by a binding target such as
  an element, component, or directive

  has side effect
  it's how we update application state from user input.
  there would be no point to responding to an event otherwise.



Data binding
************

  component logic interacts with component template (view)

  - string interpolation
    {{exp resolving to a string}}

  - property binding
    binding data to properties in your DOM
    <button [disabled] = "exp resolving to required value type">  

  - event binding 
    binding DOM events back to the model
    <button (click) = "expression handling the event">

  - two-way binding
    by default all Angular2 data binding is uni-diretional
    for performance reasons.
    <input [(ngModel)] = "bound model (e.g. object)">


binding syntax
----------------------------------------

  one-way
  from data source to view target   
        {{expression}}
        [target] = "expression"
        bind-target = "expression"

  one-way
  from view target to data source
        (target) = "statement"
        on-target = "statement"

  two-way
        [(target)] = "expression"
        bindon-target = "expression"



property binding
----------------------------------------
  we write a template property binding when we want to set a property of a
  view element to the value of a template expression. 
  e.g. binding the 'src' property of an image to 'heroImageUrl' property:

    <img [src] = "heroImageUrl">

  disabling a button when the component says that it "isUnchanged"

    <button [disabled] = "isUnchanged">Cancel is disabled</button>

  setting a property of a directive

    <div [ngClass] = "classes">[ngClass] binding to the classes property</div>
    <div (ngSubmit) = "..."></div>   

  binding to component properties

    <cmp [initObj] = "...">
    <cmp (rndEvent) = "...">    

  custom bindings

    Property Binding (@Input)

      @Input() propertyName: string 

    one-way in
    ----------

  property binding is described as "one-way data binding" because it
  flows a value in one direction, from a component's data property into
  a target element property.





attribute, class and style bindings
----------------------------------------





event binding
----------------------------------------

  User interact with your application
  - they click buttons
  - pick items from lists
  - enter text into input boxes

  Such user actions may result in data flowing in the opposite direction:

  data flow:

    from an element to a component

  The only way to know about a user action is to listent for certain events 
  such as keystrokes, mouse movements, clicks and touches.

  We declare our interest in user actions thru Angular event binding.

  Event Binding syntax

    (target event) = "template statement"

      TARGET EVENT - appears between parenthesis.

        <button (click) = "onSave()">Save</button>  

      Canonical form:

        some people prefer the "on-" prefix alternative, known as canonical form:

        <button on-click="onSave()">On Save</button>

  Matching order

    - directives
    - elements

    element events may be the more common targets, but Angular looks to see 
    if the name matches an event property of a known directive FIRST.

      <!-- 'myclick' is an event on the custom 'clickDirective' -->
      <div (myClick)="clickmessage=$event">click with myClick</div>


    $event 
    ........................

    In an event binding, Angular sets up an event handler for the target event.

    when the event is raised, the handler executes the template statement.
    The template statement typically involves a receiver which performs an action
    in response to the event, such as storing a value from the HTML control 
    into a model.

    the binding conveys info about the event, inclu data values, thru an
    event object named 

      $event

    the shape of the event object is determined by the target event.
    If the target event is a native DOM element event, then $event is a
    DOM event object, with properties such a "target" and "target.value"

      <input [value]="currentHero.firstname"
             (input)="currentHero.firstname=$event.target.value">

    this code:
      - sets the input box "value" property by binding to the "firstName" 
        property
      - to listen for changes to the value, the code binds to the input box's
        "input" event.  when the user makes changes, the "input" event is 
        raised, and the binding executes the statement within a context that
        includes the DOM event object, $event.
      - to update the "firstName" property, the changed text is retrieved from
          $event.target.value



    EventEmitter
    ........................                                   

      Directives typically raise custom events with an Angular EventEmitter.

      example

        consider a HeroDetailComponent that presents hero info and responds to 
        user actions.  Although the HeroDetailComponent has a delete button,
        it doesn't know how to delete the hero itself..
        The best it can do is raise an event reporting the user's delete request.

        template:
        -------------
          <div>
            <img src="{{heroImageUrl}}">
            <span>{{prefix}} {{hero?.fullName}}</span>
            <button (click)="delete()">Delete</button>
          </div>

        hero-detail.component.ts (delete logic):
        ----------------------------------------

          // this component make a request but it can't actually delete a hero
          deleteRequest = new EventEmitter<Hero>();

          delete() {
            this.deleteRequest.emit(this.hero);
          }

        the component defines a "deleteRequest" property that returns an 
        EventEmitter.  When the user clicks "delete", the component invokes
        the "delete()" method telling the EventEmitter to emit a Hero object.

        Now, imagine a hosting parent component that binds to the 
        HeroDetailComponent's "deleteRequest" event:

          <hero-detail 
            (deleteRequest)="deleteHero($event)"
            [hero]="currentHero"></hero-detail>

        when the "deleteRequest" event fires, Angular calls the parent 
        component's "deleteHero(..)" method, passing the hero-to-delete 
        in the $event variable.





    Event Binding (@Output)  
    .......................

      @Output() eventName = new EventEmitter();  
    or
      <button (click)="onClicked()">Click Me</button>

      onClicked() {
        alert('it worked');
      }

    Binding to Custom events
    ........................

      <button (click)="onClicked()">Click Me!</button>

      @Output() clicked = new EventEmitter<string>();
      onClicked() {
        this.clicked.emit('It Works!');
      }

      now, to consume this custom event:

      <app-event-binding (clicked)="onClicked($event)"></app-event-binding>
      and in this component.ts:

      onClicked(value: string) {
        alert(value);
      }





two-way binding
----------------------------------------

  when developing entry forms, we often want to both display a data property
  and update that property when the user makes changes.

  ngModel implements two-way binding and is an example of an attribute directive.

    NOTE: must import FormsModule in app.module.ts

    <input [(ngModel)]="currentHero.firstName">

  the above can also be achieve with separate bindings to the <input> 
  element's "value" property and "input" event:

    <input [value]="currentHero.firstName"
           (input)="currentHero.firstName=$event.target.value" >

  ngModel hides the complexity behind its own "ngModel" input and 
  "ngModelChange" output properties:

    <input
      [ngModel]="currentHero.firstName"
      (ngModelChange)="currentHero.firstName=$event" >


          Error: Can't bind to 'ngModel' since it isn't a known property of 'input'

    in order to use two-way binding for form inputs, you need to import 
    the 'FormsModule' in your Angular module.

      also, if you are working in its module, like 'hero.module.ts', you 
      need to import 'FormsModule' in that module regardless of whether 
      it is already imported in app.module.ts:

          @NgModule({
            imports: [
              CommonModule,
              HeroRoutingModule,
              FormsModule
            ],
            declarations: [
              HeroListComponent,
              HeroDetailComponent
            ]
          })  
          export class HeroModule {}    

    and in unit tests, you need to include FormsModule in imports:

      beforeEach(async(() => {
        TestBed.configureTestingModule({
          declarations: [ HeroDetailComponent ],
          imports: [ FormsModule ]
        })
        .compileComponents();
      }));    





built-in directives
----------------------------------------
* and <template>
----------------------------------------
template reference variables
----------------------------------------
input and output properties
----------------------------------------


     


======================================================================

  components
  ----------

Components are the main way we build and specify elements and logic on the page.

In angular 1, this was done with directives/controllers/scope.  In angular2, 
all those concepts are combined into components.

Here is a simple component:

import { Component } from '@angular/core';

  @Component({
    selector: 'my-component',
    // templateUrl: './my.component.html',
    // styleUrls: ['./my.component.css']
    template: '<div>Hello my name is {{name}}. <button (click)="sayMyName()">Say my name</button></div>'
  })
  export class MyComponent {
    console.log('My name is', this.name);
  }

selector
--------

  selectors work like a CSS selector.  so if we were to have 

    <my-component>

  element in our HTML document, angular would know what to load here.. 

  You can also use "hashtag" syntax:

    selector: '#app-root'

  Now, you can reference that selector via div id:

    <div id="app-root"> 






======================================================================

  View Encapsulation
  ------------------

angular 2 emulates the concept of shadow DOM:

  an HTML element has its 'shadow' DOM

<div>
  <component _nghost-pax-1>
    <h1 _ngcontent-pax-1>... </h1>
  </component>
  <h1>won't be styled the same</h1>
</div>

  This is based on CSS Attribute Selectors.

  a[target] {
    background-color: yellow;
  }

	

==============================================================================

  angular component lifecycle
  ***************************
https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html

ngOnChanges
ngOnInit
ngDoCheck

  ngAfterContentInit
  ngAfterContentChecked
  ngAfterViewInit
  ngAfterViewChecked

ngOnDestroy



  constructor versus ngOnInit
  ---------------------------

  use constructor for DI
  use ngOnInit as signal that all bindings are setup.

constructor 

  on an ES6 class is a feature of a class itself, rather than an Angular 
  feature.   It is out of Angular's control when the constructor is 
  invoked, which means that it's not a suitable hook to let you know when
  Angular has finished initializing the component.


  suitable scenario for using the constructor

    - when we want to utilize dependency injection - essentially for 
      wiring up dependencies into the component.


ngOnInit

  by adding this lifecycle hook, Angular can fire a method once it has 
  finished setting the component up.

    - ngOnInit is purely there to give us a signal that Angular has
      finished initilizing the component.

    - the first pass at Change Detection against the properties that 
      we may bind to the component itself - e.g. when using @Input()

      due to this, the @Input() properties are available inside ngOnInit
      however, are undefined inside the constructor.

  the ngOnInit lifecycle hook is a guarantee that your bindings are readily
  available.





==============================================================================

  Twitter Bootstrap

@see angular-cli

==============================================================================

  creating a new service
  **********************

  $ ng g s <service-name> --flat --spec 

    --flat (default: true)


create config service
---------------------
$ mkdir src/app/shared
craiskin@xubi-one:~/ws/standard/iam/iam-demo-ng2-product-app $ ng g s shared/Config
installing service
  create src/app/shared/config.service.spec.ts
  create src/app/shared/config.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

create mdm product service
$ ng g s MdmProduct
installing service
  create src/app/mdm-product.service.spec.ts
  create src/app/mdm-product.service.ts
  WARNING Service is generated but not provided, it must be provided to be used


create ConfigService
--------------------

import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';

@Injectable()
export class ConfigService {
  public production: boolean = environment.production;
  public mdmProductServer: string = environment.MDM_PRODUCT_SERVER;
  public mdmProductApi: string = environment.MDM_PRODUCT_API;

  public mdmProductApiURL(): string {
    return this.mdmProductServer + this.mdmProductApi;
  }
}


Provide ConfigService in @NgModule AppModule:
---------------------------------------------

import { AppComponent } from './app.component';
import { environment } from '../environments/environment';
import { ConfigService } from './shared/config.service';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AlertModule
  ],
  providers: [ ConfigService ],
  bootstrap: [AppComponent]
})
export class AppModule {

  constructor() { }
}

use ConfigService in MdmProductService
--------------------------------------

import { Injectable } from '@angular/core';
import { ConfigService } from './shared/config.service';

@Injectable()
export class MdmProductService {

  constructor(private configService: ConfigService) { 
    console.log(`
      I'm MdmProductService, and I'm configured with ConfigService
      ConfigService.mdmProductServer: ${configService.mdmProductApiURL()}
    `);
  }

}





================================================================================

  RouterModule
  ************

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

Initial version:

app.module.ts
-------------

import { RouterModule }   from '@angular/router';


@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot([
      {
        path: 'heroes',
        component: HeroesComponent
      }
    ])
  ],   
  .
  .
  .
})
export class AppModule {
}

We use the 'forRoot' method because we're providing a configured router at the 
ROOT of the application.  

The 'forRoot' method gives us the Router service providers and directives needed
for routing and performs the initial navigation based on the current browser URL.

    RouterModule.forRoot([
      {
        path: 'heroes',
        component:HeroesComponent
      },
      {
        path: 'dashboard',
        component: DashboardComponent
      },
      {
        path: '',
        redirectTo: '/dashboard',
        pathMatch: 'full'
      }
    ])

  forRoot vs forChild
  -------------------

forRoot()
  call only in the root application module, AppModule.
  calling it in any other module, particularly in a lazy loaded module,
  is contrary to the intent and is likely to produce runtime error.

forChild

  always call RouterModule.forChild in a feature-routing module



    Router Outlet

If we paste the path "/heroes" into the browser address bar, the router should 
match it to the 'heroes' route and display the 'HeroesComponent'.

    <a routerLink="/heroes">Heroes</a>
    <router-outlet></router-outlet>


    Parameterized Route


We can add the object's id to the URL.

  /detail/11

  {
    path: 'detail/:id',
    component: HeroDetailComponent
  },  

The (:) in the path indicates that :id is a placeholder to be filled with a
specific hero id when navigating to the HeroDetailComponent

The corresponding [routerLink] for the above route would look like this:

  [routerLink]="['/detail', hero.id]" 

Here, we are binding a link parameters array:

  ['/detail',hero.id]

to our destination route:

  path: 'detail/:id'

The array has two elements:
  path of the destination route
  route parameter set to the value of the current hero's id

routerLinkActive directive
---------------------------

Angular Router provides a routerLinkActive directive to add a class to the HTML 
navigation element whose route matches the active route. Ex:

  <nav>
    <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
    <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
  </nav>

  nav a.active {
    color: #039be5;
  }  



================================================================================

  Angular built-in directives
  ***************************

There are three kinds of Angular directives:

1. Components
2. Attribute directives
3. Structural directives


Attribute Directives
---------------------


ngModel

  when developing entry forms, we often want to both display a data property
  and update that property when the user makes changes.

  ngModel implements two-way binding and is an example of an attribute directive.

    NOTE: must import FormsModule in app.module.ts

    <input [(ngModel)]="currentHero.firstName">

  the above can also be achieve with separate bindings to the <input> 
  element's "value" property and "input" event:

    <input [value]="currentHero.firstName"
           (input)="currentHero.firstName=$event.target.value" >

  ngModel hides the complexity behind its own "ngModel" input and 
  "ngModelChange" output properties:

    <input
      [ngModel]="currentHero.firstName"
      (ngModelChange)="currentHero.firstName=$event" >



ngClass

  source: https://coryrylan.com/blog/introduction-to-angular-2-ngclass-and-ngstyle

  creating dynamic styles for your application
  ngClass helps us handle dynamic CSS and CSS classes with the new template syntax

    ex: chaning <div> color property

      pure JavaScript:

        let myDiv = document.getElementById('my-div');
        myDiv.style.color = 'orange';  // update 

    out of the box, angular 2 provides primitives using [property] syntax
    to manipulate elements attributes:

      <div [style.color]="'orange'">
        style using property syntax - this text is orange
      </div>

  we can also using angular2 [property] syntax to assign CSS class to element:

    .blue { color: blue; }

    <div [className]="'blue'">CSS class using property syntax - this text is blue</div>


  manipulating <div> styles with ngStyle and angular2 component properties:

    app.component.css:
    ------------------

    .show-class {
      visibility: visible;
    }

    .hide-class {
      visibility: hidden;
    }


    app.component.ts:
    -----------------
    export class AppComponent {

      ngStyleDivColor: string;
      ngStyleDivFontSize: number;
      spanDisplayedText: string;
      spanDisplayedTextVisible: boolean;

      constructor() {
        this.ngStyleDivColor = 'pink';
        this.ngStyleDivFontSize = 16;
        this.spanDisplayedText = 'show-class';
        this.spanDisplayedTextVisible = true;
      }

      toggle() {
        this.spanDisplayedTextVisible = !this.spanDisplayedTextVisible;
        this.spanDisplayedText = this.spanDisplayedTextVisible ? 
          'show-class' :
          'hide-class';
          
      }
    }

    app.component.html:
    -------------------

    <h2>ngStyle</h2>

    <input [(ngModel)]="ngStyleDivColor" />
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize + 1">+</button>
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize - 1">-</button>

    <div 
        id="using-ngStyle" 
        [ngStyle]="{'color': ngStyleDivColor, 'font-size': ngStyleDivFontSize + 'px', 'font-weight': 'bold'}">
      div style configured with ngStyle
    </div>

    <hr>

    <span id="this-span" [ngClass]="spanDisplayedText">toggled with ngClass</span>
    <button (click)="toggle()">Toggle</button>



ngStyle

  allows us to set inline styles dynamically based on the state of the component.
  binding to ngStyle lets us set many inline styles simultaneously

  with this template:

    <div 
        id="using-ngStyle" 
        [ngStyle]="{'color': ngStyleDivColor, 'font-size': ngStyleDivFontSize + 'px', 'font-weight': 'bold'}">
      div style configured with ngStyle
    </div>
    <input [(ngModel)]="ngStyleDivColor" />
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize + 1">+</button>
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize - 1">-</button>

  we can manipulate the <div> element styles with the component state:

    export class AppComponent {

      ngStyleDivColor: string;
      ngStyleDivFontSize: number;
      spanDisplayedText: string;
      spanDisplayedTextVisible: boolean;

      constructor() {
        this.ngStyleDivColor = 'pink';
        this.ngStyleDivFontSize = 16;
        this.spanDisplayedText = 'show-class';
        this.spanDisplayedTextVisible = true;
      }
        
    }

===============================================================================

  angular component styles
  ************************

/deep/
>>> 

  component style normally applies only to the component's own template. Using /deep/ selector we can force a style down through the child component tree into all child component views. /deep/ selector forces its style to its own component, child component, nested component, view children and content children. Suppose we have components with parent child relationship as follows. 

    PersonComponent -> CompanyComponent -> AddressComponent

  In PersonComponent we are using following CSS file with /deep/ selector. 
  >>> will force PersonComponent style to Company and Address component.

NOTE: as of 11.2017:
https://angular.io/guide/component-styles
The shadow-piercing descendant combinator is deprecated and support is being removed from major browsers and tools. As such we plan to drop support in Angular (for all 3 of /deep/, >>> and ::ng-deep). Until then ::ng-deep should be preferred for a broader compatibility with the tools.




===============================================================================


Structural Directives
---------------------

  structural directives like ngIf do their magic by using HTML 5 template tag.



ngIf

  conditionally includes a template based on the value of an expression.

  element subtree is physically removed or added to the DOM.

    <div *ngIf="condition">...</div>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.
    The <div> containing "Text to show" is removed or added to the DOM based
    on the value of var 'show'.

      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show">Text to Show</div>


  safe navigation operator

    <table class='table' *ngIf='products?.length'>

      // safe navigation operator returns 'null' if the value is null 
      // and does not evaluate the expression 

    </table>



with else

    <div *ngIf="condition; else elseBlock">...</div>
    <ng-template #elseBlock>...</ng-template>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.  
    The <div> containing "Text to show" will either display "primary" text if 
    variable 'show' is true, or alternate - if false.


      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show; else elseBlock">Text to Show</div>
      <ng-template #elseBlock>Alternate text while primary is hidden</ng-template>

with async

    <button (click)="nextUser()">Next User</button>
    <br>
    <div *ngIf="userObserbable | async as user; else loading">
      Hello {{user.first}} {{user.last}}!
    </div>
    <ng-template #loading let-user>Waiting ... (user is {{user|json}})
    </ng-template>


  

  NOTE: visibility (hiding) and ngIf are not the same!

    we can show/hide an element subtree with a class or style binding.
    when we hide the element subtree, it remains in the DOM.  the subtree may
    tie up substantial memory and resources.

    when ngIf is false, Angular physically removes the element subtree from the DOM.
    it destroys components in the subtree potentially freeing up resources and
    resulting in better performance.

    on the flip side, when ngIf becomes true again, the component will be 
    recreated along with its subtree.  This may be expensive.. 

      Design thought: minimize initialization effort and consider caching state
      in a companion service.


ngSwitch

  ~~  do NOT put an (*) in front of ngSwitch ~~  
  use property binding instead.

  ~~ do use (*) with ngSwitchCase and ngSwitchDefault.

  when we want to display one element tree (and its children) from a set of 
  possible element trees, based on some condition.

  Angular puts on the selected element tree into the DOM.

  <span [ngSwitch]="toeChoice">
    <span *ngSwitchCase="'Eenie'">Eenie</span>
    <span *ngSwitchCase="'Meanie'">Meanie</span>
    <span *ngSwitchCase="'Miney'">Miney</span>
    <span *ngSwitchCase="'Moe'">Moe</span>
    <span *ngSwitchDefault>other</span>
  </span>


  we bind the parent NgSwitch directive to an expression returnng a switch value.
  the value is string in this example but it could be anything.

  at any particular time, at most ONE of these spans is in the DOM.

  if none of the spans is a match, Angular adds the default span to the DOM.. 
  and removes and destroys all other spans.

  Three collaborating directives work together here:

    ngSwitch
    ngSwitchCase
    ngSwitchDefault





nfFor
  
  is a repeater directive - our goal is to represent a list of items.
  we define a block of HTML that defines how  a single item should be 
  displayed - and we tell angular to use that block as template for rendering 
  each item in the list.

    ngFor applied to a simple <div>:

      <div *ngFor="let hero of heroes">{{hero.fullName}}</div>

    ngFor applied to a component element

      <hero-detail *ngFor="let hero of heroes" [hero]="hero"></hero-detail>



* and <template>

  the (*) is a bit of syntactic sugar that makes it easier to read and write 
  directives that modify HTML layout with the help of templates.

  NgFor, NgIf, and NgSwitch all add and remove element subtrees that are wrapped
  in <template> tags.

  This is how Angular expands *ngIf for example:

    <hero-detail *ngIf="currentHero" [hero]="currentHero"></hero-detail>

  1st expansion:

    <hero-detail 
        template="ngIf:currentHero" [hero]="currentHero"></hero-detail>    

  2d expansion:

    <template [ngIf]="currentHero">
      <hero-detail [hero]="currentHero"></hero-detail>
    </template>




Custom Attribute directives 

  HostListener
  HostBinding 
    class decorators
    prefer using these to the 'host' property of the @Directive and @Component decorators

    

================================================================================

  HTTP Services
  *************

The HttpModule is not a core Angular module.
It's Angular's optional approach to web access and it exists in a separate 
add-on module called @angular/http.

app.module.ts:

import { HttpModule }   from '@angular/http';

@NgModule({
  imports: [
    HttpModule
  ],
})
export class AppModule { }

Angular team recommends registering application-wide services in the root 
'AppModule' providers.


================================================================================

  Mocking HTTP Services with angular-in-memory-web-api
  ****************************************************

https://github.com/angular/in-memory-web-api
http://www.thoughtdelimited.org/thoughts/post.cfm/adding-the-in-memory-web-api-to-an-systemjs-based-angular-cli-application

in-memory web API is not part of the Angular core.
it is an optional service in its own "angular-in-memory-web-api" library installed 
with npm via package.json

Find out the latest version of 'angular-in-memory-web-api' available:

 $ npm view angular-in-memory-web-api versions
 
[ '0.1.0',
  '0.1.1',
  '0.1.2',
  '0.1.3',
  '0.1.4',
  '0.1.5',
  '0.1.6',
  '0.1.7',
  '0.1.8',
  '0.1.9',
  '0.1.10',
  '0.1.11',
  '0.1.12',
  '0.1.13',
  '0.1.14',
  '0.1.15',
  '0.1.16',
  '0.1.17' ]


$ npm install angular-in-memory-web-api --save

  "dependencies": {
    "@angular/common": "2.2.1",
    "@angular/compiler": "2.2.1",
    "@angular/core": "2.2.1",
    "@angular/forms": "2.2.1",
    "@angular/http": "2.2.1",
    "@angular/platform-browser": "2.2.1",
    "@angular/platform-browser-dynamic": "2.2.1",
    "@angular/router": "3.2.1",
    "angular-in-memory-web-api": "^0.1.17",



in-memory-data.service.ts
-------------------------



Learn more about In-Memory Web API
----------------------------------
https://angular.io/docs/ts/latest/guide/server-communication.html#!#in-mem-web-api

If the app only needs to retrieve data, you could get heroes from a heroes.json:

{
  "data": [
    { "id": 1, "name": "Windstorm" },
    { "id": 2, "name": "Bombasto" },
    { "id": 3, "name": "Magneta" },
    { "id": 4, "name": "Tornado" }
  ]
}


You wrap the heroes array in an object with a 'data' property for the same reason
that a data server does - to mitigate the security risk posed by top-level 
JSON arrays.

You'd set the endpoint to the JSON file like this:

  private heroesUrl = 'app/heroes.json'; // URL to JSON file


The GET heroes scenario would work, but you can't save changes to a JSON file.

The in-mem web API gets its data from a custom application class with a createDb() 
method that returns a map whose keys are collection names and whose values are
arrays of objects in those collections.


in-mem-data.service.ts
-----------------------

  import { Injectable } from '@angular/core';
  import { InMemoryDbService } from 'angular-in-memory-web-api';

  @Injectable()
  export class InMemoryDataService implements InMemoryDbService{

    constructor() { }

    createDb() {
      let heroes = [
        { id: 11, name: 'Mr. Nice' },
        { id: 12, name: 'Narco' },
        { id: 13, name: 'Bombasto' },
        { id: 14, name: 'Celeritas' },
        { id: 15, name: 'Magneta' },
        { id: 16, name: 'RubberMan' },
        { id: 17, name: 'Dynama' },
        { id: 18, name: 'Dr IQ' },
        { id: 19, name: 'Magma' },
        { id: 20, name: 'Tornado' }
      ];
      return {heroes};  // NOTE: curly braces!
    }

  }


Ensure that the HeroService endpoint refers to the web API

hero.service.ts
---------------

  private heroesUrl = 'api/heroes';   // URI to web api


Finally, redirect client HTTP requests to the in-memory web API by adding the
InMemoryWebApiModule to the AppModule.imports list, and call its forRoot() 
configuration method:

    InMemoryWebApiModule.forRoot(InMemoryDataService)

How This Works
==============

Angular's http service delegates the client/server communication tasks to a 
helper service called XHRBackend.

Using standard Angular provider registration techniques, the InMemoryWebApiModule
replaces XHRBackend service with its own in-memory alternative.

The forRoot() method initializes the in-mem web API with the seed data from the 
mock hero dataset.

    NOTE: 
    
    1. the "forRoot" method name is a strong reminder that you should 
    only call the InMemoryWebApiModule ONCE while setting the metadata for the 
    root AppModule

    2. Import the InMemoryWebApiModule AFTER the HttpModule to ensure that
    the XHRBackend provider of the InMemoryWebApiModule supersedes all others.

      import { HttpModule }           from '@angular/http';
      import { InMemoryWebApiModule } from 'angular-in-memory-web-api';


Passthru to a live XHRBackend
-----------------------------

If an existing running remote server should handle requests for collections
that not in the in-memory database, set 

  Config.passThruUknownUrl: true

This service will forward unrecognized requests via a base version of the 
Angular XHRBackend.




================================================================================

  Applications Styles
  *******************

When we add styles to a component, we're keeping everything a component needs -
HTML, the CSS, the code - together in one convenient place.

We can also create styles at the application level outside of any component.

angular-cli provides styles.css at the index.html level and it's already 
integrated into the project via 

angular-cli.json:

      "styles": [
        "styles.css"
      ],

styles.css - allows users to add global styles and supports CSS imports

  if the project is created with the --style=sass option, this will be a
  .sass file instead and the same applies to scss/less/style.

You can add more global styles via the apps[0].styles property in
angular-cli.json


================================================================================

  go back browser back button
  ***************************

to navigate one step in the browser's history stack using the 'Location' service

  this.location.back()

Going back too far could take us out of the application.
Guard against that with

  CanDeactivate guard  

================================================================================    

  Guard Services
  **************
https://angular.io/docs/ts/latest/guide/router.html#guards  


================================================================================

  Caching Service options
  ***********************

ng2-cache
https://www.npmjs.com/package/ng2-cache
https://github.com/Jackson88/ng2-cache


angular2-cache





================================================================================

  Caching with RxJs Observables in Angular 2
  ******************************************

http://www.syntaxsuccess.com/viewarticle/caching-with-rxjs-observables-in-angular-2.0

http://restlet.com/blog/2016/04/12/interacting-efficiently-with-a-restful-service-with-angular2-and-rxjs-part-2/

http://stackoverflow.com/questions/36271899/what-is-the-correct-way-to-share-the-result-of-an-angular-2-http-network-call-in



================================================================================

  Forms
  *****

Debugging forms with `spy` template reference variable
---------------------------

https://angular.io/guide/forms

Temporarily add a template reference variable named spy to the Name <input> tag and use it to display the input's CSS classes.

  <input type="text" class="form-control" id="name"
    required
    [(ngModel)]="model.name" name="name"
    #spy>
  <br>TODO: remove this: {{spy.className}}


================================================================================

  Testing
  *******

================================================================================

  Controlling which tests run in Jasmine
  **************************************

http://thejsguy.com/2016/01/03/controlling-which-tests-run-in-jasmine.html


Only Running Specific Tests / Specs
------------------------------------

If you want to run a specific test, use fit() instead of it(). The f stands for focused.

  describe("description", function() {
    fit("test 1", function() {

    });

    it("test 2", function() {

    });
  });

In the example above, only test 1 will execute. You can use as many fit() calls as you would like and only those tests will execute. Similar to when you exclude tests, if you are using Jasmine with Karma, the output on the terminal will note how many tests executed and how many were skipped.

What if you want to only run a specific describe() block? As you might guess, use fdescribe() instead of describe().

  fdescribe("description", function() {
    it("test 1", function() {

    });

    it("test 2", function() {

    });

    it("test 3", function() {

    });
  });

It is also worth noting that you can have focused and unfocused tests/specs inside nested fdescribe() blocks. When you do this, only the focused tests will run. For example:

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });

    fit("test 2", function() {

    });
  });

  fit("test 3", function() {

  });

  it("test 4", function() {

  });
});

In the example above, only test 2 and test 3 will run.

If your fdescribe() block only has a single test/spec, you can just use it() and that test will execute.

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });
  });

  fit("test 2", function() {

  });

  it("test 3", function() {

  });
});
In the example above, only test 1 and test 2 will execute.    


Excluding Tests / Specs
-----------------------

If you want to exclude a specific test, simply use xit() instead of it(). The x means exclude.

  describe("description", function() {
    xit("description", function() {

    });
  });

If you want to exclude an entire describe block, use xdescribe() instead of describe().

  xdescribe("description", function() {
    it("description", function() {

    });

    it("description", function() {

    });
  });

When you exclude tests, these tests will be noted as skipped.



================================================================================

  Error Handling
  **************

https://angular.io/api/core/ErrorHandler  

Catching global errors
----------------------

  https://stackoverflow.com/questions/44108285/angular-4-custom-errorhandler-doesnt-recognize-custom-error
  https://dpopescu.me/2016/10/21/catching-global-errors-in-angular-2/


================================================================================

  require
  *******

Typescript ERROR in build-info.ts (3,12): Cannot find name 'require'.


declare const require: any;  // add this line

export const build = {
  timestamp: new Date().toLocaleString(),
  version: require('../../package.json').version
};



================================================================================

  Add build version to your application
  *************************************

.deploy/build-info.ts
----------------------

import {BuildInfo} from '../src/app/shared/models/build-info.model';

declare const require: any;

export const buildInfo: BuildInfo = {
  timestamp: new Date().toLocaleString(),
  version: require('../package.json').version
};


environments/environment.ts
---------------------------

import { buildInfo } from '../../.deploy/build-info';

export const environment = {
  production: false,
  buildInfo: buildInfo
};


environments/environment.prod.ts
---------------------------

export const environment = {
  production: true,
  buildInfo: undefined
};

shared/models/build-info.model.ts
----------------------------------

export interface BuildInfo {
  timestamp: string;
  version: string;
}



footer.component.ts
-------------------

import { environment } from '../../environments/environment';
import {BuildInfo} from '../shared/models/build-info.model';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent implements OnInit {

  buildInfo: BuildInfo;

  constructor() { }

  ngOnInit() {
    this.buildInfo = environment.buildInfo;
  }
}


footer.component.css
--------------------

/** build-info */
.build-info-container {
  position: relative;
  display: inline-block;
}
.build-info-container .build-info-text {
  visibility: hidden;
  width: 200px;
  line-height: 10px;
  font-size: 10px;
  background-color: #f2f2f2;
  color: #373737;
  text-align: left;
  border: 1px solid #121212;
  border-radius: 6px;
  padding: 2px 5px 2px 5px;
  /* position */
  position: absolute;
  z-index: 1;
  top: 60%;
  left: 50%;
  margin-left: -100px;
}
.build-info-container:hover .build-info-text,
.build-info-container:active .build-info-text {
  visibility: visible;
}
/** end build-info */



footer.component.html
----------------------

<div class="container">
  <div class="app-footer-container">
    <div class="copyright pull-left build-info-container">
      <p>&copy; 2017</p>
      <div *ngIf="buildInfo" class="build-info-text">
        <span>build.timestamp: {{buildInfo.timestamp}}</span><br>
        <span>build.version: {{buildInfo.version}}</span>
      </div>
    </div>
  </div>
</div>



================================================================================

  Centralized Store Pattern
  *************************

  Angular Ngrx Store 

http://blog.angular-university.io/angular-ngrx-store-and-effects-crash-course/  

Other references:
https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/
https://www.bersling.com/2017/06/05/state-management-ngrxstore-vs-angular-services/



origins: facebook counter bug

  unread messages counter was displaying incorrect results.

Every UI app has either implicitly or explicitly two types of data:

  - a Model, or Doman Model
  - a View Model

Model vs View Model

  what we see on the screen is not the Model, it is the View Model.
  sometimes, the View Model has a direct correspondence with the model,
  but most often they are two different models.

  there is also an extra bit of state is purely UI-only - e.g. which 
  element is currently selected.  


Centralized Store design Pattern
--------------------------------

  instead of transforming the Model into the View Model on the server
  as it is usually done, let's instead copy the Model to the client-side,
  keep it in in-memory client database and derive View Models last second
  on the client side instead of doing so upfront on the server.

  1. create a client-side in-memory database for the application data
  2. bring the real domain data, the Model, to the f/e
  3. keep that Model data which is a user-specific slice of the DB
     in that in-memory DB
  4. put the client-side in-mem DB inside a centralized service (Store)
  5. ensure the centralized service owns the data by either ensuring
     its encapsulation or exposing it as immutable
  6. this centralized service will have reactive properties, so we can
     subscribe to it to get notified when the Model data changes.


  View Models are produced 

    - each component that needs to produce a View Model of the data will
      subscribe to get new versions of the in-mem DB data

    - each component will upon reception of the Model data produce 
      its own View Model, last second at the component level.

    - ensure that all View Models are always in sync with the centralized
      Data Model

    - transformation from Model to View Model is done last second on the 
      View Root itself, not on the server

    - transformation from view to view Model is done via a function called
      a Selector - the input of a Selector is the Model, and the output
      is the View Model

  How the Model data in the Store is modified

    - the data can only be modified inside the centralized service by 
      the Store itself

    - if a component wants to trigger modifications of the data, it sends
      a message to the centralized service using an Action object

    - the emitter of the action doesn't know which parts of the application
      will be affected by the action

    - new version of the application Model state is produced by taking
      the previous state and the action and applying Reducer function

    - Reducer function can be split into multiple smaller functions
      each modifying a part of the state

    - when the new state Model is avilable, it get broadcast to all 
      interested components, which will then transform it into their 
      View model

    - the new state model is frozen before getting broadcast so that
      the subscribers cannot modify it

================================================================================

  Content Projection
  ******************

what problem is it solving?
---------------------------

say, we have JokeComponent .. 

    @Component({
      selector: 'joke',
      template: `
    <div class="card card-block">
      <h4 class="card-title">{{ data.setup }}</h4>
      <p class="card-text" [hidden]="data.hide">
        {{ data.punchline }}
      </p>
      <button class="btn btn-primary"
        (click)="data.toggle()">Tell Me</button>
    </div>
      `
    })
    class JokeComponent {
      @Input('joke') data: Joke;
    }

and JokeListComponent

    @Component({
      selector: "joke-list",
      template: `
    <joke-form (jokeCreated)="addJoke($event)"></joke-form>
    <joke *ngFor="let j of jokes" [joke]="j"></joke>
    `
    })
    class JokeListComponent {
      jokes: Joke[];
      .
      .
    }


  let's say someone else wanted to use our <JokeComponent> but instead of 
  displaying it in a <p> tag they wanted to display the punchline
  in a larger <h1> tag.

  right now, the JokeComponent does not allow this type of customization.


  We can design our component with something called "content projection" 
  to enable it to be customised by the component or developer who is using
  it.


ng-content
-----------------

when we add 

  <ng-content></ng-content>

anywhere in our template HTML for our component, the inner content of the tags
that define our component are oftent `projected` into this space.

So if we changed the template of the "JokeComponent" to be:

  <div class="card card-block">
    <h4 class="card-title">{{ data.setup }}</h4>
    <p class="card-text" [hidden]="data.hide">
      <ng-content></ng-content>
    </p>
    <button class="btn btn-primary"
      (click)="data.toggle()">Tell Me</button>
  </div>

and the JokeListComponent template to this

    <joke-form (jokeCreated)="addJoke($event)"></joke-form>
    <joke *ngFor="let j of jokes" [joke]="j">
      <h1>{{ j.punchline }}</h1>
    </joke>


This is called CONTENT PROJECTION -> we project content from 
the PARENT component to the CHILD component.


================================================================================

  Angular libraries with schematics
  *********************************

https://github.com/caroso1222/ng-lib-schematics

================================================================================

  Angular Component Communication
  *******************************


Communicating with a Template
------------------------------

to notify component of changes in the template


  Two-way binding - the long way:
  -------------------------------

  <input type='text'
         [ngModel]='listFilter' // ngModel binding directive binds ngModel to 
                                // to component' `listFilter` property
          (ngModelChange) = 'onFilterChange($event)'/>
                                // ngModelChange event is then bound to
                                // a function


  communicating with getters/setters
  ----------------------------------

    component: 

    private _listFilter: string;


    get listFilter(): string {
      return this._listFilter;
    }

    set listFilter(value: string) {
      this._listFilter = value;
      this.performFilter(this._listFilter);
    }

    template:

    <input type='text'
      [(ngModel)]='listFilter' />

  angular two-way binding communicates with the component using the exposed
  getter/setter by convention.



  ViewChild
  ------------------------------

  DOM
    let divElement = document.getElementById('divElement');

  Angular Decorator
    @ViewChild('divElementVar') divElementRef: ElementRef;

          <div #divElementVar>{{pageTitle}}</div>


    The selector could also be 

      - angular diretive like `ngModel`

      @ViewChild(NgModel) filterInput: NgModel;

        the ViewChild decorator then looks in the template for the specified 
        directive:

          <input type='text' [(ngModel)]='listFilter' />

      - a child component or a custom directive

      @ViewChild(StarComponent) star: StarComponent;

        the ViewChild decorator then looks in the template for the custom 
        directive or child component of the defined type:

          <pm-star [rating] = 'product.starRating'></pm-star>

      - template reference variable

      @ViewChild('divElementVar') divElementRef: ElementRef;

          <div #divElementVar>{{pageTitle}}</div>


  ViewChildren
  ----------------------------


      - angular directive
        @ViewChildren(NgModel) inputs: QueryList<NgModel>;

      - custom directive or child component
        @ViewChildren(StarComponent) stars: QueryList<StarComponent>;

      - template reference variable(s)
        @ViewChildren('divElementVar') divElementRefs: QueryList<ElementRef>;



  communicating with @ViewChild
  ------------------------------


  component

    using template reference variable: #filterElement:

    @ViewChild('filterElement') filterElementRef: ElementRef;

    /* setting focus on this DOM element */
    ngAfterViewInit(): void {
      this.filterElementRef.nativeElement.focus();
    }


  template

    <input type='text' #filterElement
          [(ngModel)] = 'listFilter' />



          Component lifecycle:  
            Component Constructed -> Initialized
            Component's View Initialized -> Rendered

            when in the Component's constructor, the View is not yet rendered


            ngAfterViewInit() 
              executes after component's view is initialized and rendered
              this is where we can reliable use a property 
              with ChildView decorator.


  Note: when using ViewChild to access nativeElement:

    - you're directly accessing the DOM!
    - tightly coupled to the browser
    - may not be able to use server-side rendering
    - can pose a security threat if accessing innerHtml




    Parent/Child relationship between component
------------------------------------------------

For components to have parent/child relationship, 
the parent component's template must CONTAIN the child component.

Components related via routing do NOT have parent/child relationship even if
they have child routes - i.e. if a commponent is displayed in another component
using a <router-outlet>.



Communicating thru a Service
*********************************


Managing State techniques:

  1. Property Bag

    you define a service that has simple properties that components need:

      @Injectable()
      export class ParamService {
        showImage: boolean;
        filterBy: string;
      }

2. Basic State Management

    a service that retrieves, manipulates, inserts, deletes .. app state

      @Injectable() 
      export class ProductService {

        private products: IProduct[];

        getProducts() {}
        getProduct(id: number) {}
        createProduct(product: IProduct) {}
        . . .

      }

3. State Management With Notifications

    with notifications using Subject, BehaviorSubject or similar

      @Injectable()
      export class ProductService {
        private selectedProduct: IProduct;

        private selectedProductSource = new BehaviorSubject<IProduct>();

        selectedProductChanges$ = this.selectedProductSource.asObservable();
      
        . . .
      }


4. ngrx / Redux


    ngrx is based on 4 core tenets:

      4.1 state: immutable
      4.2 actions: state changes
      4.3 reducers: state + action = new state
      4.4 store: 
              Observable of state
              Observable of actions



Using Property Bag service
---------------------------

When user makes selections, those values are stored in the component.
When user navigates away from the component, it is destroyed.
When user returns to it, it is re-initialized with default values and it has
no memory of user selections.

If a service is introduced, user selections would be stored in the service, 
which is now used to maintain the state of user selections.

  @Injectable()
  export class ProductParameterService {

    showImage: boolean;
    filterBy: string;

    constructor() { }

  }


component:

    constructor(
      private productParameterService: ProductParameterService) {
    }

    get showImage(): boolean {
        return this.productParameterService.showImage;
    }

    set showImage(value: boolean) {
        this.productParameterService.showImage = value;
    } 

In the component, class property `showImage` is replaced with getter/setter
which in turn delegate to the service to read/update the property.

Property bag retains the values when the component is destroyed.

However, 

  property bag service can communicate changes to components ONLY if they 
  use template property binding.


Service scope and lifetime
---------------------------

  Service can be registered in the  `providers` array of a component or a module.

  where we register, defines the service' scope and lifespan.

    component: 

      @Component({
        . . .
        providers: [
          ProductService
        ]
      })

    the service is available to the component and all of its children.

- if you register the service in the Root App Component, the service will be
  retained for the life of the application.

- if you register a service in a non-root component, it will be available to
  it all of its children, and it will be retained ONLY while that component is
  loaded.

- if you register a service in two different components, you will get two 
  different instances of the service.

  To monitor the scope and lifecycle of a service:

    @Injectable()
    export class SomeService implements OnDestroy {

      constructor() {
        console.log('Service created');
      }

      ngOnDestroy() {
        console.log('Service destroyed');
      }
    }

- if you register a service in a module, the service is registered in the app's
  root, so it is available to all components in the application 
  for the lifetime of the application.

  however, if the module is lazy-loaded, the service will be available only 
  to the components in that module.  once the module is loaded, it is availble
  for the lifetime of the application.


Data Access Service
-----------------------

data access service could be a pass-thru for components to a backend server,
however in many cases, it is a state management service sharing entity state
across components and services.

service properties become a data cache.

purpose of State Management Service:

- provide state values
- maintain and update state
- observe state changes

to do that

- add a property to retain data
- optionally, add code to expire data when stale


Property Bag vs State Management Service
-----------------------------------------

 property bag to:               state mgmt service to:

  retain view Setting           retrieve, manage, store state
  pass data between component   share state between components

                                methods to encapsulate retrieve operations
                                retains and shares state values
                                provides change notifications for BOUND values with getter

                                cons:

                                  stale data
                                  need to expire
                                  consider getting fresh data before updating/deleting
                                  state is not immutable


Binding and Change Detection
-----------------------------

Angular change detection watches all the property changes that are bound 
to templates, even if the property changes in the service:


template

  // template binding to a property in component
  name: {{product.productName}}

component

  export class ProductDetailComponent {
    // bound property
    product: IProduct;

    ...

      this.product.productName = 'Steel Hammer';
  }

service

  export class ProductService {

    // bound property
    currentProduct: IProduct;
  }

product shell list component

  onSelected(product: IProduct) {
    this.productService.currentProduct = product;
  }

product detail component

  // getter is bound to property in the service
  get product(): IProduct {
    return this.productService.currentProduct;
  }

product detail template
  // template binding to component property
  Name: {{product.productName}}



================================================================================





