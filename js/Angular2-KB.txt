
	@@@@@@@@@@@@@@@@@

		Angular 2

	@@@@@@@@@@@@@@@@@



  Architecture
  *************

Angular applications are composed of:
  1. HTML templates with angularized markup,
  2. component classes to manage those templates
  3. services with application logic
  4. modules combing components and services

You launch the app by bootstrapping the root module


8 main building blocks of an Angular app:

1. Modules
2. Components
3. Templates
4. Metadata
5. Data binding
6. Directives
7. Services
8. DI


Routing
-------

  Routing is another name for navigation.
  The router is the mechanism for navigating from view to view.
  Routes tell the router which views to display when a user clicks a link
  or pastes a URL into the browsers' address bar.


  Router 

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

  When the router navigates to a new component view, it updates the browser's 
  location and history with a URL for that view.  This is a strictly local URL.
  The browser should not send this URL to the server and should NOT reload the
  page.

  The Angular Router supports two techniques for achieving that with the help
  of two LocationStrategy providers:

  1. PathLocationStrategy - the default "HTML 5 pushState" style
  2. HashLocationStrategy - the "hash URL" style

  The first one relies on the modern HTML 5 browsers' support for history.pushState
  technique.

  Older browsers send page requests to the server when the location URL changes.. 
  unless the change occurs after a "#" hash.  Routers take advantage of this
  exception by composing in-application route URLs with hashes. e.g.:

    localhost:3002/src/#/crisis-center/



   <head>
    <base href="/">

    base href is important to make history.pushState work
    add the base href just under the <head> tag.

    if the "app" folder is the application root, set the href value to "/".

    The Router uses the browser's pushState for navigation.
    Thanks to pushState, we can make our in-app URL paths look the way 
    we want them to look.

    Our in-app URLs can be indistinguishable from server URLs.

    The browser also needs the base <href> value to prefix relative URLs.



    ActivatedRoute
    **************

ActivatedRoute is a service provided to each route component that contains 
route specific information such as:

  - route parameters
  - static data
  - resolve data
  - global query params
  - the global fragment

The route path and parameters are available through an injected router service
called ActivatedRoute:

  url
    an Observable of the route path(s) represented as an array of strings 
    for each part of the route path

  data

  paramMap
    an Observable that contains a map of the required and optional parameters

  queryMapParam
    an Observable that contains a amp of the query parameters available to 
    all routes.

  fragement
  outlet
  routeConfig
  parent
  firstChild
  children


  Reading path parameters
  -----------------------


  use ngOnInit() {.. }


  /heroes/hero-detail;code=ADADA

  paramMap

    constructor(private route: ActivatedRoute) {
      console.log('HeroDetailComponent: call me "/heroes/hero-detail"');
      this.route.paramMap.subscribe(
        params => {
          console.log('constructor code=', params.get('code'));
        }
      );
    }


  Query parameters
  ----------------

  /heroes/hero-detail?code=ADADA


  Use ngOnInit() - angular guide shows that

  constructor(private route: ActivatedRoute) {
    console.log('HeroDetailComponent: call me "/heroes/hero-detail"');
    this.route.queryParamMap.subscribe(
      params => {
        console.log('constructor code=', params.get('code'));
      }
    );
  }


  ngOnInit() {
    this.route.queryParamMap
      .subscribe( (queryParams: ParamMap) => {
        console.log('ngOnInit: code=', queryParams.get('code'));
    });
  }


================================================================================



1. Modules
-----------
  
every app has at least one module - root - named "AppModule"

other modules are "feature" modules

each module is a cohesive block of code dedicated to an app domain, a workflow, 
or a closely related set of capabilities.

any module, root or feature, is a class with @NgModule decorator


NgModule
--------

  NgModule is a decorator function that takes a single metadata object whose
  properties describe a module.

    - declarations

      = view classes that belong to this module. 3 types of view classes:
        1. components
        2. directives
        3. pipes
    
    - exports
      = subset of the declarations that should be visible and usable 
      in the component templates of OTHER modules
    
    - imports
      = other modules whose exported classes are needed by component
      templates declared in this module
    
    - providers
      = creators of services that this module contributes 
      to the global collection of services
      they become accessible in all parts of the app
    
    - bootstrap [ROOT only]
      = the main application view, called 'root component'
      only ROOT module should set this "bootstrap" property

example of root module

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  @NgModule({
    imports:      [ BrowserModule ],
    providers:    [ Logger ],
    declarations: [ AppComponent ],
    exports:      [ AppComponent ], // just for demo - no one needs root module
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

bootstrap root in main.ts

app/main.ts:

  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
  import { AppModule } from './app.module';

  platformBrowserDynamic().bootstrapModule(AppModule);

Angular modules and JavaScript modules

  be aware that you're using the two systems side by side:

    import { Component } from '@angular/core';
    .
    .
    .
    @NgModule({
      imports:  [ BrowserModule ],
      ...
    })

2. Components
----------------------------------------

   a component controls a patch of screen called a 'view'
   e.g., the following views are controlled by components:
    - app root with navigation links
    - list of heros
    - hero editor

  you define a component's logic - what it does to support the view - inside
  a class.  The class interacts with the view thru an API of properties and
  methods.

    e.g. this HeroListcomponent has a 'heroes' property that returns an array
    of heroes that is acquires from a service.
    it also has a selectHero() method that sets a selectedHero property when
    a user clicks to choose a hero from that list.


3. Templates
----------------------------------------

  you define a component's view with its companion template.
  a template is a form of HTML that tells Angular how to render the component.
  In addition to HTML, templates use Angular's template syntax.


  Template syntax
  ***************

  Templates display data and consume user events with the help of data binding.

    MVC or MVVM (mode-view-viewmodel)

  In Angular, the component plays the part of the Controller/Viewmodel, and
  the template represents the view.

    Basic Elements of Template syntax

  HTML
  Interpolcation
  Template expressions
  Template statements
  Binding syntax
  Property binding
  Attribute, class and style bindings
  Event binding
  Two-way data binding
  Built-in directives (NgClass, NgStyle, NgIf, NgFor, etc.)

  HTML
    almost all HTML syntax is valid template syntax.
    <script> element is notable exception - forbidden due to injection risk

  interpolation
    we use interpolation to weave calculated strings into the text between HTML element
    tags and within attribute assignments

        <h3>
          {{title}}
          <img src="{{heroImg}}" ... >
        </h3>

  template expressions
    produce a value
    angular executes the expression and assigns it to a property of a binding target

      [property]="expression"

      [disabled]="isUnchanged"

    template expressions cannot refer to anything in the global namespace.
    can't refer to window or document, can't call console.log or Math.max

    the expression context is typically the component instance which is the source
    of binding values.

    Guidelines:

      - a template expression should not change any application state other than
        the value of the target property

      - quick execution
        template expressions execute frequently - can be called every key press or
        mouse move        

      - simplicity: a property or method call should be the norm. ! is OK occasionally

      - idempotence: should be free from side effects

        Binding syntax

          from data source to view target:

        {{expression}}
        [target-property] = "expression"

          from view target to data source:

        (target) = "statement"
        on-target = "statement"


          two-way

        [(target)] = "expression"
        bindon-target = "expression"

    <button disabled>Save</button>

  with data binding

    <button [disabled]="isUnchanged">Save</button>                  


    Binding Targets

      the target of data binding is something in DOM.
      it could be a element | component | diretive property
      an event (element | component | directive) 

      binding type: property

        target:

          element property:

                <img [src] = "heroImgUrl">

              component property

                <hero-detail [hero]="currentHero"></hero-detail>

              directive property:

                <div [ngClass] = "{selected: isSelected}"></div>

      binding type: event                  

        target: 

          element event

              <button (click) = "onSave()">Save</button>


              <button (click)="show = !show"> {{show ? 'hide' : 'show'}} </button>

              presuming the component owning this template has something like:

                show: boolean = false;

              the button is bound to DOM event (click) which will trigger 
              the action indicated by the text in quotes.  Here, variable
              `show` will assigned the opposite value of self.
              The button text is bound to that variable `show`, so clicking
              the button will toggle the button text.



          component event

              <hero-detail (deleteRequest)="deleteHero()"></hero-detail>

          directive event

              <div (myClick)="clicked=$event">click me</div>



      binding type: two-way              

        target

          event and property

              <input [(ngModel)]="heroName">


      attribute

        <button [attr.aria-label]="help">help</button>

      class

        <div [class.special]j="isSpecial">Special</div>

      style

        <button [style.color] = "isSpecial ? 'red' : 'green'">


      How the parent and child components can communicate with each other:
      ---------------------------------------------------------------------

        <hero-detail [hero]="currentHero"></hero-detail>
      


4. Metadata
----------------------------------------



5. Data binding
----------------------------------------

  you display data by binding controls in an HTML template to properties
  of an Angular component.


    Template binding works with DOM PROPERTIES, not HTML attributes.



  one-way from data source to view target
  ---------------------------------------

      1. property style

       {{expression}} expression interpolation

          <ul>
            <li *ngFor="let hero of heroes"> {{hero}} </li>
          </ul>

      2. attribute style

        [target]="expression"

          e.g. bind 'isUnchanged' property to button disabled state

            <button [disabled]="isUnchanged">Save</button>

              you're binding the button's 'disabled' attribute and setting
              it to the current value of the component's 'isUnchanged' property.. 
              right?  WRONG

              These are not HTML attributes - these are properties fo DOM
              elements, components and directives.


      3. class style

        bind-target="expression"



  one-way from view target to data source
  ---------------------------------------

      Event 

        (view-target)="statement"
        
        on-target="statement"


  two-way 
  --------


      [(target)]="expression"

      bindon-target="expression"


      /**********************************
       *                                *
       * HTML attribute vs DOM property *
       *                                *
       **********************************/


  Attributes are defined by HTML.
  Properties are defined by the DOM.

  * a few HTML attributes have 1:1 mapping to properties.
    'id' is one example

  * some HTML attributes have no corresponding properties - e.g. colspan

  * some DOM props don't have corresponding attributes - textContent, e.g.

  * many HTML attrs seem to map to properties, but not the way you think!

  Attributes initialize DOM properties and then they are DONE.
  Property values can change; attributes do not.

  e.g. when the browser renders 

    <input type="text" value="Bob">

  it creates a corresponding DOM node with a 'value' property initialed to "Bob".
  when the user enters "Sally" into the input box, the DOM element 'value' 
  property becomes "Sally".  But the HTML 'value' attribute REMAINS 
  unchanged as you can confirm by asking:

    input.getAttribute('value');  // returns "Bob"

  the HTML attribute value specifies the INITIAL value; the DOM value property
  is the CURRENT value.

  The 'disabled' attribute is another peculiar example.
  A button's 'disable' PROPERTY is "false" by default so it is enabled.
  when you add the 'disabled' attribute, its presence alone initializes the 
  button's 'disabled' property to "true" to the button is disabled.

  Setting the button's 'disabled' property disables|enables the button - 
  the value of the PROPERTY matters (attribute does not).


Type

  Property

    element:  <img [src]="heroImageUrl">

    component:  <hero-detail [hero]="currentHero"</hero-detail>

    directive:  <div [ngClass]="{'special': isSpecial}">

                </div>

  Event

    element:   <button (click)="onSave()">Save</botton>

    component: <hero-detail (deleteRequest)="deletedHero()"></hero-detail>
     
    directive:  <div (myClick)="clicked=$event" clickable>click me</div>


  Attribute

    attribute:  <button [attr.aria-label]="help">help</button>

  Class

    property:   <div [class.special]="isSpecial">Special</div>


  Style

    property:   <button [style.color]="isSpecial ? 'red' : 'green'">



  Two-way

    event and property:   <input [(ngModel)]="name">


6. Directives
----------------------------------------

  A directive is a class with directive metadata.
  In TS, apply the @Directive decorator to attach metadata to the class.

  A component is a "directive-with-a-template".
  @Component decorator is actually a @Directive extended with template-oriented
  features.

  two other kinds of directives exist:

  1. structural
  2. attribute

  structural directives
  ...................................

    alter layout by adding, removing, and replacing elements in DOM.
    the example template uses two built-in structural directives

      <li *ngFor="let hero of heroes"></li>
      <hero-detail *ngIf="selectedHero"></hero-detail>

    *ngFor tells Angular to stamp out one <li> per hero in the 'heroes' list

    *ngIf includes the HeroDetail component only if a selected hero exists.



  attribute directives
  ...................................    

    alter the appearance or behaviour of an existing element.
    In templates, they look like regular HTML attributes, hence the name.

    ngModel directive implements two-way binding and is an example of an
    attribute directive.

    it modifies the behaviour of an existing element (typically <input>) by 
    setting its display value property and responding to change events:

      <input [(ngModel)]="hero.name">

  custom attribute directive
  .....................................

  $ ng g d highlight

    import { Directive, ElementRef, Renderer } from '@angular/core';

    @Directive({
      selector: '[highlight]'
    )}
    export class HighlightDirective {

      // this is a short cut for creating a private field at the class level
      // and assigning to it in the constructor/method call
      constructor(private elementRef: ElementRef, private renderer: Renderer) {
        this.renderer.setElementStyle(
          this.elementRef.nativeElement, 
          'background-color', 
          'green');
      }

    }
          


7. Services
----------------------------------------

  Service is a broad category encompassing any value, function, or feture that
  your application needs.

  Almost anything can be a service.
  Typically is a class with a narrow, well-defined purpose.
  Examples:
  - logging service
  - data service
  - message bus
  - tax calculator
  - application configuration

Angular has no definition of services.
There is no service base class, and no place to register a service.
Yet services are fundamental - components are big consumers of services.

example of a service class that logs to browser console:
app/logger.service.ts:

  export class Logger {
    log(msg: any) { console.log(msg); }
    error(msg: any) { console.error(msg); }
    warn(msg: any) { console.warn(msg); }
  }

example of HeroService that fetches heroes and returns them in a resolved
Promise.  This services also depends on the Logger service and another 
BackendService that handles the server comm grunt work:

app/hero.service.ts

  export class HeroService {
    private heroes: Hero[] = [];

    constructor(
      private backend: BackendService,
      private logger: Logger
    ) {}

    getHeroes() {
      this.backend.getAll(Hero).then(
        (heroes: Hero[]) => {
          // ... 
        });
      );
    }
  }

Component classes should be lean - they don't fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.

A component's job is to enable the user experience - nothing more. 
It mediates between the view (rendered by the template) and the application
logic (which often includes some notion of a model).

A good component presents properties and methods for data binding.
It delegates everything non-trivial to services.



  Async Services and Promises
  ...........................

if a service calls a remote server like

  this.heroes = this.heroService.getHeroes();

the method call sig is synchronous - and we will have to wait for the server to
respond and we won't be able to block the UI while we wait.

  Promises
  --------

A Promise is a promise to call us back later when the results are ready - 
we ask an async service to do some work and give it a callback function.



8. DI
----------------------------------------

Main points:

  injector - main DI mechanism

    maintains a container of service instances that it created

    can create a new service instance from a provider

  provider is a recipe for creating a service

  you register providers with injector
  
      
      
  Services and DI
  ---------------

Most dependencies are services - Angular uses DI to provide new components with the 
services they need.
Angular can tell which services a component needs by looking at the types of 
its constructor parameters.

E.g. constuctor of the HeroListcomponent:

  constructor(private service: HeroService) {}

When Angular creates the component, it asks an INJECTOR for the services that 
the component requires.

An injector maintains a container of service instances that it has previously
created.  If a requested service instance is not in the container, the 
injector makes one and adds it to the container before returning the service 
to Angular.

    How does the injector know how to make one?

You must have previously registered a PROVIDER of the HeroService with the 
injector.  A provider is something that can create or return a service, 
typically a service class itself.  You can register providers in modules or
in components.

In general, add providers to the root module so that the same instance of a
service is available everywhere.

    root module
    app/app.module.ts

      providers: [
        BackendService,
        HeroService,
        Logger
      ],

alternatively, register at a component level in the providers property of 
the @Component metadata:

  app/hero-list.component.ts

    @Component({
      moduleId: module.id,
      selector: 'hero-list',
      templateUrl: 'hero-list.component.html',
      providers: [ HeroService ]
    })

registering at a component level means you get a NEW instance of the service
with each NEW instance of that component.



Pipes
------------------------------------------

Pipes are a good way to format strings, currency amounts, dates and other
display data.

Angular ships with several pipes and we can write out own.


  Async Pipe
  ----------

Usage:

  <div>{{ observableTime | async }}</div>

Purpose:

  unwrap a value from an asynchronous primitive.
  if we have an Observable or Promise instance, then we can use it directly
  with AsyncPipe using diretives like 'ngFor', 'ngIf' and 'NgSwitch'.

  subscribes to Observable or Promise and returns latest data.

  marks the component to check for data changes.

    NgFor Example
    .............

      @Injectable() service to fetch book data

      component to display that data

        <ul>
          <li *ngFor="let book of observableBooks | async" >

            Id: {{book.id}}, Name: {{book.name}}

          </li>
        </ul>

      in component:

        ngOnInit(): void {
          this.observableBooks = this.bookService.getBooks();
        }

    NgIf and NgSwitch Example
    .........................

      <div *ngIf="promiseBook | async as book; else loading">
        Id: {{book.id}}, Name: {{book.name}}
      </div>
      <ng-template #loading>Loading Data .. </ng-template>

      <h3>AsyncPipe with NgSwitch</h3>

      <div [ngSwitch]="(promiseBook | async)?.id">

        <div *ngSwitchCase="100">Find Actual Data</div>
        <div *ngSwitchDefault>Showing Default Data</div>

      </div>



==============================================================================

  template syntax
  ***************

https://angular.io/docs/ts/latest/guide/template-syntax.html

interpolation  
----------------------------------------

  {{title}}
  {{ 1 + 1 + getVal() }}


template expressions
----------------------------------------
  produces a value
  angular executes the expression, assigns it to a property of a binding
  target - a HTML element, a component, or a directive

    [property] = "expression"



template statements
----------------------------------------

  (event) = "statement"

  a template statement responds to an event raised by a binding target such as
  an element, component, or directive

  has side effect
  it's how we update application state from user input.
  there would be no point to responding to an event otherwise.



Data binding
************

  component logic interacts with component template (view)

  - string interpolation
    {{exp resolving to a string}}

  - property binding
    binding data to properties in your DOM
    <button [disabled] = "exp resolving to required value type">  

  - event binding 
    binding DOM events back to the model
    <button (click) = "expression handling the event">

  - two-way binding
    by default all Angular2 data binding is uni-diretional
    for performance reasons.
    <input [(ngModel)] = "bound model (e.g. object)">


binding syntax
----------------------------------------

  one-way
  from data source to view target   
        {{expression}}
        [target] = "expression"
        bind-target = "expression"

  one-way
  from view target to data source
        (target) = "statement"
        on-target = "statement"

  two-way
        [(target)] = "expression"
        bindon-target = "expression"



property binding
----------------------------------------
  we write a template property binding when we want to set a property of a
  view element to the value of a template expression. 
  e.g. binding the 'src' property of an image to 'heroImageUrl' property:

    <img [src] = "heroImageUrl">

  disabling a button when the component says that it "isUnchanged"

    <button [disabled] = "isUnchanged">Cancel is disabled</button>

  setting a property of a directive

    <div [ngClass] = "classes">[ngClass] binding to the classes property</div>
    <div (ngSubmit) = "..."></div>   

  binding to component properties

    <cmp [initObj] = "...">
    <cmp (rndEvent) = "...">    

  custom bindings

    Property Binding (@Input)

      @Input() propertyName: string 

    one-way in
    ----------

  property binding is described as "one-way data binding" because it
  flows a value in one direction, from a component's data property into
  a target element property.





attribute, class and style bindings
----------------------------------------





event binding
----------------------------------------

  User interact with your application
  - they click buttons
  - pick items from lists
  - enter text into input boxes

  Such user actions may result in data flowing in the opposite direction:

  data flow:

    from an element to a component

  The only way to know about a user action is to listent for certain events 
  such as keystrokes, mouse movements, clicks and touches.

  We declare our interest in user actions thru Angular event binding.

  Event Binding syntax

    (target event) = "template statement"

      TARGET EVENT - appears between parenthesis.

        <button (click) = "onSave()">Save</button>  

      Canonical form:

        some people prefer the "on-" prefix alternative, known as canonical form:

        <button on-click="onSave()">On Save</button>

  Matching order

    - directives
    - elements

    element events may be the more common targets, but Angular looks to see 
    if the name matches an event property of a known directive FIRST.

      <!-- 'myclick' is an event on the custom 'clickDirective' -->
      <div (myClick)="clickmessage=$event">click with myClick</div>


    $event 
    ........................

    In an event binding, Angular sets up an event handler for the target event.

    when the event is raised, the handler executes the template statement.
    The template statement typically involves a receiver which performs an action
    in response to the event, such as storing a value from the HTML control 
    into a model.

    the binding conveys info about the event, inclu data values, thru an
    event object named 

      $event

    the shape of the event object is determined by the target event.
    If the target event is a native DOM element event, then $event is a
    DOM event object, with properties such a "target" and "target.value"

      <input [value]="currentHero.firstname"
             (input)="currentHero.firstname=$event.target.value">

    this code:
      - sets the input box "value" property by binding to the "firstName" 
        property
      - to listen for changes to the value, the code binds to the input box's
        "input" event.  when the user makes changes, the "input" event is 
        raised, and the binding executes the statement within a context that
        includes the DOM event object, $event.
      - to update the "firstName" property, the changed text is retrieved from
          $event.target.value



    EventEmitter
    ........................                                   

      Directives typically raise custom events with an Angular EventEmitter.

      example

        consider a HeroDetailComponent that presents hero info and responds to 
        user actions.  Although the HeroDetailComponent has a delete button,
        it doesn't know how to delete the hero itself..
        The best it can do is raise an event reporting the user's delete request.

        template:
        -------------
          <dimatchingv>
            <img src="{{heroImageUrl}}">
            <span>{{prefix}} {{hero?.fullName}}</span>
            <button (click)="delete()">Delete</button>
          </div>

        hero-detail.component.ts (delete logic):
        ----------------------------------------

          // this component make a request but it can't actually delete a hero
          deleteRequest = new EventEmitter<Hero>();

          delete() {
            this.deleteRequest.emit(this.hero);
          }

        the component defines a "deleteRequest" property that returns an 
        EventEmitter.  When the user clicks "delete", the component invokes
        the "delete()" method telling the EventEmitter to emit a Hero object.

        Now, imagine a hosting parent component that binds to the 
        HeroDetailComponent's "deleteRequest" event:

          <hero-detail 
            (deleteRequest)="deleteHero($event)"
            [hero]="currentHero"></hero-detail>

        when the "deleteRequest" event fires, Angular calls the parent 
        component's "deleteHero(..)" method, passing the hero-to-delete 
        in the $event variable.





    Event Binding (@Output)  
    .......................

      @Output() eventName = new EventEmitter();  
    or
      <button (click)="onClicked()">Click Me</button>

      onClicked() {
        alert('it worked');
      }

    Binding to Custom events
    ........................

      <button (click)="onClicked()">Click Me!</button>

      @Output() clicked = new EventEmitter<string>();
      onClicked() {
        this.clicked.emit('It Works!');
      }

      now, to consume this custom event:

      <app-event-binding (clicked)="onClicked($event)"></app-event-binding>
      and in this component.ts:

      onClicked(value: string) {
        alert(value);
      }





two-way binding
----------------------------------------
built-in directives
----------------------------------------
* and <template>
----------------------------------------
template reference variables
----------------------------------------
input and output properties
----------------------------------------


     


======================================================================

  components
  ----------

Components are the main way we build and specify elements and logic on the page.

In angular 1, this was done with directives/controllers/scope.  In angular2, 
all those concepts are combined into components.

Here is a simple component:

import { Component } from '@angular/core';

  @Component({
    selector: 'my-component',
    // templateUrl: './my.component.html',
    // styleUrls: ['./my.component.css']
    template: '<div>Hello my name is {{name}}. <button (click)="sayMyName()">Say my name</button></div>'
  })
  export class MyComponent {
    console.log('My name is', this.name);
  }

selector
--------

  selectors work like a CSS selector.  so if we were to have 

    <my-component>

  element in our HTML document, angular would know what to load here.. 

  You can also use "hashtag" syntax:

    selector: '#app-root'

  Now, you can reference that selector via div id:

    <div id="app-root"> 




======================================================================

  Angular Modules 
  ***************

Angular Modules help organize an application into cohesive blocks of 
functionality.

Modules are a great way to organize the application and extend it with capabilities
from external libraries.  Many libraries are modules (e.g. FormsModule, HttpModule,
RouterModule).  Many 3rd party libs are available as Angular modules (e.g. Material
Design, Ionic, AngularFire2).

Modules consolidate components, directives and pipes into cohesive blocks of 
functionality, each focused on a feature area, application business domain, etc..

Modules can be loaded eagerly when the app starts, or lazy loaded asynch by the 
router.

Every Angular app has at least once module class - the root module.
We bootstrap that module to launch the application.

The root module is all we need in a simple application with a few components.
As the app grows, we refactor the root module into feature modules, and we
import these modules into root module.

An Angular Module is a class adorned with the @NgModule decorator function.

root module
-----------

By convention, root module is a class called 'AppModule' in a file named
app.module.ts

  import { NgModule }      from '@angular/core';
  import { BrowserModule } from '@angular/platform-browser';

  import
        { AppComponent }  from './app.component';

  @NgModule({
    imports: [ BrowserModule ],
    declarations: [ AppComponent ],
    bootstrap:    [ AppComponent ]
  })
  export class AppModule { }

NgModule
  this decorator defines the metadata for the module.
  this metadata imports a single helper module - BrowserModule - which 
  every browser app must import.

BrowserModule
  registers critical app service providers and 
  includes common directives like NgIf and NgFor

declarations
  this list identifies the application's only component, the root component
  "AppComponent"

bootstrap
  this property identies this AppComponent as the bootstrap component.
  When Angular launches the app, it places the HTML rendering of AppComponent
  in the DOM, inside the <my-app> element tags of the index.html.  


Example
-------

  Root Module

    app.module.ts

  Dashboard Module

    dashboard/
      dashboard-hero.component.ts
      dashboard.component.ts
      dashboard.module.ts
      dashboard-routing.module.ts


    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts  

  

======================================================================

  View Encapsulation
  ------------------

angular 2 emulates the concept of shadow DOM:

  an HTML element has its 'shadow' DOM

<div>
  <component _nghost-pax-1>
    <h1 _ngcontent-pax-1>... </h1>
  </component>
  <h1>won't be styled the same</h1>
</div>

  This is based on CSS Attribute Selectors.

  a[target] {
    background-color: yellow;
  }

========================================================================
	

==============================================================================

  angular component lifecycle
  ***************************
https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html

ngOnChanges
ngOnInit
ngDoCheck

  ngAfterContentInit
  ngAfterContentChecked
  ngAfterViewInit
  ngAfterViewChecked

ngOnDestroy

==============================================================================

  Twitter Bootstrap

@see angular-cli

==============================================================================

  creating a new service
  **********************

  $ ng g s <service-name> --flat --spec 

    --flat (default: true)


create config service
---------------------
$ mkdir src/app/shared
craiskin@xubi-one:~/ws/standard/iam/iam-demo-ng2-product-app $ ng g s shared/Config
installing service
  create src/app/shared/config.service.spec.ts
  create src/app/shared/config.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

create mdm product service
$ ng g s MdmProduct
installing service
  create src/app/mdm-product.service.spec.ts
  create src/app/mdm-product.service.ts
  WARNING Service is generated but not provided, it must be provided to be used


create ConfigService
--------------------

import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';

@Injectable()
export class ConfigService {
  public production: boolean = environment.production;
  public mdmProductServer: string = environment.MDM_PRODUCT_SERVER;
  public mdmProductApi: string = environment.MDM_PRODUCT_API;

  public mdmProductApiURL(): string {
    return this.mdmProductServer + this.mdmProductApi;
  }
}


Provide ConfigService in @NgModule AppModule:
---------------------------------------------

import { AppComponent } from './app.component';
import { environment } from '../environments/environment';
import { ConfigService } from './shared/config.service';


@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AlertModule
  ],
  providers: [ ConfigService ],
  bootstrap: [AppComponent]
})
export class AppModule {

  constructor() { }
}

use ConfigService in MdmProductService
--------------------------------------

import { Injectable } from '@angular/core';
import { ConfigService } from './shared/config.service';

@Injectable()
export class MdmProductService {

  constructor(private configService: ConfigService) { 
    console.log(`
      I'm MdmProductService, and I'm configured with ConfigService
      ConfigService.mdmProductServer: ${configService.mdmProductApiURL()}
    `);
  }

}





================================================================================

  RouterModule
  ************

  Angular router is an external optional Angular NgModule called RouterModule.

  It's a combination of 
   - multiple provided services (RouterModule)
   - multiple directives (RouterOutlet, RouterLink, RouterLinkActive)
   - configuration (Routes)

Initial version:

app.module.ts
-------------

import { RouterModule }   from '@angular/router';


@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot([
      {
        path: 'heroes',
        component: HeroesComponent
      }
    ])
  ],   
  .
  .
  .
})
export class AppModule {
}

We use the 'forRoot' method because we're providing a configured router at the 
ROOT of the application.  

The 'forRoot' method gives us the Router service providers and directives needed
for routing and performs the initial navigation based on the current browser URL.

    RouterModule.forRoot([
      {
        path: 'heroes',
        component:HeroesComponent
      },
      {
        path: 'dashboard',
        component: DashboardComponent
      },
      {
        path: '',
        redirectTo: '/dashboard',
        pathMatch: 'full'
      }
    ])

  forRoot vs forChild
  -------------------

forRoot()
  call only in the root application module, AppModule.
  calling it in any other module, particularly in a lazy loaded module,
  is contrary to the intent and is likely to produce runtime error.

forChild

  always call RouterModule.forChild in a feature-routing module



    Router Outlet

If we paste the path "/heroes" into the browser address bar, the router should 
match it to the 'heroes' route and display the 'HeroesComponent'.

    <a routerLink="/heroes">Heroes</a>
    <router-outlet></router-outlet>


    Parameterized Route


We can add the object's id to the URL.

  /detail/11

  {
    path: 'detail/:id',
    component: HeroDetailComponent
  },  

The (:) in the path indicates that :id is a placeholder to be filled with a
specific hero id when navigating to the HeroDetailComponent

The corresponding [routerLink] for the above route would look like this:

  [routerLink]="['/detail', hero.id]" 

Here, we are binding a link parameters array:

  ['/detail',hero.id]

to our destination route:

  path: 'detail/:id'

The array has two elements:
  path of the destination route
  route parameter set to the value of the current hero's id

routerLinkActive directive
---------------------------

Angular Router provides a routerLinkActive directive to add a class to the HTML 
navigation element whose route matches the active route. Ex:

  <nav>
    <a routerLink="/dashboard" routerLinkActive="active">Dashboard</a>
    <a routerLink="/heroes" routerLinkActive="active">Heroes</a>
  </nav>

  nav a.active {
    color: #039be5;
  }  



================================================================================

  Angular built-in directives
  ***************************

There are three kinds of Angular directives:

1. Components
2. Attribute directives
3. Structural directives


Attribute Directives
---------------------


ngModel

  when developing entry forms, we often want to both display a data property
  and update that property when the user makes changes.

  ngModel implements two-way binding and is an example of an attribute directive.

    NOTE: must import FormsModule in app.module.ts

    <input [(ngModel)]="currentHero.firstName">

  the above can also be achieve with separate bindings to the <input> 
  element's "value" property and "input" event:

    <input [value]="currentHero.firstName"
           (input)="currentHero.firstName=$event.target.value" >

  ngModel hides the complexity behind its own "ngModel" input and 
  "ngModelChange" output properties:

    <input
      [ngModel]="currentHero.firstName"
      (ngModelChange)="currentHero.firstName=$event" >



ngClass

  source: https://coryrylan.com/blog/introduction-to-angular-2-ngclass-and-ngstyle

  creating dynamic styles for your application
  ngClass helps us handle dynamic CSS and CSS classes with the new template syntax

    ex: chaning <div> color property

      pure JavaScript:

        let myDiv = document.getElementById('my-div');
        myDiv.style.color = 'orange';  // update 

    out of the box, angular 2 provides primitives using [property] syntax
    to manipulate elements attributes:

      <div [style.color]="'orange'">
        style using property syntax - this text is orange
      </div>

  we can also using angular2 [property] syntax to assign CSS class to element:

    .blue { color: blue; }

    <div [className]="'blue'">CSS class using property syntax - this text is blue</div>


  manipulating <div> styles with ngStyle and angular2 component properties:

    app.component.css:
    ------------------

    .show-class {
      visibility: visible;
    }

    .hide-class {
      visibility: hidden;
    }


    app.component.ts:
    -----------------
    export class AppComponent {

      ngStyleDivColor: string;
      ngStyleDivFontSize: number;
      spanDisplayedText: string;
      spanDisplayedTextVisible: boolean;

      constructor() {
        this.ngStyleDivColor = 'pink';
        this.ngStyleDivFontSize = 16;
        this.spanDisplayedText = 'show-class';
        this.spanDisplayedTextVisible = true;
      }

      toggle() {
        this.spanDisplayedTextVisible = !this.spanDisplayedTextVisible;
        this.spanDisplayedText = this.spanDisplayedTextVisible ? 
          'show-class' :
          'hide-class';
          
      }
    }

    app.component.html:
    -------------------

    <h2>ngStyle</h2>

    <input [(ngModel)]="ngStyleDivColor" />
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize + 1">+</button>
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize - 1">-</button>

    <div 
        id="using-ngStyle" 
        [ngStyle]="{'color': ngStyleDivColor, 'font-size': ngStyleDivFontSize + 'px', 'font-weight': 'bold'}">
      div style configured with ngStyle
    </div>

    <hr>

    <span id="this-span" [ngClass]="spanDisplayedText">toggled with ngClass</span>
    <button (click)="toggle()">Toggle</button>



ngStyle

  allows us to set inline styles dynamically based on the state of the component.
  binding to ngStyle lets us set many inline styles simultaneously

  with this template:

    <div 
        id="using-ngStyle" 
        [ngStyle]="{'color': ngStyleDivColor, 'font-size': ngStyleDivFontSize + 'px', 'font-weight': 'bold'}">
      div style configured with ngStyle
    </div>
    <input [(ngModel)]="ngStyleDivColor" />
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize + 1">+</button>
    <button (click)="ngStyleDivFontSize = ngStyleDivFontSize - 1">-</button>

  we can manipulate the <div> element styles with the component state:

    export class AppComponent {

      ngStyleDivColor: string;
      ngStyleDivFontSize: number;
      spanDisplayedText: string;
      spanDisplayedTextVisible: boolean;

      constructor() {
        this.ngStyleDivColor = 'pink';
        this.ngStyleDivFontSize = 16;
        this.spanDisplayedText = 'show-class';
        this.spanDisplayedTextVisible = true;
      }
        
    }




Structural Directives
---------------------

  structural directives like ngIf do their magic by using HTML 5 template tag.



ngIf

  conditionally includes a template based on the value of an expression.

  element subtree is physically removed or added to the DOM.

    <div *ngIf="condition">...</div>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.
    The <div> containing "Text to show" is removed or added to the DOM based
    on the value of var 'show'.

      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show">Text to Show</div>



with else

    <div *ngIf="condition; else elseBlock">...</div>
    <ng-template #elseBlock>...</ng-template>

    example: 'ngIf' evaluates expression "show" which the value of variable
    'show' toggled by the button.  
    The <div> containing "Text to show" will either display "primary" text if 
    variable 'show' is true, or alternate - if false.


      <button (click)="show = !show">{{show ? 'hide' : 'show'}}</button>
      show = {{show}}
      <br>
      <div *ngIf="show; else elseBlock">Text to Show</div>
      <ng-template #elseBlock>Alternate text while primary is hidden</ng-template>

with async

    <button (click)="nextUser()">Next User</button>
    <br>
    <div *ngIf="userObserbable | async as user; else loading">
      Hello {{user.first}} {{user.last}}!
    </div>
    <ng-template #loading let-user>Waiting ... (user is {{user|json}})
    </ng-template>


  

  NOTE: visibility (hiding) and ngIf are not the same!

    we can show/hide an element subtree with a class or style binding.
    when we hide the element subtree, it remains in the DOM.  the subtree may
    tie up substantial memory and resources.

    when ngIf is false, Angular physically removes the element subtree from the DOM.
    it destroys components in the subtree potentially freeing up resources and
    resulting in better performance.

    on the flip side, when ngIf becomes true again, the component will be 
    recreated along with its subtree.  This may be expensive.. 

      Design thought: minimize initialization effort and consider caching state
      in a companion service.


ngSwitch

  ~~  do NOT put an (*) in front of ngSwitch ~~  
  use property binding instead.

  ~~ do use (*) with ngSwitchCase and ngSwitchDefault.

  when we want to display one element tree (and its children) from a set of 
  possible element trees, based on some condition.

  Angular puts on the selected element tree into the DOM.

  <span [ngSwitch]="toeChoice">
    <span *ngSwitchCase="'Eenie'">Eenie</span>
    <span *ngSwitchCase="'Meanie'">Meanie</span>
    <span *ngSwitchCase="'Miney'">Miney</span>
    <span *ngSwitchCase="'Moe'">Moe</span>
    <span *ngSwitchDefault>other</span>
  </span>


  we bind the parent NgSwitch directive to an expression returnng a switch value.
  the value is string in this example but it could be anything.

  at any particular time, at most ONE of these spans is in the DOM.

  if none of the spans is a match, Angular adds the default span to the DOM.. 
  and removes and destroys all other spans.

  Three collaborating directives work together here:

    ngSwitch
    ngSwitchCase
    ngSwitchDefault





nfFor
  
  is a repeater directive - our goal is to represent a list of items.
  we define a block of HTML that defines how  a single item should be 
  displayed - and we tell angular to use that block as template for rendering 
  each item in the list.

    ngFor applied to a simple <div>:

      <div *ngFor="let hero of heroes">{{hero.fullName}}</div>

    ngFor applied to a component element

      <hero-detail *ngFor="let hero of heroes" [hero]="hero"></hero-detail>



* and <template>

  the (*) is a bit of syntactic sugar that makes it easier to read and write 
  directives that modify HTML layout with the help of templates.

  NgFor, NgIf, and NgSwitch all add and remove element subtrees that are wrapped
  in <template> tags.

  This is how Angular expands *ngIf for example:

    <hero-detail *ngIf="currentHero" [hero]="currentHero"></hero-detail>

  1st expansion:

    <hero-detail 
        template="ngIf:currentHero" [hero]="currentHero"></hero-detail>    

  2d expansion:

    <template [ngIf]="currentHero">
      <hero-detail [hero]="currentHero"></hero-detail>
    </template>




Custom Attribute directives 

  HostListener
  HostBinding 
    class decorators
    prefer using these to the 'host' property of the @Directive and @Component decorators

    

================================================================================

  HTTP Services
  *************

The HttpModule is not a core Angular module.
It's Angular's optional approach to web access and it exists in a separate 
add-on module called @angular/http.

app.module.ts:

import { HttpModule }   from '@angular/http';

@NgModule({
  imports: [
    HttpModule
  ],
})
export class AppModule { }

Angular team recommends registering application-wide services in the root 
'AppModule' providers.


================================================================================

  Mocking HTTP Services with angular-in-memory-web-api
  ****************************************************

https://github.com/angular/in-memory-web-api
http://www.thoughtdelimited.org/thoughts/post.cfm/adding-the-in-memory-web-api-to-an-systemjs-based-angular-cli-application

in-memory web API is not part of the Angular core.
it is an optional service in its own "angular-in-memory-web-api" library installed 
with npm via package.json

Find out the latest version of 'angular-in-memory-web-api' available:

 $ npm view angular-in-memory-web-api versions
 
[ '0.1.0',
  '0.1.1',
  '0.1.2',
  '0.1.3',
  '0.1.4',
  '0.1.5',
  '0.1.6',
  '0.1.7',
  '0.1.8',
  '0.1.9',
  '0.1.10',
  '0.1.11',
  '0.1.12',
  '0.1.13',
  '0.1.14',
  '0.1.15',
  '0.1.16',
  '0.1.17' ]


$ npm install angular-in-memory-web-api --save

  "dependencies": {
    "@angular/common": "2.2.1",
    "@angular/compiler": "2.2.1",
    "@angular/core": "2.2.1",
    "@angular/forms": "2.2.1",
    "@angular/http": "2.2.1",
    "@angular/platform-browser": "2.2.1",
    "@angular/platform-browser-dynamic": "2.2.1",
    "@angular/router": "3.2.1",
    "angular-in-memory-web-api": "^0.1.17",



in-memory-data.service.ts
-------------------------



Learn more about In-Memory Web API
----------------------------------
https://angular.io/docs/ts/latest/guide/server-communication.html#!#in-mem-web-api

If the app only needs to retrieve data, you could get heroes from a heroes.json:

{
  "data": [
    { "id": 1, "name": "Windstorm" },
    { "id": 2, "name": "Bombasto" },
    { "id": 3, "name": "Magneta" },
    { "id": 4, "name": "Tornado" }
  ]
}


You wrap the heroes array in an object with a 'data' property for the same reason
that a data server does - to mitigate the security risk posed by top-level 
JSON arrays.

You'd set the endpoint to the JSON file like this:

  private heroesUrl = 'app/heroes.json'; // URL to JSON file


The GET heroes scenario would work, but you can't save changes to a JSON file.

The in-mem web API gets its data from a custom application class with a createDb() 
method that returns a map whose keys are collection names and whose values are
arrays of objects in those collections.


in-mem-data.service.ts
-----------------------

  import { Injectable } from '@angular/core';
  import { InMemoryDbService } from 'angular-in-memory-web-api';

  @Injectable()
  export class InMemoryDataService implements InMemoryDbService{

    constructor() { }

    createDb() {
      let heroes = [
        { id: 11, name: 'Mr. Nice' },
        { id: 12, name: 'Narco' },
        { id: 13, name: 'Bombasto' },
        { id: 14, name: 'Celeritas' },
        { id: 15, name: 'Magneta' },
        { id: 16, name: 'RubberMan' },
        { id: 17, name: 'Dynama' },
        { id: 18, name: 'Dr IQ' },
        { id: 19, name: 'Magma' },
        { id: 20, name: 'Tornado' }
      ];
      return {heroes};  // NOTE: curly braces!
    }

  }


Ensure that the HeroService endpoint refers to the web API

hero.service.ts
---------------

  private heroesUrl = 'api/heroes';   // URI to web api


Finally, redirect client HTTP requests to the in-memory web API by adding the
InMemoryWebApiModule to the AppModule.imports list, and call its forRoot() 
configuration method:

    InMemoryWebApiModule.forRoot(InMemoryDataService)

How This Works
==============

Angular's http service delegates the client/server communication tasks to a 
helper service called XHRBackend.

Using standard Angular provider registration techniques, the InMemoryWebApiModule
replaces XHRBackend service with its own in-memory alternative.

The forRoot() method initializes the in-mem web API with the seed data from the 
mock hero dataset.

    NOTE: 
    
    1. the "forRoot" method name is a strong reminder that you should 
    only call the InMemoryWebApiModule ONCE while setting the metadata for the 
    root AppModule

    2. Import the InMemoryWebApiModule AFTER the HttpModule to ensure that
    the XHRBackend provider of the InMemoryWebApiModule supersedes all others.

      import { HttpModule }           from '@angular/http';
      import { InMemoryWebApiModule } from 'angular-in-memory-web-api';


Passthru to a live XHRBackend
-----------------------------

If an existing running remote server should handle requests for collections
that not in the in-memory database, set 

  Config.passThruUknownUrl: true

This service will forward unrecognized requests via a base version of the 
Angular XHRBackend.




================================================================================

  Applications Styles
  *******************

When we add styles to a component, we're keeping everything a component needs -
HTML, the CSS, the code - together in one convenient place.

We can also create styles at the application level outside of any component.

angular-cli provides styles.css at the index.html level and it's already 
integrated into the project via 

angular-cli.json:

      "styles": [
        "styles.css"
      ],

styles.css - allows users to add global styles and supports CSS imports

  if the project is created with the --style=sass option, this will be a
  .sass file instead and the same applies to scss/less/style.

You can add more global styles via the apps[0].styles property in
angular-cli.json


================================================================================

  go back browser back button
  ***************************

to navigate one step in the browser's history stack using the 'Location' service

  this.location.back()

Going back too far could take us out of the application.
Guard against that with

  CanDeactivate guard  

================================================================================    

  Guard Services
  **************
https://angular.io/docs/ts/latest/guide/router.html#guards  


================================================================================

  Caching Service options
  ***********************

ng2-cache
https://www.npmjs.com/package/ng2-cache
https://github.com/Jackson88/ng2-cache


angular2-cache





================================================================================

  Caching with RxJs Observables in Angular 2
  ******************************************

http://www.syntaxsuccess.com/viewarticle/caching-with-rxjs-observables-in-angular-2.0

http://restlet.com/blog/2016/04/12/interacting-efficiently-with-a-restful-service-with-angular2-and-rxjs-part-2/

http://stackoverflow.com/questions/36271899/what-is-the-correct-way-to-share-the-result-of-an-angular-2-http-network-call-in



================================================================================

  Forms
  *****

Debugging forms with `spy` template reference variable
---------------------------

https://angular.io/guide/forms

Temporarily add a template reference variable named spy to the Name <input> tag and use it to display the input's CSS classes.

  <input type="text" class="form-control" id="name"
    required
    [(ngModel)]="model.name" name="name"
    #spy>
  <br>TODO: remove this: {{spy.className}}


================================================================================

  Testing
  *******

================================================================================

  Controlling which tests run in Jasmine
  **************************************

http://thejsguy.com/2016/01/03/controlling-which-tests-run-in-jasmine.html


Only Running Specific Tests / Specs
------------------------------------

If you want to run a specific test, use fit() instead of it(). The f stands for focused.

  describe("description", function() {
    fit("test 1", function() {

    });

    it("test 2", function() {

    });
  });

In the example above, only test 1 will execute. You can use as many fit() calls as you would like and only those tests will execute. Similar to when you exclude tests, if you are using Jasmine with Karma, the output on the terminal will note how many tests executed and how many were skipped.

What if you want to only run a specific describe() block? As you might guess, use fdescribe() instead of describe().

  fdescribe("description", function() {
    it("test 1", function() {

    });

    it("test 2", function() {

    });

    it("test 3", function() {

    });
  });

It is also worth noting that you can have focused and unfocused tests/specs inside nested fdescribe() blocks. When you do this, only the focused tests will run. For example:

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });

    fit("test 2", function() {

    });
  });

  fit("test 3", function() {

  });

  it("test 4", function() {

  });
});

In the example above, only test 2 and test 3 will run.

If your fdescribe() block only has a single test/spec, you can just use it() and that test will execute.

fdescribe("description", function() {
  fdescribe("description", function() {
    it("test 1", function() {

    });
  });

  fit("test 2", function() {

  });

  it("test 3", function() {

  });
});
In the example above, only test 1 and test 2 will execute.    


Excluding Tests / Specs
-----------------------

If you want to exclude a specific test, simply use xit() instead of it(). The x means exclude.

  describe("description", function() {
    xit("description", function() {

    });
  });

If you want to exclude an entire describe block, use xdescribe() instead of describe().

  xdescribe("description", function() {
    it("description", function() {

    });

    it("description", function() {

    });
  });

When you exclude tests, these tests will be noted as “skipped”.

================================================================================


  Angular Testing
  ***************

https://angular.io/guide/testing


Jasmine
  test framework
  ships with an HTML test runner that executes tests in browser

Angular testing utilities
  create a test environment for the angular application code under test
  use them to condition and control parts of the application as they 
  interact within the Angular environment

Karma
  test runner ideal for writing and running unit tests while developing
  the application.

Protractor
  use it to write and run e2e tests.
  in e2e testing, one process runs the real application, and a second process
  runs protractor tests that simulate user behavior and assert that the
  application responds in the browser as expected.


================================================================================

  Introduction to Jasmine
  ***********************

testing framework from Pivotal Labs using behavior driven notation.

Suites
  describe(string, function)  
    take a title and a function
    containing one or more specs

Specs
  it(string, function) functions
    take a title and a function containing one or more expectations

Expectations
  are assertions that evaluate to true or false:
    expect(actual).toBe(expected)

Matchers
  are predefined helpers for common assertions:
    toBe(expected)      - reference equality
    toEqual(expected)   - deep comparison

    complete list: https://github.com/JamieMason/Jasmine-Matchers

Setup / Teardown

  beforeEach
  afterEach

  beforeAll
  afterAll


================================================================================

  Angular Unit Testing
  ********************

@see 
    https://github.com/angular/angular.io
    https://github.com/angular/angular.io/tree/master/public/docs/_examples/testing/ts/src



spec file

  tests written in Jasmine are called specs
  the file extension must be .spec.ts - convention expected in karma.conf.js
  which looks for spec file in src/app folder


TestBed

  TestBed is the first and most important of Angular testing utilities - used
  to set up the dependencies for our tests.

  it creates an Angular testing module - an @NgModule class - that you 
  configure with the 'configureTestingModule' method to produce the 
  module environment for the class you want to test.

  in effect, you detach the tested component from its own application 
  module and re-attach it to a dynamically-constructed Angular test module
  tailored specifically for this battery of tests.

  ComponentFixture 

    a handle on the test environment surrounding the created component.
    provides access to the component itself and to the DebugElement which is 
    a handle to the component's DOM element.

    let fixture: ComponentFixture<BannerInlineComponent>;
    let component: BannerInlineComponent;
    let de: DebugElement;
    let el: HTMLElement;
    ...

    beforeEach( () => {
      ...

      fixture = TestBed.createComponent(BannerInlineComponent);
      component = fixture.componentInstance;
      de = fixture.debugElement.query(By.css('h1'));
      el = de.nativeElement;

    })


    fixture returned from TestBed.createComponent is your component under test
    with several additional properties and methods:

      detectChanges()
        force a walk of the data graph and update the view with relevant content

        In the actual application, change detection kicks in automatically when
        Angular creates a component or the user enters a keystroke or an AJAX
        activity completes.
        TestBed.createComponent() does not trigger change detection.
        This behavior (or lack of it) is intentional - it gives the tester
        an opportunity to inspect or change the state of the component 
        before Angular initiates data binding or calls lifecycle hooks.


      componentInstance
        actual component under test - you can call methods on the component

      DebugElement

        angular class that contains all kinds of references and methods 
        that help you introspect the element

      nativeElement
        the DOM element of the template your component owns.



TestBed.compileComponents()

  WebPack developers need not call 'compileComponents' because it inlines
  templates and css as part of the automated build process that precedes
  running the test.

  Q: when am I supposed to call compileComponents()?

    angular docs doesn't explain
     - in what circumstances it is "necessary" to call this function
     - what are the consequences of not doing so

  A: if you're using webpack, the build will compile the templateUrls 
  into inline templates and styleUrls to styles.
  so there is no need to 'compileComponents' because it is jsut like 
  you're using template and styles .. 

  if you're using SystemJS, this doens't happen.  Angular will need to 
  make XHR requests to retrieve the external templates and styles, and 
  then compile.  Here you will need to 'compileComponents'.


  DO NOT configure the TestBed AFTER calling 'compileComponents' - it closes 
  the current TestBed instance to further configuration.  
  Make it the last step before calling TestBed.createComponent() to instantiate
  the component-under-test.


inject

  allows us to get dependencies at the TestBed level

  it('should return ... ', inject([MyService], service => {
    service.foo();
  }));




beforeEach(async(..))

  async is necessary to all the asynchronous TestBed.compileComponents method.
  Internally, async arranges for the body of the 'beforeEach' to run in a 
  special async test zone.

  https://stackoverflow.com/questions/40126729/angular-2-testing-async-function-call-when-to-use

  'async' will allow the next test not to start until the 'async' 
  finishes all it's tasks.

  What 'async' does is wrap the callback in a Zone, where all async tasks
  (e.g. setTimeout) are tracked.  Once all the async tasks are complete,
  then the 'async' completes.

  If you've ever worked with Jasmine outside of Angular, you may have seen
  'done' being passed to the callback:

  it('..', function(done) {
    someAsyncAction().then( () => {
      expect(something).toBe(something);
      done();
    });
  });

  With Angular (in a Jasmine environment), Angular will actually call
  'done' behind the scenes, when we use 'async'.  It will keep track of 
  all the async tasks in the Zone, and when they are all finished, 'done' will be 
  called behind the scenes.

  With TestBed configuration, you would use this generally when you want
  to 'compileComponents'.

  When testing a component that uses templateUrl (if you're not using webpack)
  then Angular needs to make an XHR request to get the template, so the 
  communication is asynchronous.


beforeEach( ... )

  the second 'beforeEach' containing the remaining setup follows the async
  beforeEach.

  Typically, here you create the instance of the component-under-test and
  query the elements to inspect:

    component = fixture.createComponentInstance;
    de = fixture.debugElement.query(By.css('h1'));
    el = de.nativeElement;

  The test runner will wait for the first async 'beforeEach' to finish
  before calling the 2nd one.

    compileComponents returns a promise so you can perform add'l tasks 
    immediately after it finishes.. e.g.:

      compileComponents()
        .then(...)

    but most find this hard to read.

    The two beforeEach calls are widely preferred.



    Change Detection
    ----------------

  detectChanges()

        In the actual application, change detection kicks in automatically when
        Angular creates a component or the user enters a keystroke or an AJAX
        activity completes.
        TestBed.createComponent() does not trigger change detection.
        This behavior (or lack of it) is intentional - it gives the tester
        an opportunity to inspect or change the state of the component 
        before Angular initiates data binding or calls lifecycle hooks.    

You can call changeChanges in 

  beforeEach

    fixture = TestBed.createComponent(Comp);
    fixture.detectChanges();

  in each test 

    it('should do something', () => {
      fixture.detectChanges();
      ...
    });

  automatically

    some testers prefer that the Angular test environment run change detection
    automatically with the ComponentFixtureAutoDetect provider:

      import { ComponentFixtureAutoDetect } from '@angular/core/testing';

    then add it to the providers array of the testing module configuration:

      TestBed.configureTestingModule({
        declarations: [ Banner Component ],
        providers: [
          { provide: ComponentFixtureAutoDetect, useValue: true }
        ]
      })

    IMPORTANT: ComponentFixtureAutoDetect service responds to ASYNC activities
    such as promise resolution, timers, DOM events.
    But a direct, synchronous update of the component is invisible.
    The test call fixture.detectChanges() manually to trigger another cycle
    of change detection.


  *********************************************************************
  * Rather than wonder when the text fixture will or will not perform *
  * change detection, just always call detectChanges() explicitly.    *
  * There is NO harm in calling detectChanges() more often then is    *
  * strictly necessary                                                *    
  *********************************************************************

  NOTE:   
          if I have 'fixture.detectChanges' in the 2nd beforeEach, and then
          in tests, change detection did not work.

          I noticed that in the angular test guide, they do NOT have 
          fixture.detectChanges in beforeEach, but then use it in every 
          test when needed:

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/welcome.component.spec.ts

          2. the default tests created by angular-cli put 
          fixture.detectChanges into the 2nd beforeEach(..)
          however, the generated test specs do not have any in the tests ..




================================================================================

  Stubbing Component's Dependency just to satisfy the dependency
  ********************************

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/app.component.spec.ts  

If you're testing a component, and it has a dependency on another 
component (which in turn has dependencies on other services, for instance).. 
and you're not asserting anything on this dependency component.. 

you might as well just stub it out:

  // stub WelcomeComponent
  @Component({selector: 'app-welcome', template: ''})
  class WelcomeStubComponent {}


  describe('AppComponent', () => {
    beforeEach(async(() => {
      TestBed.configureTestingModule({
        declarations: [
          AppComponent,
          BannerInlineComponent, 
          WelcomeStubComponent    // declare the stubbed out component
        ],
      }).compileComponents();
    }));

    .
    .
    .

  });



================================================================================

  Testing Component with a Dependency
  ***********************************

https://github.com/angular/angular-es/blob/master/public/docs/_examples/testing/ts/app/welcome.component.spec.ts


$ mkdir src/app/model
$ ng g s model/user --flat true --spec false
installing service
  create src/app/model/user.service.ts
  WARNING Service is generated but not provided, it must be provided to be used

$ ng g c welcome

The 'WelcomeComponent' displays a welcome mesage to the logged in user.
It knows the user based on the property of the injected 'UserService'.

in welcome.component.spec.ts

  do not provide the real service - use a test double instead:

    let userServiceStub: {
      isLoggedIn: boolean;
      user: {name: string};
    };

    beforeEach(async( () => {
      userServiceStub = {
        isLoggedIn: true,
        user: { name: 'Test User'}
      };
  
      TestBed.configureTestingModule({
        declarations: [ WelcomeComponent ],
        providers: [
          { provide: UserService, useValue: userServiceStub}
        ]
      }).compileComponents();

    }));


The tests need access to the (stubbed) UserService injected into the 
WelcomeComponent.

  Angular has a hierarchical injection system.  There can be injectors at 
  multiple levels, from the root injector created by the TestBed down through
  the component tree.

The safest way to get the injected service (always works!) is to get it from
the injector of the component-under-test.

  Component Injector
  ------------------

The component injector is a property of the fixture's DebugElement:

  // UserService injected into the component
  userService = fixture.debugElement.injector.get(UserService);

    TestBed.get(..)

      you may be able to get the service from the root injector via 
      TestBed.get - it is easier to remember and less verbose.
      But it only works when Angular injects the component with the service
      instance in the test's root injector.
      In this test suite, the ONLY provider of UserService is the root testing
      module, so it would be safe to call TestBed.get like so:

        userService = TestBed.get(UserService);

  NEVER reference the 'userServiceStub' object that's provided to the testing
  module in the body of your test - THIS WOULDN'T WORK - the userService 
  instance injected into the component is a DIFFERENT objeect - a clone of the
  provided userServiceStub.


================================================================================

  Stub out service
  ****************

import ...

var mockStory = {
  id: 1,
  title: 'Blah',
  ...
}

class MockStoryService {
  public getStory(id): Observable<StoryModel> {
    return Observable.of(mockStory);
  }
}

describe('Story', () => {
  var storyFixture,
      story,
      storyE1;

  beforeEach(
  );


}




================================================================================

  Test componet with an async service
  ***********************************

Many services return values async'ly. Most data services make an HTTP request
to a remote server and the response is necessarily asynchronous.

In general, tests should not make calls to remote servers.  They should emulate
such calls.  The setup in src/apps/shared/twain.component.spec.ts shows one way.

  The twain.component.ts handles the display of Twain quotes returned by the
  TwainService.  Both are in src/app/shared.

  $ ng g c shared/twain --flat -it -is
  installing component
    create src/app/shared/twain.component.spec.ts
    create src/app/shared/twain.component.ts
    update src/app/app.module.ts

  $ ng g s shared/twain --module=app.module
  installing service
    create src/app/shared/twain.service.spec.ts
    create src/app/shared/twain.service.ts
    update src/app/app.module.ts

note: this automatically provides the service in app.module.ts

Tests still pass at this point.. 



  Spying on the real service
  --------------------------

This setup is similar to the welcome.component.spec.setup
but instead of stubbing the servide, it injects the REAL service 
and replaces the critical 'getQuote' method with a Jasmine spy.


  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ TwainComponent ],
      providers: [ TwainService ]  // provide TwainService
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(TwainComponent);
    component = fixture.componentInstance;

    twainService = fixture.debugElement.injector.get(TwainService);
    spy = spyOn(twainService, 'getQuote')
      .and.returnValue(Promise.resolve(testQuote));  // spy on it

    de = fixture.debugElement.query(By.css('.twain'));
    el = de.nativeElement;

  });

The spy is designed in such a way that any call to 'getQuote' receives an 
immediately resolved promise with a test quote.
They spy bypasses the actual 'getQuote' method and therefore does not contact
the server.

  Faking a service instance and spying on a real object are BOTH great
  options.  Pick one that seems easiest for the current test suite.

    Spying on the real service isn't always easy, especially when the real 
    servide has injected dependencies.

    You can even STUB and SPY at the same time!

Tests need to become asynchronous in order to pick up the quote returned 
from the service which gets initialized in ngOnInit()

service.getQuote is called in the component's ngOnInit() method, 
and ngOnInit() is called during the first change detection cycle.
but the tests need to wait at least one more full turn of the JS engine
before the value becomes available.


async() 

  the async function is one of the Angular testing activities.
  it simplifies coding of asynch tests by arranging for the tester's
  code to run in a special 'async test zone'.

  async hides most of the asynchronous boilerplate, but some functions
  called within a test (such as fixture.whenStable) continue to reveal
  their async behavior

whenStable

  the test must wait for the getQuote() promise to resolve in the next 
  turn of the JS engine.

  getQuote() is called within the TwainComponent.ngOnInit() method and
  therefore inaccessible to a test that probes only the component API.

  fortunately, the getQuote promise is accessible to the 'async test zone', 
  which intercepts all promises issued with the async method call 
  NO MATTER WHERE THEY OCCUR

  The ComponentFixture.whenStable returns its own promise which resolves
  when the getQuote promise finishes.  In fact, the 'whenStable' promise
  resolves when all pending async activities within this test complete -
  the definition of "stable".

    it('should show quote after getQuote promise (async)', async(() => {
      fixture.detectChanges();

      fixture.whenStable().then(() => { // wait for async getQuote
        fixture.detectChanges();        // update view with quote
        expect(el.textContent).toBe(testQuote);
      });
    }));

  then, the test resumes and kicks off another round of change detection
  which tells Angular to update the DOM with the quote.


fakeAsync

  it('should do something.. ', fakeAsync( () => {
    fixture.detectChanges();
    tick();                   // wait for async getQuote
    fixture.detectChanges();  // update view with quote
    expect(el.textContent).toBe(testQuote);
  }));

  fakeAsync is used instead of async.
  It enables a linear coding style by running the test body in a special fakeAsync test zone.

  main advantage of fakeAsync over async is that the test appears to be synchronous.  There is no then(...) to disrupt the visible flow of control.
  the promise-returning 'fixture.whenStable' is gone replaced by tick()

    The limitation - you cannot make XHR calls from within a fakeAsync


tick()

  is a companion to fakeAsync and you can only call it within faceAsync body.

  simulates the passage of time until all pending async activities flush
  it returns nothing
  there's no promise to wait for - proceed with the same test code that 
  appeared in the whenStable.then() callback.


jasmine.done

  while the 'async' and 'fakeAsync' simplify Angular async testing, you can
  still use the traditional Jasmine async testing technique:

    it('should show quote after getQuote promise is done', (done: any) => {
      fixture.detectChanges();

      // get the spy promise and wait for it to resolve
      spy.calls.mostRecent().returnValue.then( () => {
        ...
        fixture.detectChanges();
        expect(..);
        done();
      });
    });

  Although there is no direct access to the getQuote promise inside
  TwainComponent, the spy has direct access which makes it possible to 
  wait for 'getQuote' to finish.    




  Test a component with inputs and outputs 
  ----------------------------------------


such component typically appears inside the view template of the host component. the host uses a property binding to set the input property and an event binding to listen to events raised by the output property.

the testing goal is to verify that such bindings work as expected.
the tests should set input values and listen for output events.

the 'DashboardHeroComponent' is a tiny component that displays an individual
hero provided by the 'DashboardComponent'.

    NOTE:  MAKE SURE TO ADD YOUR MODULE files:
    e.g.:
      if 
        you add dashboard/dashboard.module.ts
      then
        you need to import it in your app.module.ts:

          @NgModule({
            imports: [
              DashboardModule,
              AppRoutingModule
            ],
            providers: [ <services> ],
            declarations: [ <components-not-part-of-dashboard-module> ],
            bootstrap: [ AppComponent ]
          })
          export class AppModule { }

      and in your dashboard.module.ts
        - import your dashboard-routing.module.ts

    NOTE:  ONCE YOU ADD routing YOUR app.component.spec.ts will fail -
           as it doesn't know what <router-outlet> is

          NO_ERRORS_SCHEMA

            adding NO_ERRORS_SCHEMA to the testing module's 'schema' metadata
            will tell the compiler to ignore unrecognized elements and attributes.

              beforeEach( async( () => {

                TestBed.configureTestingModule({
                  declarations: [
                    AppComponent,
                    RouterLinkStubDirective
                  ],
                  schemas: [ NO_ERRORS_SCHEMA ]
                })
                .compileComponents()
                .then( () => {
                  fixture = TestBed.createComponent(AppComponent);
                  comp = fixture.componentInstance;
                });
              });


            these tests are SHALLOW b/c they only "go deep" into the components
            you want to test

  create dashboard-hero component:

    $ ng g c dashboard/dashboard-hero --flat -is -it -m dashboard/dashboard.module.ts


  note: when you have properties declared with @Input(),
  you need to initialize those in your test:


  create 'hero' module

    $ ng g m hero --module=app --routing
    installing module
      create src/app/hero/hero-routing.module.ts
      create src/app/hero/hero.module.ts
      update src/app/app.module.ts


  create 'hero-list' component within 'hero' module

    $ ng g c hero/hero-list --module hero
    installing component
      create src/app/hero/hero-list/hero-list.component.css
      create src/app/hero/hero-list/hero-list.component.html
      create src/app/hero/hero-list/hero-list.component.spec.ts
      create src/app/hero/hero-list/hero-list.component.ts
      update src/app/hero/hero.module.ts


  create 'hero-detail' component within 'hero' module

    $ ng g c hero/hero-detail --module hero
    installing component
      create src/app/hero/hero-detail/hero-detail.component.css
      create src/app/hero/hero-detail/hero-detail.component.html
      create src/app/hero/hero-detail/hero-detail.component.spec.ts
      create src/app/hero/hero-detail/hero-detail.component.ts
      update src/app/hero/hero.module.ts




================================================================================

  default test template created by angular-cli
  ********************************************

  angular-cli creates a new describe Suite for the new component
  it just created.

  It comes with (2) beforeEach:

    beforeEach(async) - compileComponents
    beforeEach()      - creates fixture/component/etc instances
                        and runs detectChanges on the fixture.


  describe('GreeterComponent', () => {
    let component: GreeterComponent;
    let fixture: ComponentFixture<GreeterComponent>;

    beforeEach(async(() => {
      console.log('beforeEach(async)');
      TestBed.configureTestingModule({
        declarations: [ GreeterComponent ]
      })
      .compileComponents();
    }));

    beforeEach(() => {
      console.log('beforeEach()');
      fixture = TestBed.createComponent(GreeterComponent);
      component = fixture.componentInstance;
      fixture.detectChanges();  // I'VE SEEN THIS CREATE PROBLEM IF TEST ALSO do this!!!
    });

    it('should create', () => {
      expect(component).toBeTruthy();
    });
  });



================================================================================

  Example: test LanguageService component
  ----------------------------------------

1. load the dependencies requireq for the test with TestBed.configureTestingModule
2. use 'inject' to automatically instantiate each dependency

  describe('Service: LanguageService', () => {

    beforeEach( () => TestBed.configureTestingModule({
      providers: [ LanguageService ]
    }));

    it('should return available languages', inject([LanguageService], service => {
      expect(service.get()).toContain('en');
    }));

  })

3. refactor the 'inject' so it is not repeated for each spec:


  describe('Service: LanguageService', () => {

    let service;

    beforeEach( () => TestBed.configureTestingModule({
      providers: [ LanguageService ]
    }));

    beforeEach(inject([LanguageService], s => {
      service = s;
    }));

    it('should return available languages', () => {
      expect(service.get()).toContain('en');
    });
 
  })


  Example: instantiating a Component
  ----------------------------------

    // Synchronous:

    beforeEach( () => {
      fixture = TestBed.createComponent(MyComponentUnderTest);
    });

    // Async

    beforeEach( async( () => {
      TestBed.configureTestingModule({
        declarations: [ MyComponentUnderTest ],
      }).compileComponents();  // compile external templates and css
    }));

  we can use async() when dependencies involve async handling. 
  this will internally create a zone and deal with async processing.
  

  Example: testing a component
  ----------------------------

  // Component
  // usage: <greeter name="Joe"></greeter>
  // renders: <h1>Hello Joe!</h1>

  @Component({
    selector: 'greeter',
    template: `<h1>Hello {{name}}!</h1>`
  })

  export class Greeter {
    @Input() name;
  }


================================================================================

  Access elements
  ***************

let de: DebugElement;
let el: HTMLElement;

de = fixture.debugElement.query(By.css('#some-id'));
el = de.nativeElement;

expect(nativeElement.querySelector('#some-id') === null).toBe(false);

// trigger the button
nativeElement.querySelector('#some-id').click();



================================================================================

Test Debugging

  Debug specs in browser in the same way that you debug an application

  1. click DEBUG button in the browser
    it opens a new tab and re-runs the test(s)

  2. open Developer Tools (ctr-shift-i)

  3. pick the "sources" section

    important: for the next step to work, you need to FIRST
      right-click anywhere in the Sources view
      and "Add folder to workspace" and select src/app


  4. open your ".spec.ts" test file (ctrl-P, then start typing name of file)

  5. set a breakpoint in the test

  6. refresh the browser and it stops at the breakpoint.





================================================================================

  Error Handling
  **************

https://angular.io/api/core/ErrorHandler  

Catching global errors
----------------------

  https://stackoverflow.com/questions/44108285/angular-4-custom-errorhandler-doesnt-recognize-custom-error
  https://dpopescu.me/2016/10/21/catching-global-errors-in-angular-2/


================================================================================





